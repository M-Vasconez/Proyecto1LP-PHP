Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADDITION
    ADVANCE_PAGE
    BOOLEAN_AND
    BOOLEAN_OR
    CLOSE_TAG
    COMILLA_DOBLE
    DIVISION
    ESCAPE
    EXPONENTIATION
    FGETS
    FOR
    FSCANF
    IDENTITY
    LBRACKET
    MODULO
    MULTIPLICATION
    NEGATION
    NEW
    NOT
    NULL
    OPEN_TAG
    OPERADOR_CONCATENACION
    OPERADOR_DECREMENTO
    OPERADOR_INCREMENTO
    PUSH
    RBRACKET
    READLINE
    SETSIZE
    SINTAXIS_ARRAY
    SPLEDOUBLYLINKEDLIST
    SPLFIXEDARRAY
    SUBTRACTION
    TAB_VERTICAL
    WHITESPACE
    XOR

Grammar

Rule 0     S' -> cuerpo
Rule 1     cuerpo -> salida
Rule 2     cuerpo -> asignacion
Rule 3     cuerpo -> funcion
Rule 4     cuerpo -> estructuras_control
Rule 5     cuerpo -> bucles
Rule 6     salida -> ECHO valor ENDLINE
Rule 7     salida -> PRINT LPAREN valor RPAREN
Rule 8     valor -> ARGUMENTO
Rule 9     valor -> INTEGER
Rule 10    valor -> FLOAT
Rule 11    valor -> BOOLEAN
Rule 12    valor -> STRING
Rule 13    valor -> VARIABLE
Rule 14    funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
Rule 15    asignacion -> VARIABLE operador_asignacion valor ENDLINE
Rule 16    operador_asignacion -> EQUAL
Rule 17    operador_asignacion -> PLUS_EQUAL
Rule 18    operador_asignacion -> CONCAT_EQUAL
Rule 19    operador_comparacion -> IS_EQUAL
Rule 20    operador_comparacion -> IS_GREATER_OR_EQUAL
Rule 21    operador_comparacion -> IS_NOT_EQUAL
Rule 22    operador_comparacion -> IS_SMALLER_OR_EQUAL
Rule 23    operador_comparacion -> IS_GREATER
Rule 24    operador_comparacion -> IS_SMALLER
Rule 25    estructuras_control -> if
Rule 26    estructuras_control -> else
Rule 27    bucles -> while
Rule 28    if -> IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY
Rule 29    else -> if ELSE LKEY cuerpo RKEY
Rule 30    expresion_logica -> BOOLEAN
Rule 31    expresion_logica -> valor AND valor
Rule 32    expresion_logica -> valor OR valor
Rule 33    while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON

Terminals, with rules where they appear

ADDITION             : 
ADVANCE_PAGE         : 
AND                  : 31
ARGUMENTO            : 8 14 14
BOOLEAN              : 11 30
BOOLEAN_AND          : 
BOOLEAN_OR           : 
CLOSE_TAG            : 
COLON                : 33
COMILLA_DOBLE        : 
CONCAT_EQUAL         : 18
DIVISION             : 
ECHO                 : 6
ELSE                 : 29
ENDLINE              : 6 15
EQUAL                : 16
ESCAPE               : 
EXPONENTIATION       : 
FGETS                : 
FLOAT                : 10
FOR                  : 
FSCANF               : 
FUNCTION             : 14
IDENTITY             : 
IF                   : 28
INTEGER              : 9
IS_EQUAL             : 19
IS_GREATER           : 23
IS_GREATER_OR_EQUAL  : 20
IS_NOT_EQUAL         : 21
IS_SMALLER           : 24
IS_SMALLER_OR_EQUAL  : 22
LBRACKET             : 
LKEY                 : 14 28 29
LPAREN               : 7 14 28 33
MODULO               : 
MULTIPLICATION       : 
NEGATION             : 
NEW                  : 
NOT                  : 
NULL                 : 
OPEN_TAG             : 
OPERADOR_CONCATENACION : 
OPERADOR_DECREMENTO  : 
OPERADOR_INCREMENTO  : 
OR                   : 32
PLUS_EQUAL           : 17
PRINT                : 7
PUSH                 : 
RBRACKET             : 
READLINE             : 
RKEY                 : 14 28 29
RPAREN               : 7 14 28 33
SETSIZE              : 
SINTAXIS_ARRAY       : 
SPLEDOUBLYLINKEDLIST : 
SPLFIXEDARRAY        : 
STRING               : 12
SUBTRACTION          : 
TAB_VERTICAL         : 
VARIABLE             : 13 14 15
WHILE                : 33
WHITESPACE           : 
XOR                  : 
error                : 

Nonterminals, with rules where they appear

asignacion           : 2
bucles               : 5
cuerpo               : 28 29 0
else                 : 26
estructuras_control  : 4
expresion_logica     : 28
funcion              : 3
if                   : 25 29
operador_asignacion  : 15
operador_comparacion : 33
salida               : 1
valor                : 6 7 15 31 31 32 32 33 33
while                : 27

Parsing method: LALR

state 0

    (0) S' -> . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . asignacion
    (3) cuerpo -> . funcion
    (4) cuerpo -> . estructuras_control
    (5) cuerpo -> . bucles
    (6) salida -> . ECHO valor ENDLINE
    (7) salida -> . PRINT LPAREN valor RPAREN
    (15) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (14) funcion -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (25) estructuras_control -> . if
    (26) estructuras_control -> . else
    (27) bucles -> . while
    (28) if -> . IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY
    (29) else -> . if ELSE LKEY cuerpo RKEY
    (33) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON

    ECHO            shift and go to state 7
    PRINT           shift and go to state 8
    VARIABLE        shift and go to state 9
    FUNCTION        shift and go to state 10
    IF              shift and go to state 14
    WHILE           shift and go to state 15

    cuerpo                         shift and go to state 1
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    funcion                        shift and go to state 4
    estructuras_control            shift and go to state 5
    bucles                         shift and go to state 6
    if                             shift and go to state 11
    else                           shift and go to state 12
    while                          shift and go to state 13

state 1

    (0) S' -> cuerpo .



state 2

    (1) cuerpo -> salida .

    $end            reduce using rule 1 (cuerpo -> salida .)
    RKEY            reduce using rule 1 (cuerpo -> salida .)


state 3

    (2) cuerpo -> asignacion .

    $end            reduce using rule 2 (cuerpo -> asignacion .)
    RKEY            reduce using rule 2 (cuerpo -> asignacion .)


state 4

    (3) cuerpo -> funcion .

    $end            reduce using rule 3 (cuerpo -> funcion .)
    RKEY            reduce using rule 3 (cuerpo -> funcion .)


state 5

    (4) cuerpo -> estructuras_control .

    $end            reduce using rule 4 (cuerpo -> estructuras_control .)
    RKEY            reduce using rule 4 (cuerpo -> estructuras_control .)


state 6

    (5) cuerpo -> bucles .

    $end            reduce using rule 5 (cuerpo -> bucles .)
    RKEY            reduce using rule 5 (cuerpo -> bucles .)


state 7

    (6) salida -> ECHO . valor ENDLINE
    (8) valor -> . ARGUMENTO
    (9) valor -> . INTEGER
    (10) valor -> . FLOAT
    (11) valor -> . BOOLEAN
    (12) valor -> . STRING
    (13) valor -> . VARIABLE

    ARGUMENTO       shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    VARIABLE        shift and go to state 22

    valor                          shift and go to state 16

state 8

    (7) salida -> PRINT . LPAREN valor RPAREN

    LPAREN          shift and go to state 23


state 9

    (15) asignacion -> VARIABLE . operador_asignacion valor ENDLINE
    (16) operador_asignacion -> . EQUAL
    (17) operador_asignacion -> . PLUS_EQUAL
    (18) operador_asignacion -> . CONCAT_EQUAL

    EQUAL           shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    CONCAT_EQUAL    shift and go to state 27

    operador_asignacion            shift and go to state 24

state 10

    (14) funcion -> FUNCTION . ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY

    ARGUMENTO       shift and go to state 28


state 11

    (25) estructuras_control -> if .
    (29) else -> if . ELSE LKEY cuerpo RKEY

    $end            reduce using rule 25 (estructuras_control -> if .)
    RKEY            reduce using rule 25 (estructuras_control -> if .)
    ELSE            shift and go to state 29


state 12

    (26) estructuras_control -> else .

    $end            reduce using rule 26 (estructuras_control -> else .)
    RKEY            reduce using rule 26 (estructuras_control -> else .)


state 13

    (27) bucles -> while .

    $end            reduce using rule 27 (bucles -> while .)
    RKEY            reduce using rule 27 (bucles -> while .)


state 14

    (28) if -> IF . LPAREN expresion_logica RPAREN LKEY cuerpo RKEY

    LPAREN          shift and go to state 30


state 15

    (33) while -> WHILE . LPAREN valor operador_comparacion valor RPAREN COLON

    LPAREN          shift and go to state 31


state 16

    (6) salida -> ECHO valor . ENDLINE

    ENDLINE         shift and go to state 32


state 17

    (8) valor -> ARGUMENTO .

    ENDLINE         reduce using rule 8 (valor -> ARGUMENTO .)
    RPAREN          reduce using rule 8 (valor -> ARGUMENTO .)
    AND             reduce using rule 8 (valor -> ARGUMENTO .)
    OR              reduce using rule 8 (valor -> ARGUMENTO .)
    IS_EQUAL        reduce using rule 8 (valor -> ARGUMENTO .)
    IS_GREATER_OR_EQUAL reduce using rule 8 (valor -> ARGUMENTO .)
    IS_NOT_EQUAL    reduce using rule 8 (valor -> ARGUMENTO .)
    IS_SMALLER_OR_EQUAL reduce using rule 8 (valor -> ARGUMENTO .)
    IS_GREATER      reduce using rule 8 (valor -> ARGUMENTO .)
    IS_SMALLER      reduce using rule 8 (valor -> ARGUMENTO .)


state 18

    (9) valor -> INTEGER .

    ENDLINE         reduce using rule 9 (valor -> INTEGER .)
    RPAREN          reduce using rule 9 (valor -> INTEGER .)
    AND             reduce using rule 9 (valor -> INTEGER .)
    OR              reduce using rule 9 (valor -> INTEGER .)
    IS_EQUAL        reduce using rule 9 (valor -> INTEGER .)
    IS_GREATER_OR_EQUAL reduce using rule 9 (valor -> INTEGER .)
    IS_NOT_EQUAL    reduce using rule 9 (valor -> INTEGER .)
    IS_SMALLER_OR_EQUAL reduce using rule 9 (valor -> INTEGER .)
    IS_GREATER      reduce using rule 9 (valor -> INTEGER .)
    IS_SMALLER      reduce using rule 9 (valor -> INTEGER .)


state 19

    (10) valor -> FLOAT .

    ENDLINE         reduce using rule 10 (valor -> FLOAT .)
    RPAREN          reduce using rule 10 (valor -> FLOAT .)
    AND             reduce using rule 10 (valor -> FLOAT .)
    OR              reduce using rule 10 (valor -> FLOAT .)
    IS_EQUAL        reduce using rule 10 (valor -> FLOAT .)
    IS_GREATER_OR_EQUAL reduce using rule 10 (valor -> FLOAT .)
    IS_NOT_EQUAL    reduce using rule 10 (valor -> FLOAT .)
    IS_SMALLER_OR_EQUAL reduce using rule 10 (valor -> FLOAT .)
    IS_GREATER      reduce using rule 10 (valor -> FLOAT .)
    IS_SMALLER      reduce using rule 10 (valor -> FLOAT .)


state 20

    (11) valor -> BOOLEAN .

    ENDLINE         reduce using rule 11 (valor -> BOOLEAN .)
    RPAREN          reduce using rule 11 (valor -> BOOLEAN .)
    IS_EQUAL        reduce using rule 11 (valor -> BOOLEAN .)
    IS_GREATER_OR_EQUAL reduce using rule 11 (valor -> BOOLEAN .)
    IS_NOT_EQUAL    reduce using rule 11 (valor -> BOOLEAN .)
    IS_SMALLER_OR_EQUAL reduce using rule 11 (valor -> BOOLEAN .)
    IS_GREATER      reduce using rule 11 (valor -> BOOLEAN .)
    IS_SMALLER      reduce using rule 11 (valor -> BOOLEAN .)


state 21

    (12) valor -> STRING .

    ENDLINE         reduce using rule 12 (valor -> STRING .)
    RPAREN          reduce using rule 12 (valor -> STRING .)
    AND             reduce using rule 12 (valor -> STRING .)
    OR              reduce using rule 12 (valor -> STRING .)
    IS_EQUAL        reduce using rule 12 (valor -> STRING .)
    IS_GREATER_OR_EQUAL reduce using rule 12 (valor -> STRING .)
    IS_NOT_EQUAL    reduce using rule 12 (valor -> STRING .)
    IS_SMALLER_OR_EQUAL reduce using rule 12 (valor -> STRING .)
    IS_GREATER      reduce using rule 12 (valor -> STRING .)
    IS_SMALLER      reduce using rule 12 (valor -> STRING .)


state 22

    (13) valor -> VARIABLE .

    ENDLINE         reduce using rule 13 (valor -> VARIABLE .)
    RPAREN          reduce using rule 13 (valor -> VARIABLE .)
    AND             reduce using rule 13 (valor -> VARIABLE .)
    OR              reduce using rule 13 (valor -> VARIABLE .)
    IS_EQUAL        reduce using rule 13 (valor -> VARIABLE .)
    IS_GREATER_OR_EQUAL reduce using rule 13 (valor -> VARIABLE .)
    IS_NOT_EQUAL    reduce using rule 13 (valor -> VARIABLE .)
    IS_SMALLER_OR_EQUAL reduce using rule 13 (valor -> VARIABLE .)
    IS_GREATER      reduce using rule 13 (valor -> VARIABLE .)
    IS_SMALLER      reduce using rule 13 (valor -> VARIABLE .)


state 23

    (7) salida -> PRINT LPAREN . valor RPAREN
    (8) valor -> . ARGUMENTO
    (9) valor -> . INTEGER
    (10) valor -> . FLOAT
    (11) valor -> . BOOLEAN
    (12) valor -> . STRING
    (13) valor -> . VARIABLE

    ARGUMENTO       shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    VARIABLE        shift and go to state 22

    valor                          shift and go to state 33

state 24

    (15) asignacion -> VARIABLE operador_asignacion . valor ENDLINE
    (8) valor -> . ARGUMENTO
    (9) valor -> . INTEGER
    (10) valor -> . FLOAT
    (11) valor -> . BOOLEAN
    (12) valor -> . STRING
    (13) valor -> . VARIABLE

    ARGUMENTO       shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    VARIABLE        shift and go to state 22

    valor                          shift and go to state 34

state 25

    (16) operador_asignacion -> EQUAL .

    ARGUMENTO       reduce using rule 16 (operador_asignacion -> EQUAL .)
    INTEGER         reduce using rule 16 (operador_asignacion -> EQUAL .)
    FLOAT           reduce using rule 16 (operador_asignacion -> EQUAL .)
    BOOLEAN         reduce using rule 16 (operador_asignacion -> EQUAL .)
    STRING          reduce using rule 16 (operador_asignacion -> EQUAL .)
    VARIABLE        reduce using rule 16 (operador_asignacion -> EQUAL .)


state 26

    (17) operador_asignacion -> PLUS_EQUAL .

    ARGUMENTO       reduce using rule 17 (operador_asignacion -> PLUS_EQUAL .)
    INTEGER         reduce using rule 17 (operador_asignacion -> PLUS_EQUAL .)
    FLOAT           reduce using rule 17 (operador_asignacion -> PLUS_EQUAL .)
    BOOLEAN         reduce using rule 17 (operador_asignacion -> PLUS_EQUAL .)
    STRING          reduce using rule 17 (operador_asignacion -> PLUS_EQUAL .)
    VARIABLE        reduce using rule 17 (operador_asignacion -> PLUS_EQUAL .)


state 27

    (18) operador_asignacion -> CONCAT_EQUAL .

    ARGUMENTO       reduce using rule 18 (operador_asignacion -> CONCAT_EQUAL .)
    INTEGER         reduce using rule 18 (operador_asignacion -> CONCAT_EQUAL .)
    FLOAT           reduce using rule 18 (operador_asignacion -> CONCAT_EQUAL .)
    BOOLEAN         reduce using rule 18 (operador_asignacion -> CONCAT_EQUAL .)
    STRING          reduce using rule 18 (operador_asignacion -> CONCAT_EQUAL .)
    VARIABLE        reduce using rule 18 (operador_asignacion -> CONCAT_EQUAL .)


state 28

    (14) funcion -> FUNCTION ARGUMENTO . LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY

    LPAREN          shift and go to state 35


state 29

    (29) else -> if ELSE . LKEY cuerpo RKEY

    LKEY            shift and go to state 36


state 30

    (28) if -> IF LPAREN . expresion_logica RPAREN LKEY cuerpo RKEY
    (30) expresion_logica -> . BOOLEAN
    (31) expresion_logica -> . valor AND valor
    (32) expresion_logica -> . valor OR valor
    (8) valor -> . ARGUMENTO
    (9) valor -> . INTEGER
    (10) valor -> . FLOAT
    (11) valor -> . BOOLEAN
    (12) valor -> . STRING
    (13) valor -> . VARIABLE

    BOOLEAN         shift and go to state 38
    ARGUMENTO       shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 21
    VARIABLE        shift and go to state 22

    expresion_logica               shift and go to state 37
    valor                          shift and go to state 39

state 31

    (33) while -> WHILE LPAREN . valor operador_comparacion valor RPAREN COLON
    (8) valor -> . ARGUMENTO
    (9) valor -> . INTEGER
    (10) valor -> . FLOAT
    (11) valor -> . BOOLEAN
    (12) valor -> . STRING
    (13) valor -> . VARIABLE

    ARGUMENTO       shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    VARIABLE        shift and go to state 22

    valor                          shift and go to state 40

state 32

    (6) salida -> ECHO valor ENDLINE .

    $end            reduce using rule 6 (salida -> ECHO valor ENDLINE .)
    RKEY            reduce using rule 6 (salida -> ECHO valor ENDLINE .)


state 33

    (7) salida -> PRINT LPAREN valor . RPAREN

    RPAREN          shift and go to state 41


state 34

    (15) asignacion -> VARIABLE operador_asignacion valor . ENDLINE

    ENDLINE         shift and go to state 42


state 35

    (14) funcion -> FUNCTION ARGUMENTO LPAREN . VARIABLE RPAREN LKEY ARGUMENTO RKEY

    VARIABLE        shift and go to state 43


state 36

    (29) else -> if ELSE LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . asignacion
    (3) cuerpo -> . funcion
    (4) cuerpo -> . estructuras_control
    (5) cuerpo -> . bucles
    (6) salida -> . ECHO valor ENDLINE
    (7) salida -> . PRINT LPAREN valor RPAREN
    (15) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (14) funcion -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (25) estructuras_control -> . if
    (26) estructuras_control -> . else
    (27) bucles -> . while
    (28) if -> . IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY
    (29) else -> . if ELSE LKEY cuerpo RKEY
    (33) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON

    ECHO            shift and go to state 7
    PRINT           shift and go to state 8
    VARIABLE        shift and go to state 9
    FUNCTION        shift and go to state 10
    IF              shift and go to state 14
    WHILE           shift and go to state 15

    if                             shift and go to state 11
    cuerpo                         shift and go to state 44
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    funcion                        shift and go to state 4
    estructuras_control            shift and go to state 5
    bucles                         shift and go to state 6
    else                           shift and go to state 12
    while                          shift and go to state 13

state 37

    (28) if -> IF LPAREN expresion_logica . RPAREN LKEY cuerpo RKEY

    RPAREN          shift and go to state 45


state 38

    (30) expresion_logica -> BOOLEAN .
    (11) valor -> BOOLEAN .

    RPAREN          reduce using rule 30 (expresion_logica -> BOOLEAN .)
    AND             reduce using rule 11 (valor -> BOOLEAN .)
    OR              reduce using rule 11 (valor -> BOOLEAN .)


state 39

    (31) expresion_logica -> valor . AND valor
    (32) expresion_logica -> valor . OR valor

    AND             shift and go to state 46
    OR              shift and go to state 47


state 40

    (33) while -> WHILE LPAREN valor . operador_comparacion valor RPAREN COLON
    (19) operador_comparacion -> . IS_EQUAL
    (20) operador_comparacion -> . IS_GREATER_OR_EQUAL
    (21) operador_comparacion -> . IS_NOT_EQUAL
    (22) operador_comparacion -> . IS_SMALLER_OR_EQUAL
    (23) operador_comparacion -> . IS_GREATER
    (24) operador_comparacion -> . IS_SMALLER

    IS_EQUAL        shift and go to state 49
    IS_GREATER_OR_EQUAL shift and go to state 50
    IS_NOT_EQUAL    shift and go to state 51
    IS_SMALLER_OR_EQUAL shift and go to state 52
    IS_GREATER      shift and go to state 53
    IS_SMALLER      shift and go to state 54

    operador_comparacion           shift and go to state 48

state 41

    (7) salida -> PRINT LPAREN valor RPAREN .

    $end            reduce using rule 7 (salida -> PRINT LPAREN valor RPAREN .)
    RKEY            reduce using rule 7 (salida -> PRINT LPAREN valor RPAREN .)


state 42

    (15) asignacion -> VARIABLE operador_asignacion valor ENDLINE .

    $end            reduce using rule 15 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    RKEY            reduce using rule 15 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)


state 43

    (14) funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE . RPAREN LKEY ARGUMENTO RKEY

    RPAREN          shift and go to state 55


state 44

    (29) else -> if ELSE LKEY cuerpo . RKEY

    RKEY            shift and go to state 56


state 45

    (28) if -> IF LPAREN expresion_logica RPAREN . LKEY cuerpo RKEY

    LKEY            shift and go to state 57


state 46

    (31) expresion_logica -> valor AND . valor
    (8) valor -> . ARGUMENTO
    (9) valor -> . INTEGER
    (10) valor -> . FLOAT
    (11) valor -> . BOOLEAN
    (12) valor -> . STRING
    (13) valor -> . VARIABLE

    ARGUMENTO       shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    VARIABLE        shift and go to state 22

    valor                          shift and go to state 58

state 47

    (32) expresion_logica -> valor OR . valor
    (8) valor -> . ARGUMENTO
    (9) valor -> . INTEGER
    (10) valor -> . FLOAT
    (11) valor -> . BOOLEAN
    (12) valor -> . STRING
    (13) valor -> . VARIABLE

    ARGUMENTO       shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    VARIABLE        shift and go to state 22

    valor                          shift and go to state 59

state 48

    (33) while -> WHILE LPAREN valor operador_comparacion . valor RPAREN COLON
    (8) valor -> . ARGUMENTO
    (9) valor -> . INTEGER
    (10) valor -> . FLOAT
    (11) valor -> . BOOLEAN
    (12) valor -> . STRING
    (13) valor -> . VARIABLE

    ARGUMENTO       shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    VARIABLE        shift and go to state 22

    valor                          shift and go to state 60

state 49

    (19) operador_comparacion -> IS_EQUAL .

    ARGUMENTO       reduce using rule 19 (operador_comparacion -> IS_EQUAL .)
    INTEGER         reduce using rule 19 (operador_comparacion -> IS_EQUAL .)
    FLOAT           reduce using rule 19 (operador_comparacion -> IS_EQUAL .)
    BOOLEAN         reduce using rule 19 (operador_comparacion -> IS_EQUAL .)
    STRING          reduce using rule 19 (operador_comparacion -> IS_EQUAL .)
    VARIABLE        reduce using rule 19 (operador_comparacion -> IS_EQUAL .)


state 50

    (20) operador_comparacion -> IS_GREATER_OR_EQUAL .

    ARGUMENTO       reduce using rule 20 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 20 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    FLOAT           reduce using rule 20 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    BOOLEAN         reduce using rule 20 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    STRING          reduce using rule 20 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    VARIABLE        reduce using rule 20 (operador_comparacion -> IS_GREATER_OR_EQUAL .)


state 51

    (21) operador_comparacion -> IS_NOT_EQUAL .

    ARGUMENTO       reduce using rule 21 (operador_comparacion -> IS_NOT_EQUAL .)
    INTEGER         reduce using rule 21 (operador_comparacion -> IS_NOT_EQUAL .)
    FLOAT           reduce using rule 21 (operador_comparacion -> IS_NOT_EQUAL .)
    BOOLEAN         reduce using rule 21 (operador_comparacion -> IS_NOT_EQUAL .)
    STRING          reduce using rule 21 (operador_comparacion -> IS_NOT_EQUAL .)
    VARIABLE        reduce using rule 21 (operador_comparacion -> IS_NOT_EQUAL .)


state 52

    (22) operador_comparacion -> IS_SMALLER_OR_EQUAL .

    ARGUMENTO       reduce using rule 22 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 22 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    FLOAT           reduce using rule 22 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    BOOLEAN         reduce using rule 22 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    STRING          reduce using rule 22 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    VARIABLE        reduce using rule 22 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)


state 53

    (23) operador_comparacion -> IS_GREATER .

    ARGUMENTO       reduce using rule 23 (operador_comparacion -> IS_GREATER .)
    INTEGER         reduce using rule 23 (operador_comparacion -> IS_GREATER .)
    FLOAT           reduce using rule 23 (operador_comparacion -> IS_GREATER .)
    BOOLEAN         reduce using rule 23 (operador_comparacion -> IS_GREATER .)
    STRING          reduce using rule 23 (operador_comparacion -> IS_GREATER .)
    VARIABLE        reduce using rule 23 (operador_comparacion -> IS_GREATER .)


state 54

    (24) operador_comparacion -> IS_SMALLER .

    ARGUMENTO       reduce using rule 24 (operador_comparacion -> IS_SMALLER .)
    INTEGER         reduce using rule 24 (operador_comparacion -> IS_SMALLER .)
    FLOAT           reduce using rule 24 (operador_comparacion -> IS_SMALLER .)
    BOOLEAN         reduce using rule 24 (operador_comparacion -> IS_SMALLER .)
    STRING          reduce using rule 24 (operador_comparacion -> IS_SMALLER .)
    VARIABLE        reduce using rule 24 (operador_comparacion -> IS_SMALLER .)


state 55

    (14) funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN . LKEY ARGUMENTO RKEY

    LKEY            shift and go to state 61


state 56

    (29) else -> if ELSE LKEY cuerpo RKEY .

    $end            reduce using rule 29 (else -> if ELSE LKEY cuerpo RKEY .)
    RKEY            reduce using rule 29 (else -> if ELSE LKEY cuerpo RKEY .)


state 57

    (28) if -> IF LPAREN expresion_logica RPAREN LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . asignacion
    (3) cuerpo -> . funcion
    (4) cuerpo -> . estructuras_control
    (5) cuerpo -> . bucles
    (6) salida -> . ECHO valor ENDLINE
    (7) salida -> . PRINT LPAREN valor RPAREN
    (15) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (14) funcion -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (25) estructuras_control -> . if
    (26) estructuras_control -> . else
    (27) bucles -> . while
    (28) if -> . IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY
    (29) else -> . if ELSE LKEY cuerpo RKEY
    (33) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON

    ECHO            shift and go to state 7
    PRINT           shift and go to state 8
    VARIABLE        shift and go to state 9
    FUNCTION        shift and go to state 10
    IF              shift and go to state 14
    WHILE           shift and go to state 15

    cuerpo                         shift and go to state 62
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    funcion                        shift and go to state 4
    estructuras_control            shift and go to state 5
    bucles                         shift and go to state 6
    if                             shift and go to state 11
    else                           shift and go to state 12
    while                          shift and go to state 13

state 58

    (31) expresion_logica -> valor AND valor .

    RPAREN          reduce using rule 31 (expresion_logica -> valor AND valor .)


state 59

    (32) expresion_logica -> valor OR valor .

    RPAREN          reduce using rule 32 (expresion_logica -> valor OR valor .)


state 60

    (33) while -> WHILE LPAREN valor operador_comparacion valor . RPAREN COLON

    RPAREN          shift and go to state 63


state 61

    (14) funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY . ARGUMENTO RKEY

    ARGUMENTO       shift and go to state 64


state 62

    (28) if -> IF LPAREN expresion_logica RPAREN LKEY cuerpo . RKEY

    RKEY            shift and go to state 65


state 63

    (33) while -> WHILE LPAREN valor operador_comparacion valor RPAREN . COLON

    COLON           shift and go to state 66


state 64

    (14) funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO . RKEY

    RKEY            shift and go to state 67


state 65

    (28) if -> IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY .

    ELSE            reduce using rule 28 (if -> IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY .)
    $end            reduce using rule 28 (if -> IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY .)
    RKEY            reduce using rule 28 (if -> IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY .)


state 66

    (33) while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON .

    $end            reduce using rule 33 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON .)
    RKEY            reduce using rule 33 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON .)


state 67

    (14) funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .

    $end            reduce using rule 14 (funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    RKEY            reduce using rule 14 (funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)

