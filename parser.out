Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADVANCE_PAGE
    ARRAY
    CLOSE_TAG
    ESCAPE
    FSCANF
    IDENTITY
    NEGATION
    NOT
    NULL
    OPEN_TAG
    OPERADOR_CONCATENACION
    READLINE
    SETSIZE
    SINTAXIS_ARRAY
    SPLFIXEDARRAY
    WHITESPACE

Grammar

Rule 0     S' -> cuerpo
Rule 1     cuerpo -> salida
Rule 2     cuerpo -> salida cuerpo
Rule 3     cuerpo -> asignacion
Rule 4     cuerpo -> asignacion cuerpo
Rule 5     cuerpo -> function
Rule 6     cuerpo -> function cuerpo
Rule 7     cuerpo -> estructuras_control
Rule 8     cuerpo -> estructuras_control cuerpo
Rule 9     cuerpo -> metodos
Rule 10    cuerpo -> metodos cuerpo
Rule 11    cuerpo -> abrir_archivo
Rule 12    cuerpo -> lectura_archivo
Rule 13    salida -> ECHO valor ENDLINE
Rule 14    salida -> PRINT LPAREN valor RPAREN ENDLINE
Rule 15    valor -> ARGUMENTO
Rule 16    valor -> number
Rule 17    valor -> BOOLEAN
Rule 18    valor -> string
Rule 19    valor -> VARIABLE
Rule 20    valor -> estructuras_datos
Rule 21    valor -> funciones
Rule 22    valor -> valor
Rule 23    string -> STRING
Rule 24    string -> COMILLA_DOBLE STRING COMILLA_DOBLE
Rule 25    string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE
Rule 26    function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
Rule 27    asignacion -> VARIABLE operador_asignacion valor ENDLINE
Rule 28    asignacion -> VARIABLE operador_asignacion expresion ENDLINE
Rule 29    asignacion -> queue_variable operador_asignacion queue ENDLINE
Rule 30    queue -> NEW SPLQUEUE LPAREN RPAREN
Rule 31    queue_variable -> VARIABLE
Rule 32    push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
Rule 33    pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE
Rule 34    metodos -> push
Rule 35    metodos -> pop
Rule 36    operador_asignacion -> EQUAL
Rule 37    operador_asignacion -> PLUS_EQUAL
Rule 38    operador_asignacion -> CONCAT_EQUAL
Rule 39    estructuras_datos -> array
Rule 40    estructuras_datos -> queue
Rule 41    operador_comparacion -> IS_EQUAL
Rule 42    operador_comparacion -> IS_GREATER_OR_EQUAL
Rule 43    operador_comparacion -> IS_NOT_EQUAL
Rule 44    operador_comparacion -> IS_SMALLER_OR_EQUAL
Rule 45    operador_comparacion -> IS_GREATER
Rule 46    operador_comparacion -> IS_SMALLER
Rule 47    operacion_comparacion -> VARIABLE operador_comparacion VARIABLE
Rule 48    estructuras_control -> if
Rule 49    estructuras_control -> else
Rule 50    estructuras_control -> while
Rule 51    estructuras_control -> for
Rule 52    estructuras_control -> estructuras_control
Rule 53    if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY
Rule 54    else -> if ELSE LKEY cuerpo RKEY
Rule 55    expresion -> expresiones_logicas
Rule 56    expresion -> expresion_aritmetica
Rule 57    expresiones_logicas -> valor
Rule 58    expresiones_logicas -> valor operador expresiones_logicas
Rule 59    operador_logico -> BOOLEAN_AND
Rule 60    operador_logico -> BOOLEAN_OR
Rule 61    operador_logico -> AND
Rule 62    operador_logico -> OR
Rule 63    operador_logico -> XOR
Rule 64    operador -> operador_logico
Rule 65    operador -> operador_comparacion
Rule 66    number -> INTEGER
Rule 67    number -> FLOAT
Rule 68    operador_aritmetico -> ADDITION
Rule 69    operador_aritmetico -> SUBTRACTION
Rule 70    operador_aritmetico -> MULTIPLICATION
Rule 71    operador_aritmetico -> DIVISION
Rule 72    operador_aritmetico -> MODULO
Rule 73    operador_aritmetico -> EXPONENTIATION
Rule 74    expresion_aritmetica -> number
Rule 75    expresion_aritmetica -> number operador_aritmetico expresion_aritmetica
Rule 76    abrir_archivo -> FOPEN LPAREN string RPAREN
Rule 77    abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE
Rule 78    lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE
Rule 79    lectura -> FGETS LPAREN VARIABLE COMA INTEGER RPAREN ENDLINE
Rule 80    while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
Rule 81    while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
Rule 82    array -> LBRACKET valorArreglo RBRACKET ENDLINE
Rule 83    valorArreglo -> valor COMA valorArreglo
Rule 84    valorArreglo -> valor
Rule 85    funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY
Rule 86    tipo_operador -> ADDITION
Rule 87    tipo_operador -> SUBTRACTION
Rule 88    tipo_operador -> MULTIPLICATION
Rule 89    tipo_operador -> DIVISION
Rule 90    tipo_operador -> MODULO
Rule 91    tipo_operador -> EXPONENTIATION
Rule 92    forma_operacion -> VARIABLE OPERADOR_INCREMENTO
Rule 93    forma_operacion -> OPERADOR_INCREMENTO VARIABLE
Rule 94    forma_operacion -> VARIABLE OPERADOR_DECREMENTO
Rule 95    forma_operacion -> OPERADOR_DECREMENTO VARIABLE
Rule 96    forma_operacion -> VARIABLE EQUAL VARIABLE tipo_operador INTEGER
Rule 97    for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

Terminals, with rules where they appear

ADDITION             : 68 86
ADVANCE_PAGE         : 
AND                  : 61
ARGUMENTO            : 15 26 26
ARRAY                : 
ARROW                : 32 33
BOOLEAN              : 17
BOOLEAN_AND          : 59
BOOLEAN_OR           : 60
CLOSE_TAG            : 
COLON                : 80
COMA                 : 79 83
COMILLA_DOBLE        : 24 24
COMILLA_SIMPLE       : 25 25
CONCAT_EQUAL         : 38
DIVISION             : 71 89
ECHO                 : 13
ELSE                 : 54
ENDLINE              : 13 14 27 28 29 32 33 77 78 79 82 97 97
EQUAL                : 36 96 97
ESCAPE               : 
EXPONENTIATION       : 73 91
FGETS                : 78 79
FLOAT                : 67
FOPEN                : 76 77
FOR                  : 97
FSCANF               : 
FUNCTION             : 26
IDENTITY             : 
IF                   : 53
INTEGER              : 66 79 96 97 97
IS_EQUAL             : 41
IS_GREATER           : 45
IS_GREATER_OR_EQUAL  : 42
IS_NOT_EQUAL         : 43
IS_SMALLER           : 46
IS_SMALLER_OR_EQUAL  : 44
LBRACKET             : 82
LKEY                 : 26 53 54 81 85 97
LPAREN               : 14 26 30 32 33 53 76 77 78 79 80 81 85 97
MODULO               : 72 90
MULTIPLICATION       : 70 88
NEGATION             : 
NEW                  : 30
NOT                  : 
NULL                 : 
OPEN_TAG             : 
OPERADOR_CONCATENACION : 
OPERADOR_DECREMENTO  : 94 95
OPERADOR_INCREMENTO  : 92 93
OR                   : 62
PLUS_EQUAL           : 37
POP                  : 33
PRINT                : 14
PUSH                 : 32
RBRACKET             : 82
READLINE             : 
RKEY                 : 26 53 54 81 85 97
RPAREN               : 14 26 30 32 33 53 76 77 78 79 80 81 85 97
SETSIZE              : 
SINTAXIS_ARRAY       : 
SPLFIXEDARRAY        : 
SPLQUEUE             : 30
STRING               : 23 24 25
SUBTRACTION          : 69 87
TAB_VERTICAL         : 81
VARIABLE             : 19 26 27 28 31 47 47 79 92 93 94 95 96 96 97 97
WHILE                : 80 81
WHITESPACE           : 
XOR                  : 63
error                : 

Nonterminals, with rules where they appear

abrir_archivo        : 11 78
array                : 39
asignacion           : 3 4
cuerpo               : 2 4 6 8 10 53 54 80 81 85 97 0
else                 : 49
estructuras_control  : 7 8 52
estructuras_datos    : 20
expresion            : 28 53
expresion_aritmetica : 56 75
expresiones_logicas  : 55 58
for                  : 51
forma_operacion      : 97
funciones            : 21
function             : 5 6
if                   : 48 54
lectura              : 
lectura_archivo      : 12
metodos              : 9 10
number               : 16 74 75
operacion_comparacion : 
operador             : 58
operador_aritmetico  : 75
operador_asignacion  : 27 28 29
operador_comparacion : 47 65 80 81 97
operador_logico      : 64
pop                  : 35
push                 : 34
queue                : 29 40
queue_variable       : 29 32 33
salida               : 1 2
string               : 18 76 77
tipo_operador        : 96
valor                : 13 14 22 27 32 57 58 80 80 81 81 83 84 85 85
valorArreglo         : 82 83
while                : 50

Parsing method: LALR

state 0

    (0) S' -> . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . metodos
    (10) cuerpo -> . metodos cuerpo
    (11) cuerpo -> . abrir_archivo
    (12) cuerpo -> . lectura_archivo
    (13) salida -> . ECHO valor ENDLINE
    (14) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (27) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (29) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (26) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (48) estructuras_control -> . if
    (49) estructuras_control -> . else
    (50) estructuras_control -> . while
    (51) estructuras_control -> . for
    (52) estructuras_control -> . estructuras_control
    (34) metodos -> . push
    (35) metodos -> . pop
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (78) lectura_archivo -> . FGETS LPAREN abrir_archivo RPAREN ENDLINE
    (31) queue_variable -> . VARIABLE
    (53) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (54) else -> . if ELSE LKEY cuerpo RKEY
    (80) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (97) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (32) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    VARIABLE        shift and go to state 11
    FUNCTION        shift and go to state 13
    FOPEN           shift and go to state 20
    FGETS           shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24

    cuerpo                         shift and go to state 1
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    metodos                        shift and go to state 6
    abrir_archivo                  shift and go to state 7
    lectura_archivo                shift and go to state 8
    queue_variable                 shift and go to state 12
    if                             shift and go to state 14
    else                           shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    push                           shift and go to state 18
    pop                            shift and go to state 19

state 1

    (0) S' -> cuerpo .



state 2

    (1) cuerpo -> salida .
    (2) cuerpo -> salida . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . metodos
    (10) cuerpo -> . metodos cuerpo
    (11) cuerpo -> . abrir_archivo
    (12) cuerpo -> . lectura_archivo
    (13) salida -> . ECHO valor ENDLINE
    (14) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (27) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (29) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (26) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (48) estructuras_control -> . if
    (49) estructuras_control -> . else
    (50) estructuras_control -> . while
    (51) estructuras_control -> . for
    (52) estructuras_control -> . estructuras_control
    (34) metodos -> . push
    (35) metodos -> . pop
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (78) lectura_archivo -> . FGETS LPAREN abrir_archivo RPAREN ENDLINE
    (31) queue_variable -> . VARIABLE
    (53) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (54) else -> . if ELSE LKEY cuerpo RKEY
    (80) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (97) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (32) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FOPEN resolved as shift
  ! shift/reduce conflict for FGETS resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    $end            reduce using rule 1 (cuerpo -> salida .)
    RKEY            reduce using rule 1 (cuerpo -> salida .)
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    VARIABLE        shift and go to state 11
    FUNCTION        shift and go to state 13
    FOPEN           shift and go to state 20
    FGETS           shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24

  ! ECHO            [ reduce using rule 1 (cuerpo -> salida .) ]
  ! PRINT           [ reduce using rule 1 (cuerpo -> salida .) ]
  ! VARIABLE        [ reduce using rule 1 (cuerpo -> salida .) ]
  ! FUNCTION        [ reduce using rule 1 (cuerpo -> salida .) ]
  ! FOPEN           [ reduce using rule 1 (cuerpo -> salida .) ]
  ! FGETS           [ reduce using rule 1 (cuerpo -> salida .) ]
  ! IF              [ reduce using rule 1 (cuerpo -> salida .) ]
  ! WHILE           [ reduce using rule 1 (cuerpo -> salida .) ]
  ! FOR             [ reduce using rule 1 (cuerpo -> salida .) ]

    salida                         shift and go to state 2
    cuerpo                         shift and go to state 25
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    metodos                        shift and go to state 6
    abrir_archivo                  shift and go to state 7
    lectura_archivo                shift and go to state 8
    queue_variable                 shift and go to state 12
    if                             shift and go to state 14
    else                           shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    push                           shift and go to state 18
    pop                            shift and go to state 19

state 3

    (3) cuerpo -> asignacion .
    (4) cuerpo -> asignacion . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . metodos
    (10) cuerpo -> . metodos cuerpo
    (11) cuerpo -> . abrir_archivo
    (12) cuerpo -> . lectura_archivo
    (13) salida -> . ECHO valor ENDLINE
    (14) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (27) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (29) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (26) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (48) estructuras_control -> . if
    (49) estructuras_control -> . else
    (50) estructuras_control -> . while
    (51) estructuras_control -> . for
    (52) estructuras_control -> . estructuras_control
    (34) metodos -> . push
    (35) metodos -> . pop
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (78) lectura_archivo -> . FGETS LPAREN abrir_archivo RPAREN ENDLINE
    (31) queue_variable -> . VARIABLE
    (53) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (54) else -> . if ELSE LKEY cuerpo RKEY
    (80) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (97) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (32) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FOPEN resolved as shift
  ! shift/reduce conflict for FGETS resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    $end            reduce using rule 3 (cuerpo -> asignacion .)
    RKEY            reduce using rule 3 (cuerpo -> asignacion .)
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    VARIABLE        shift and go to state 11
    FUNCTION        shift and go to state 13
    FOPEN           shift and go to state 20
    FGETS           shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24

  ! ECHO            [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! PRINT           [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! VARIABLE        [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! FUNCTION        [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! FOPEN           [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! FGETS           [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! IF              [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! WHILE           [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! FOR             [ reduce using rule 3 (cuerpo -> asignacion .) ]

    asignacion                     shift and go to state 3
    cuerpo                         shift and go to state 26
    salida                         shift and go to state 2
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    metodos                        shift and go to state 6
    abrir_archivo                  shift and go to state 7
    lectura_archivo                shift and go to state 8
    queue_variable                 shift and go to state 12
    if                             shift and go to state 14
    else                           shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    push                           shift and go to state 18
    pop                            shift and go to state 19

state 4

    (5) cuerpo -> function .
    (6) cuerpo -> function . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . metodos
    (10) cuerpo -> . metodos cuerpo
    (11) cuerpo -> . abrir_archivo
    (12) cuerpo -> . lectura_archivo
    (13) salida -> . ECHO valor ENDLINE
    (14) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (27) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (29) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (26) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (48) estructuras_control -> . if
    (49) estructuras_control -> . else
    (50) estructuras_control -> . while
    (51) estructuras_control -> . for
    (52) estructuras_control -> . estructuras_control
    (34) metodos -> . push
    (35) metodos -> . pop
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (78) lectura_archivo -> . FGETS LPAREN abrir_archivo RPAREN ENDLINE
    (31) queue_variable -> . VARIABLE
    (53) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (54) else -> . if ELSE LKEY cuerpo RKEY
    (80) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (97) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (32) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FOPEN resolved as shift
  ! shift/reduce conflict for FGETS resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    $end            reduce using rule 5 (cuerpo -> function .)
    RKEY            reduce using rule 5 (cuerpo -> function .)
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    VARIABLE        shift and go to state 11
    FUNCTION        shift and go to state 13
    FOPEN           shift and go to state 20
    FGETS           shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24

  ! ECHO            [ reduce using rule 5 (cuerpo -> function .) ]
  ! PRINT           [ reduce using rule 5 (cuerpo -> function .) ]
  ! VARIABLE        [ reduce using rule 5 (cuerpo -> function .) ]
  ! FUNCTION        [ reduce using rule 5 (cuerpo -> function .) ]
  ! FOPEN           [ reduce using rule 5 (cuerpo -> function .) ]
  ! FGETS           [ reduce using rule 5 (cuerpo -> function .) ]
  ! IF              [ reduce using rule 5 (cuerpo -> function .) ]
  ! WHILE           [ reduce using rule 5 (cuerpo -> function .) ]
  ! FOR             [ reduce using rule 5 (cuerpo -> function .) ]

    function                       shift and go to state 4
    cuerpo                         shift and go to state 27
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    estructuras_control            shift and go to state 5
    metodos                        shift and go to state 6
    abrir_archivo                  shift and go to state 7
    lectura_archivo                shift and go to state 8
    queue_variable                 shift and go to state 12
    if                             shift and go to state 14
    else                           shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    push                           shift and go to state 18
    pop                            shift and go to state 19

state 5

    (7) cuerpo -> estructuras_control .
    (8) cuerpo -> estructuras_control . cuerpo
    (52) estructuras_control -> estructuras_control .
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . metodos
    (10) cuerpo -> . metodos cuerpo
    (11) cuerpo -> . abrir_archivo
    (12) cuerpo -> . lectura_archivo
    (13) salida -> . ECHO valor ENDLINE
    (14) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (27) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (29) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (26) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (48) estructuras_control -> . if
    (49) estructuras_control -> . else
    (50) estructuras_control -> . while
    (51) estructuras_control -> . for
    (52) estructuras_control -> . estructuras_control
    (34) metodos -> . push
    (35) metodos -> . pop
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (78) lectura_archivo -> . FGETS LPAREN abrir_archivo RPAREN ENDLINE
    (31) queue_variable -> . VARIABLE
    (53) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (54) else -> . if ELSE LKEY cuerpo RKEY
    (80) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (97) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (32) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

  ! reduce/reduce conflict for ECHO resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for PRINT resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for FOPEN resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for FGETS resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for IF resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for WHILE resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for FOR resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for $end resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for RKEY resolved using rule 7 (cuerpo -> estructuras_control .)
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FOPEN resolved as shift
  ! shift/reduce conflict for FGETS resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    $end            reduce using rule 7 (cuerpo -> estructuras_control .)
    RKEY            reduce using rule 7 (cuerpo -> estructuras_control .)
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    VARIABLE        shift and go to state 11
    FUNCTION        shift and go to state 13
    FOPEN           shift and go to state 20
    FGETS           shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24

  ! ECHO            [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! PRINT           [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! VARIABLE        [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! FUNCTION        [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! FOPEN           [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! FGETS           [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! IF              [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! WHILE           [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! FOR             [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! ECHO            [ reduce using rule 52 (estructuras_control -> estructuras_control .) ]
  ! PRINT           [ reduce using rule 52 (estructuras_control -> estructuras_control .) ]
  ! VARIABLE        [ reduce using rule 52 (estructuras_control -> estructuras_control .) ]
  ! FUNCTION        [ reduce using rule 52 (estructuras_control -> estructuras_control .) ]
  ! FOPEN           [ reduce using rule 52 (estructuras_control -> estructuras_control .) ]
  ! FGETS           [ reduce using rule 52 (estructuras_control -> estructuras_control .) ]
  ! IF              [ reduce using rule 52 (estructuras_control -> estructuras_control .) ]
  ! WHILE           [ reduce using rule 52 (estructuras_control -> estructuras_control .) ]
  ! FOR             [ reduce using rule 52 (estructuras_control -> estructuras_control .) ]
  ! $end            [ reduce using rule 52 (estructuras_control -> estructuras_control .) ]
  ! RKEY            [ reduce using rule 52 (estructuras_control -> estructuras_control .) ]

    estructuras_control            shift and go to state 5
    cuerpo                         shift and go to state 28
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    metodos                        shift and go to state 6
    abrir_archivo                  shift and go to state 7
    lectura_archivo                shift and go to state 8
    queue_variable                 shift and go to state 12
    if                             shift and go to state 14
    else                           shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    push                           shift and go to state 18
    pop                            shift and go to state 19

state 6

    (9) cuerpo -> metodos .
    (10) cuerpo -> metodos . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . metodos
    (10) cuerpo -> . metodos cuerpo
    (11) cuerpo -> . abrir_archivo
    (12) cuerpo -> . lectura_archivo
    (13) salida -> . ECHO valor ENDLINE
    (14) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (27) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (29) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (26) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (48) estructuras_control -> . if
    (49) estructuras_control -> . else
    (50) estructuras_control -> . while
    (51) estructuras_control -> . for
    (52) estructuras_control -> . estructuras_control
    (34) metodos -> . push
    (35) metodos -> . pop
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (78) lectura_archivo -> . FGETS LPAREN abrir_archivo RPAREN ENDLINE
    (31) queue_variable -> . VARIABLE
    (53) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (54) else -> . if ELSE LKEY cuerpo RKEY
    (80) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (97) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (32) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FOPEN resolved as shift
  ! shift/reduce conflict for FGETS resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    $end            reduce using rule 9 (cuerpo -> metodos .)
    RKEY            reduce using rule 9 (cuerpo -> metodos .)
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    VARIABLE        shift and go to state 11
    FUNCTION        shift and go to state 13
    FOPEN           shift and go to state 20
    FGETS           shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24

  ! ECHO            [ reduce using rule 9 (cuerpo -> metodos .) ]
  ! PRINT           [ reduce using rule 9 (cuerpo -> metodos .) ]
  ! VARIABLE        [ reduce using rule 9 (cuerpo -> metodos .) ]
  ! FUNCTION        [ reduce using rule 9 (cuerpo -> metodos .) ]
  ! FOPEN           [ reduce using rule 9 (cuerpo -> metodos .) ]
  ! FGETS           [ reduce using rule 9 (cuerpo -> metodos .) ]
  ! IF              [ reduce using rule 9 (cuerpo -> metodos .) ]
  ! WHILE           [ reduce using rule 9 (cuerpo -> metodos .) ]
  ! FOR             [ reduce using rule 9 (cuerpo -> metodos .) ]

    metodos                        shift and go to state 6
    cuerpo                         shift and go to state 29
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    abrir_archivo                  shift and go to state 7
    lectura_archivo                shift and go to state 8
    queue_variable                 shift and go to state 12
    if                             shift and go to state 14
    else                           shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    push                           shift and go to state 18
    pop                            shift and go to state 19

state 7

    (11) cuerpo -> abrir_archivo .

    $end            reduce using rule 11 (cuerpo -> abrir_archivo .)
    RKEY            reduce using rule 11 (cuerpo -> abrir_archivo .)
    ECHO            reduce using rule 11 (cuerpo -> abrir_archivo .)
    PRINT           reduce using rule 11 (cuerpo -> abrir_archivo .)
    VARIABLE        reduce using rule 11 (cuerpo -> abrir_archivo .)
    FUNCTION        reduce using rule 11 (cuerpo -> abrir_archivo .)
    FOPEN           reduce using rule 11 (cuerpo -> abrir_archivo .)
    FGETS           reduce using rule 11 (cuerpo -> abrir_archivo .)
    IF              reduce using rule 11 (cuerpo -> abrir_archivo .)
    WHILE           reduce using rule 11 (cuerpo -> abrir_archivo .)
    FOR             reduce using rule 11 (cuerpo -> abrir_archivo .)


state 8

    (12) cuerpo -> lectura_archivo .

    $end            reduce using rule 12 (cuerpo -> lectura_archivo .)
    RKEY            reduce using rule 12 (cuerpo -> lectura_archivo .)
    ECHO            reduce using rule 12 (cuerpo -> lectura_archivo .)
    PRINT           reduce using rule 12 (cuerpo -> lectura_archivo .)
    VARIABLE        reduce using rule 12 (cuerpo -> lectura_archivo .)
    FUNCTION        reduce using rule 12 (cuerpo -> lectura_archivo .)
    FOPEN           reduce using rule 12 (cuerpo -> lectura_archivo .)
    FGETS           reduce using rule 12 (cuerpo -> lectura_archivo .)
    IF              reduce using rule 12 (cuerpo -> lectura_archivo .)
    WHILE           reduce using rule 12 (cuerpo -> lectura_archivo .)
    FOR             reduce using rule 12 (cuerpo -> lectura_archivo .)


state 9

    (13) salida -> ECHO . valor ENDLINE
    (15) valor -> . ARGUMENTO
    (16) valor -> . number
    (17) valor -> . BOOLEAN
    (18) valor -> . string
    (19) valor -> . VARIABLE
    (20) valor -> . estructuras_datos
    (21) valor -> . funciones
    (22) valor -> . valor
    (66) number -> . INTEGER
    (67) number -> . FLOAT
    (23) string -> . STRING
    (24) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (25) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (39) estructuras_datos -> . array
    (40) estructuras_datos -> . queue
    (85) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (82) array -> . LBRACKET valorArreglo RBRACKET ENDLINE
    (30) queue -> . NEW SPLQUEUE LPAREN RPAREN

    ARGUMENTO       shift and go to state 31
    BOOLEAN         shift and go to state 33
    VARIABLE        shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    COMILLA_DOBLE   shift and go to state 41
    COMILLA_SIMPLE  shift and go to state 42
    LBRACKET        shift and go to state 45
    NEW             shift and go to state 46

    valor                          shift and go to state 30
    number                         shift and go to state 32
    string                         shift and go to state 34
    estructuras_datos              shift and go to state 36
    funciones                      shift and go to state 37
    array                          shift and go to state 43
    queue                          shift and go to state 44

state 10

    (14) salida -> PRINT . LPAREN valor RPAREN ENDLINE

    LPAREN          shift and go to state 47


state 11

    (27) asignacion -> VARIABLE . operador_asignacion valor ENDLINE
    (28) asignacion -> VARIABLE . operador_asignacion expresion ENDLINE
    (31) queue_variable -> VARIABLE .
    (36) operador_asignacion -> . EQUAL
    (37) operador_asignacion -> . PLUS_EQUAL
    (38) operador_asignacion -> . CONCAT_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for PLUS_EQUAL resolved as shift
  ! shift/reduce conflict for CONCAT_EQUAL resolved as shift
    ARROW           reduce using rule 31 (queue_variable -> VARIABLE .)
    EQUAL           shift and go to state 49
    PLUS_EQUAL      shift and go to state 50
    CONCAT_EQUAL    shift and go to state 51

  ! EQUAL           [ reduce using rule 31 (queue_variable -> VARIABLE .) ]
  ! PLUS_EQUAL      [ reduce using rule 31 (queue_variable -> VARIABLE .) ]
  ! CONCAT_EQUAL    [ reduce using rule 31 (queue_variable -> VARIABLE .) ]

    operador_asignacion            shift and go to state 48

state 12

    (29) asignacion -> queue_variable . operador_asignacion queue ENDLINE
    (32) push -> queue_variable . ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> queue_variable . ARROW POP LPAREN RPAREN ENDLINE
    (36) operador_asignacion -> . EQUAL
    (37) operador_asignacion -> . PLUS_EQUAL
    (38) operador_asignacion -> . CONCAT_EQUAL

    ARROW           shift and go to state 53
    EQUAL           shift and go to state 49
    PLUS_EQUAL      shift and go to state 50
    CONCAT_EQUAL    shift and go to state 51

    operador_asignacion            shift and go to state 52

state 13

    (26) function -> FUNCTION . ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY

    ARGUMENTO       shift and go to state 54


state 14

    (48) estructuras_control -> if .
    (54) else -> if . ELSE LKEY cuerpo RKEY

    ECHO            reduce using rule 48 (estructuras_control -> if .)
    PRINT           reduce using rule 48 (estructuras_control -> if .)
    VARIABLE        reduce using rule 48 (estructuras_control -> if .)
    FUNCTION        reduce using rule 48 (estructuras_control -> if .)
    FOPEN           reduce using rule 48 (estructuras_control -> if .)
    FGETS           reduce using rule 48 (estructuras_control -> if .)
    IF              reduce using rule 48 (estructuras_control -> if .)
    WHILE           reduce using rule 48 (estructuras_control -> if .)
    FOR             reduce using rule 48 (estructuras_control -> if .)
    $end            reduce using rule 48 (estructuras_control -> if .)
    RKEY            reduce using rule 48 (estructuras_control -> if .)
    ELSE            shift and go to state 55


state 15

    (49) estructuras_control -> else .

    ECHO            reduce using rule 49 (estructuras_control -> else .)
    PRINT           reduce using rule 49 (estructuras_control -> else .)
    VARIABLE        reduce using rule 49 (estructuras_control -> else .)
    FUNCTION        reduce using rule 49 (estructuras_control -> else .)
    FOPEN           reduce using rule 49 (estructuras_control -> else .)
    FGETS           reduce using rule 49 (estructuras_control -> else .)
    IF              reduce using rule 49 (estructuras_control -> else .)
    WHILE           reduce using rule 49 (estructuras_control -> else .)
    FOR             reduce using rule 49 (estructuras_control -> else .)
    $end            reduce using rule 49 (estructuras_control -> else .)
    RKEY            reduce using rule 49 (estructuras_control -> else .)


state 16

    (50) estructuras_control -> while .

    ECHO            reduce using rule 50 (estructuras_control -> while .)
    PRINT           reduce using rule 50 (estructuras_control -> while .)
    VARIABLE        reduce using rule 50 (estructuras_control -> while .)
    FUNCTION        reduce using rule 50 (estructuras_control -> while .)
    FOPEN           reduce using rule 50 (estructuras_control -> while .)
    FGETS           reduce using rule 50 (estructuras_control -> while .)
    IF              reduce using rule 50 (estructuras_control -> while .)
    WHILE           reduce using rule 50 (estructuras_control -> while .)
    FOR             reduce using rule 50 (estructuras_control -> while .)
    $end            reduce using rule 50 (estructuras_control -> while .)
    RKEY            reduce using rule 50 (estructuras_control -> while .)


state 17

    (51) estructuras_control -> for .

    ECHO            reduce using rule 51 (estructuras_control -> for .)
    PRINT           reduce using rule 51 (estructuras_control -> for .)
    VARIABLE        reduce using rule 51 (estructuras_control -> for .)
    FUNCTION        reduce using rule 51 (estructuras_control -> for .)
    FOPEN           reduce using rule 51 (estructuras_control -> for .)
    FGETS           reduce using rule 51 (estructuras_control -> for .)
    IF              reduce using rule 51 (estructuras_control -> for .)
    WHILE           reduce using rule 51 (estructuras_control -> for .)
    FOR             reduce using rule 51 (estructuras_control -> for .)
    $end            reduce using rule 51 (estructuras_control -> for .)
    RKEY            reduce using rule 51 (estructuras_control -> for .)


state 18

    (34) metodos -> push .

    ECHO            reduce using rule 34 (metodos -> push .)
    PRINT           reduce using rule 34 (metodos -> push .)
    VARIABLE        reduce using rule 34 (metodos -> push .)
    FUNCTION        reduce using rule 34 (metodos -> push .)
    FOPEN           reduce using rule 34 (metodos -> push .)
    FGETS           reduce using rule 34 (metodos -> push .)
    IF              reduce using rule 34 (metodos -> push .)
    WHILE           reduce using rule 34 (metodos -> push .)
    FOR             reduce using rule 34 (metodos -> push .)
    $end            reduce using rule 34 (metodos -> push .)
    RKEY            reduce using rule 34 (metodos -> push .)


state 19

    (35) metodos -> pop .

    ECHO            reduce using rule 35 (metodos -> pop .)
    PRINT           reduce using rule 35 (metodos -> pop .)
    VARIABLE        reduce using rule 35 (metodos -> pop .)
    FUNCTION        reduce using rule 35 (metodos -> pop .)
    FOPEN           reduce using rule 35 (metodos -> pop .)
    FGETS           reduce using rule 35 (metodos -> pop .)
    IF              reduce using rule 35 (metodos -> pop .)
    WHILE           reduce using rule 35 (metodos -> pop .)
    FOR             reduce using rule 35 (metodos -> pop .)
    $end            reduce using rule 35 (metodos -> pop .)
    RKEY            reduce using rule 35 (metodos -> pop .)


state 20

    (76) abrir_archivo -> FOPEN . LPAREN string RPAREN
    (77) abrir_archivo -> FOPEN . LPAREN string RPAREN ENDLINE

    LPAREN          shift and go to state 56


state 21

    (78) lectura_archivo -> FGETS . LPAREN abrir_archivo RPAREN ENDLINE

    LPAREN          shift and go to state 57


state 22

    (53) if -> IF . LPAREN expresion RPAREN LKEY cuerpo RKEY

    LPAREN          shift and go to state 58


state 23

    (80) while -> WHILE . LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> WHILE . LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY

    LPAREN          shift and go to state 59


state 24

    (97) for -> FOR . LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    LPAREN          shift and go to state 60


state 25

    (2) cuerpo -> salida cuerpo .

    $end            reduce using rule 2 (cuerpo -> salida cuerpo .)
    RKEY            reduce using rule 2 (cuerpo -> salida cuerpo .)
    ECHO            reduce using rule 2 (cuerpo -> salida cuerpo .)
    PRINT           reduce using rule 2 (cuerpo -> salida cuerpo .)
    VARIABLE        reduce using rule 2 (cuerpo -> salida cuerpo .)
    FUNCTION        reduce using rule 2 (cuerpo -> salida cuerpo .)
    FOPEN           reduce using rule 2 (cuerpo -> salida cuerpo .)
    FGETS           reduce using rule 2 (cuerpo -> salida cuerpo .)
    IF              reduce using rule 2 (cuerpo -> salida cuerpo .)
    WHILE           reduce using rule 2 (cuerpo -> salida cuerpo .)
    FOR             reduce using rule 2 (cuerpo -> salida cuerpo .)


state 26

    (4) cuerpo -> asignacion cuerpo .

    $end            reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    RKEY            reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    ECHO            reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    PRINT           reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    VARIABLE        reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    FUNCTION        reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    FOPEN           reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    FGETS           reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    IF              reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    WHILE           reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    FOR             reduce using rule 4 (cuerpo -> asignacion cuerpo .)


state 27

    (6) cuerpo -> function cuerpo .

    $end            reduce using rule 6 (cuerpo -> function cuerpo .)
    RKEY            reduce using rule 6 (cuerpo -> function cuerpo .)
    ECHO            reduce using rule 6 (cuerpo -> function cuerpo .)
    PRINT           reduce using rule 6 (cuerpo -> function cuerpo .)
    VARIABLE        reduce using rule 6 (cuerpo -> function cuerpo .)
    FUNCTION        reduce using rule 6 (cuerpo -> function cuerpo .)
    FOPEN           reduce using rule 6 (cuerpo -> function cuerpo .)
    FGETS           reduce using rule 6 (cuerpo -> function cuerpo .)
    IF              reduce using rule 6 (cuerpo -> function cuerpo .)
    WHILE           reduce using rule 6 (cuerpo -> function cuerpo .)
    FOR             reduce using rule 6 (cuerpo -> function cuerpo .)


state 28

    (8) cuerpo -> estructuras_control cuerpo .

    $end            reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    RKEY            reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    ECHO            reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    PRINT           reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    VARIABLE        reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    FUNCTION        reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    FOPEN           reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    FGETS           reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    IF              reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    WHILE           reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    FOR             reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)


state 29

    (10) cuerpo -> metodos cuerpo .

    $end            reduce using rule 10 (cuerpo -> metodos cuerpo .)
    RKEY            reduce using rule 10 (cuerpo -> metodos cuerpo .)
    ECHO            reduce using rule 10 (cuerpo -> metodos cuerpo .)
    PRINT           reduce using rule 10 (cuerpo -> metodos cuerpo .)
    VARIABLE        reduce using rule 10 (cuerpo -> metodos cuerpo .)
    FUNCTION        reduce using rule 10 (cuerpo -> metodos cuerpo .)
    FOPEN           reduce using rule 10 (cuerpo -> metodos cuerpo .)
    FGETS           reduce using rule 10 (cuerpo -> metodos cuerpo .)
    IF              reduce using rule 10 (cuerpo -> metodos cuerpo .)
    WHILE           reduce using rule 10 (cuerpo -> metodos cuerpo .)
    FOR             reduce using rule 10 (cuerpo -> metodos cuerpo .)


state 30

    (13) salida -> ECHO valor . ENDLINE
    (22) valor -> valor .
    (85) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

  ! shift/reduce conflict for ENDLINE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ENDLINE         shift and go to state 61
    LPAREN          shift and go to state 62

  ! ENDLINE         [ reduce using rule 22 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 22 (valor -> valor .) ]


state 31

    (15) valor -> ARGUMENTO .

    ENDLINE         reduce using rule 15 (valor -> ARGUMENTO .)
    LPAREN          reduce using rule 15 (valor -> ARGUMENTO .)
    COMA            reduce using rule 15 (valor -> ARGUMENTO .)
    RBRACKET        reduce using rule 15 (valor -> ARGUMENTO .)
    RPAREN          reduce using rule 15 (valor -> ARGUMENTO .)
    BOOLEAN_AND     reduce using rule 15 (valor -> ARGUMENTO .)
    BOOLEAN_OR      reduce using rule 15 (valor -> ARGUMENTO .)
    AND             reduce using rule 15 (valor -> ARGUMENTO .)
    OR              reduce using rule 15 (valor -> ARGUMENTO .)
    XOR             reduce using rule 15 (valor -> ARGUMENTO .)
    IS_EQUAL        reduce using rule 15 (valor -> ARGUMENTO .)
    IS_GREATER_OR_EQUAL reduce using rule 15 (valor -> ARGUMENTO .)
    IS_NOT_EQUAL    reduce using rule 15 (valor -> ARGUMENTO .)
    IS_SMALLER_OR_EQUAL reduce using rule 15 (valor -> ARGUMENTO .)
    IS_GREATER      reduce using rule 15 (valor -> ARGUMENTO .)
    IS_SMALLER      reduce using rule 15 (valor -> ARGUMENTO .)


state 32

    (16) valor -> number .

    ENDLINE         reduce using rule 16 (valor -> number .)
    LPAREN          reduce using rule 16 (valor -> number .)
    COMA            reduce using rule 16 (valor -> number .)
    RBRACKET        reduce using rule 16 (valor -> number .)
    RPAREN          reduce using rule 16 (valor -> number .)
    IS_EQUAL        reduce using rule 16 (valor -> number .)
    IS_GREATER_OR_EQUAL reduce using rule 16 (valor -> number .)
    IS_NOT_EQUAL    reduce using rule 16 (valor -> number .)
    IS_SMALLER_OR_EQUAL reduce using rule 16 (valor -> number .)
    IS_GREATER      reduce using rule 16 (valor -> number .)
    IS_SMALLER      reduce using rule 16 (valor -> number .)
    BOOLEAN_AND     reduce using rule 16 (valor -> number .)
    BOOLEAN_OR      reduce using rule 16 (valor -> number .)
    AND             reduce using rule 16 (valor -> number .)
    OR              reduce using rule 16 (valor -> number .)
    XOR             reduce using rule 16 (valor -> number .)


state 33

    (17) valor -> BOOLEAN .

    ENDLINE         reduce using rule 17 (valor -> BOOLEAN .)
    LPAREN          reduce using rule 17 (valor -> BOOLEAN .)
    COMA            reduce using rule 17 (valor -> BOOLEAN .)
    RBRACKET        reduce using rule 17 (valor -> BOOLEAN .)
    RPAREN          reduce using rule 17 (valor -> BOOLEAN .)
    BOOLEAN_AND     reduce using rule 17 (valor -> BOOLEAN .)
    BOOLEAN_OR      reduce using rule 17 (valor -> BOOLEAN .)
    AND             reduce using rule 17 (valor -> BOOLEAN .)
    OR              reduce using rule 17 (valor -> BOOLEAN .)
    XOR             reduce using rule 17 (valor -> BOOLEAN .)
    IS_EQUAL        reduce using rule 17 (valor -> BOOLEAN .)
    IS_GREATER_OR_EQUAL reduce using rule 17 (valor -> BOOLEAN .)
    IS_NOT_EQUAL    reduce using rule 17 (valor -> BOOLEAN .)
    IS_SMALLER_OR_EQUAL reduce using rule 17 (valor -> BOOLEAN .)
    IS_GREATER      reduce using rule 17 (valor -> BOOLEAN .)
    IS_SMALLER      reduce using rule 17 (valor -> BOOLEAN .)


state 34

    (18) valor -> string .

    ENDLINE         reduce using rule 18 (valor -> string .)
    LPAREN          reduce using rule 18 (valor -> string .)
    COMA            reduce using rule 18 (valor -> string .)
    RBRACKET        reduce using rule 18 (valor -> string .)
    RPAREN          reduce using rule 18 (valor -> string .)
    BOOLEAN_AND     reduce using rule 18 (valor -> string .)
    BOOLEAN_OR      reduce using rule 18 (valor -> string .)
    AND             reduce using rule 18 (valor -> string .)
    OR              reduce using rule 18 (valor -> string .)
    XOR             reduce using rule 18 (valor -> string .)
    IS_EQUAL        reduce using rule 18 (valor -> string .)
    IS_GREATER_OR_EQUAL reduce using rule 18 (valor -> string .)
    IS_NOT_EQUAL    reduce using rule 18 (valor -> string .)
    IS_SMALLER_OR_EQUAL reduce using rule 18 (valor -> string .)
    IS_GREATER      reduce using rule 18 (valor -> string .)
    IS_SMALLER      reduce using rule 18 (valor -> string .)


state 35

    (19) valor -> VARIABLE .

    ENDLINE         reduce using rule 19 (valor -> VARIABLE .)
    LPAREN          reduce using rule 19 (valor -> VARIABLE .)
    COMA            reduce using rule 19 (valor -> VARIABLE .)
    RBRACKET        reduce using rule 19 (valor -> VARIABLE .)
    RPAREN          reduce using rule 19 (valor -> VARIABLE .)
    BOOLEAN_AND     reduce using rule 19 (valor -> VARIABLE .)
    BOOLEAN_OR      reduce using rule 19 (valor -> VARIABLE .)
    AND             reduce using rule 19 (valor -> VARIABLE .)
    OR              reduce using rule 19 (valor -> VARIABLE .)
    XOR             reduce using rule 19 (valor -> VARIABLE .)
    IS_EQUAL        reduce using rule 19 (valor -> VARIABLE .)
    IS_GREATER_OR_EQUAL reduce using rule 19 (valor -> VARIABLE .)
    IS_NOT_EQUAL    reduce using rule 19 (valor -> VARIABLE .)
    IS_SMALLER_OR_EQUAL reduce using rule 19 (valor -> VARIABLE .)
    IS_GREATER      reduce using rule 19 (valor -> VARIABLE .)
    IS_SMALLER      reduce using rule 19 (valor -> VARIABLE .)


state 36

    (20) valor -> estructuras_datos .

    ENDLINE         reduce using rule 20 (valor -> estructuras_datos .)
    LPAREN          reduce using rule 20 (valor -> estructuras_datos .)
    COMA            reduce using rule 20 (valor -> estructuras_datos .)
    RBRACKET        reduce using rule 20 (valor -> estructuras_datos .)
    RPAREN          reduce using rule 20 (valor -> estructuras_datos .)
    BOOLEAN_AND     reduce using rule 20 (valor -> estructuras_datos .)
    BOOLEAN_OR      reduce using rule 20 (valor -> estructuras_datos .)
    AND             reduce using rule 20 (valor -> estructuras_datos .)
    OR              reduce using rule 20 (valor -> estructuras_datos .)
    XOR             reduce using rule 20 (valor -> estructuras_datos .)
    IS_EQUAL        reduce using rule 20 (valor -> estructuras_datos .)
    IS_GREATER_OR_EQUAL reduce using rule 20 (valor -> estructuras_datos .)
    IS_NOT_EQUAL    reduce using rule 20 (valor -> estructuras_datos .)
    IS_SMALLER_OR_EQUAL reduce using rule 20 (valor -> estructuras_datos .)
    IS_GREATER      reduce using rule 20 (valor -> estructuras_datos .)
    IS_SMALLER      reduce using rule 20 (valor -> estructuras_datos .)


state 37

    (21) valor -> funciones .

    ENDLINE         reduce using rule 21 (valor -> funciones .)
    LPAREN          reduce using rule 21 (valor -> funciones .)
    COMA            reduce using rule 21 (valor -> funciones .)
    RBRACKET        reduce using rule 21 (valor -> funciones .)
    RPAREN          reduce using rule 21 (valor -> funciones .)
    BOOLEAN_AND     reduce using rule 21 (valor -> funciones .)
    BOOLEAN_OR      reduce using rule 21 (valor -> funciones .)
    AND             reduce using rule 21 (valor -> funciones .)
    OR              reduce using rule 21 (valor -> funciones .)
    XOR             reduce using rule 21 (valor -> funciones .)
    IS_EQUAL        reduce using rule 21 (valor -> funciones .)
    IS_GREATER_OR_EQUAL reduce using rule 21 (valor -> funciones .)
    IS_NOT_EQUAL    reduce using rule 21 (valor -> funciones .)
    IS_SMALLER_OR_EQUAL reduce using rule 21 (valor -> funciones .)
    IS_GREATER      reduce using rule 21 (valor -> funciones .)
    IS_SMALLER      reduce using rule 21 (valor -> funciones .)


state 38

    (66) number -> INTEGER .

    ENDLINE         reduce using rule 66 (number -> INTEGER .)
    LPAREN          reduce using rule 66 (number -> INTEGER .)
    COMA            reduce using rule 66 (number -> INTEGER .)
    RBRACKET        reduce using rule 66 (number -> INTEGER .)
    RPAREN          reduce using rule 66 (number -> INTEGER .)
    ADDITION        reduce using rule 66 (number -> INTEGER .)
    SUBTRACTION     reduce using rule 66 (number -> INTEGER .)
    MULTIPLICATION  reduce using rule 66 (number -> INTEGER .)
    DIVISION        reduce using rule 66 (number -> INTEGER .)
    MODULO          reduce using rule 66 (number -> INTEGER .)
    EXPONENTIATION  reduce using rule 66 (number -> INTEGER .)
    BOOLEAN_AND     reduce using rule 66 (number -> INTEGER .)
    BOOLEAN_OR      reduce using rule 66 (number -> INTEGER .)
    AND             reduce using rule 66 (number -> INTEGER .)
    OR              reduce using rule 66 (number -> INTEGER .)
    XOR             reduce using rule 66 (number -> INTEGER .)
    IS_EQUAL        reduce using rule 66 (number -> INTEGER .)
    IS_GREATER_OR_EQUAL reduce using rule 66 (number -> INTEGER .)
    IS_NOT_EQUAL    reduce using rule 66 (number -> INTEGER .)
    IS_SMALLER_OR_EQUAL reduce using rule 66 (number -> INTEGER .)
    IS_GREATER      reduce using rule 66 (number -> INTEGER .)
    IS_SMALLER      reduce using rule 66 (number -> INTEGER .)


state 39

    (67) number -> FLOAT .

    ENDLINE         reduce using rule 67 (number -> FLOAT .)
    LPAREN          reduce using rule 67 (number -> FLOAT .)
    COMA            reduce using rule 67 (number -> FLOAT .)
    RBRACKET        reduce using rule 67 (number -> FLOAT .)
    RPAREN          reduce using rule 67 (number -> FLOAT .)
    ADDITION        reduce using rule 67 (number -> FLOAT .)
    SUBTRACTION     reduce using rule 67 (number -> FLOAT .)
    MULTIPLICATION  reduce using rule 67 (number -> FLOAT .)
    DIVISION        reduce using rule 67 (number -> FLOAT .)
    MODULO          reduce using rule 67 (number -> FLOAT .)
    EXPONENTIATION  reduce using rule 67 (number -> FLOAT .)
    BOOLEAN_AND     reduce using rule 67 (number -> FLOAT .)
    BOOLEAN_OR      reduce using rule 67 (number -> FLOAT .)
    AND             reduce using rule 67 (number -> FLOAT .)
    OR              reduce using rule 67 (number -> FLOAT .)
    XOR             reduce using rule 67 (number -> FLOAT .)
    IS_EQUAL        reduce using rule 67 (number -> FLOAT .)
    IS_GREATER_OR_EQUAL reduce using rule 67 (number -> FLOAT .)
    IS_NOT_EQUAL    reduce using rule 67 (number -> FLOAT .)
    IS_SMALLER_OR_EQUAL reduce using rule 67 (number -> FLOAT .)
    IS_GREATER      reduce using rule 67 (number -> FLOAT .)
    IS_SMALLER      reduce using rule 67 (number -> FLOAT .)


state 40

    (23) string -> STRING .

    ENDLINE         reduce using rule 23 (string -> STRING .)
    LPAREN          reduce using rule 23 (string -> STRING .)
    COMA            reduce using rule 23 (string -> STRING .)
    RBRACKET        reduce using rule 23 (string -> STRING .)
    RPAREN          reduce using rule 23 (string -> STRING .)
    BOOLEAN_AND     reduce using rule 23 (string -> STRING .)
    BOOLEAN_OR      reduce using rule 23 (string -> STRING .)
    AND             reduce using rule 23 (string -> STRING .)
    OR              reduce using rule 23 (string -> STRING .)
    XOR             reduce using rule 23 (string -> STRING .)
    IS_EQUAL        reduce using rule 23 (string -> STRING .)
    IS_GREATER_OR_EQUAL reduce using rule 23 (string -> STRING .)
    IS_NOT_EQUAL    reduce using rule 23 (string -> STRING .)
    IS_SMALLER_OR_EQUAL reduce using rule 23 (string -> STRING .)
    IS_GREATER      reduce using rule 23 (string -> STRING .)
    IS_SMALLER      reduce using rule 23 (string -> STRING .)


state 41

    (24) string -> COMILLA_DOBLE . STRING COMILLA_DOBLE

    STRING          shift and go to state 63


state 42

    (25) string -> COMILLA_SIMPLE . STRING COMILLA_SIMPLE

    STRING          shift and go to state 64


state 43

    (39) estructuras_datos -> array .

    ENDLINE         reduce using rule 39 (estructuras_datos -> array .)
    LPAREN          reduce using rule 39 (estructuras_datos -> array .)
    COMA            reduce using rule 39 (estructuras_datos -> array .)
    RBRACKET        reduce using rule 39 (estructuras_datos -> array .)
    RPAREN          reduce using rule 39 (estructuras_datos -> array .)
    BOOLEAN_AND     reduce using rule 39 (estructuras_datos -> array .)
    BOOLEAN_OR      reduce using rule 39 (estructuras_datos -> array .)
    AND             reduce using rule 39 (estructuras_datos -> array .)
    OR              reduce using rule 39 (estructuras_datos -> array .)
    XOR             reduce using rule 39 (estructuras_datos -> array .)
    IS_EQUAL        reduce using rule 39 (estructuras_datos -> array .)
    IS_GREATER_OR_EQUAL reduce using rule 39 (estructuras_datos -> array .)
    IS_NOT_EQUAL    reduce using rule 39 (estructuras_datos -> array .)
    IS_SMALLER_OR_EQUAL reduce using rule 39 (estructuras_datos -> array .)
    IS_GREATER      reduce using rule 39 (estructuras_datos -> array .)
    IS_SMALLER      reduce using rule 39 (estructuras_datos -> array .)


state 44

    (40) estructuras_datos -> queue .

    ENDLINE         reduce using rule 40 (estructuras_datos -> queue .)
    LPAREN          reduce using rule 40 (estructuras_datos -> queue .)
    COMA            reduce using rule 40 (estructuras_datos -> queue .)
    RBRACKET        reduce using rule 40 (estructuras_datos -> queue .)
    RPAREN          reduce using rule 40 (estructuras_datos -> queue .)
    BOOLEAN_AND     reduce using rule 40 (estructuras_datos -> queue .)
    BOOLEAN_OR      reduce using rule 40 (estructuras_datos -> queue .)
    AND             reduce using rule 40 (estructuras_datos -> queue .)
    OR              reduce using rule 40 (estructuras_datos -> queue .)
    XOR             reduce using rule 40 (estructuras_datos -> queue .)
    IS_EQUAL        reduce using rule 40 (estructuras_datos -> queue .)
    IS_GREATER_OR_EQUAL reduce using rule 40 (estructuras_datos -> queue .)
    IS_NOT_EQUAL    reduce using rule 40 (estructuras_datos -> queue .)
    IS_SMALLER_OR_EQUAL reduce using rule 40 (estructuras_datos -> queue .)
    IS_GREATER      reduce using rule 40 (estructuras_datos -> queue .)
    IS_SMALLER      reduce using rule 40 (estructuras_datos -> queue .)


state 45

    (82) array -> LBRACKET . valorArreglo RBRACKET ENDLINE
    (83) valorArreglo -> . valor COMA valorArreglo
    (84) valorArreglo -> . valor
    (15) valor -> . ARGUMENTO
    (16) valor -> . number
    (17) valor -> . BOOLEAN
    (18) valor -> . string
    (19) valor -> . VARIABLE
    (20) valor -> . estructuras_datos
    (21) valor -> . funciones
    (22) valor -> . valor
    (66) number -> . INTEGER
    (67) number -> . FLOAT
    (23) string -> . STRING
    (24) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (25) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (39) estructuras_datos -> . array
    (40) estructuras_datos -> . queue
    (85) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (82) array -> . LBRACKET valorArreglo RBRACKET ENDLINE
    (30) queue -> . NEW SPLQUEUE LPAREN RPAREN

    ARGUMENTO       shift and go to state 31
    BOOLEAN         shift and go to state 33
    VARIABLE        shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    COMILLA_DOBLE   shift and go to state 41
    COMILLA_SIMPLE  shift and go to state 42
    LBRACKET        shift and go to state 45
    NEW             shift and go to state 46

    valorArreglo                   shift and go to state 65
    valor                          shift and go to state 66
    number                         shift and go to state 32
    string                         shift and go to state 34
    estructuras_datos              shift and go to state 36
    funciones                      shift and go to state 37
    array                          shift and go to state 43
    queue                          shift and go to state 44

state 46

    (30) queue -> NEW . SPLQUEUE LPAREN RPAREN

    SPLQUEUE        shift and go to state 67


state 47

    (14) salida -> PRINT LPAREN . valor RPAREN ENDLINE
    (15) valor -> . ARGUMENTO
    (16) valor -> . number
    (17) valor -> . BOOLEAN
    (18) valor -> . string
    (19) valor -> . VARIABLE
    (20) valor -> . estructuras_datos
    (21) valor -> . funciones
    (22) valor -> . valor
    (66) number -> . INTEGER
    (67) number -> . FLOAT
    (23) string -> . STRING
    (24) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (25) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (39) estructuras_datos -> . array
    (40) estructuras_datos -> . queue
    (85) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (82) array -> . LBRACKET valorArreglo RBRACKET ENDLINE
    (30) queue -> . NEW SPLQUEUE LPAREN RPAREN

    ARGUMENTO       shift and go to state 31
    BOOLEAN         shift and go to state 33
    VARIABLE        shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    COMILLA_DOBLE   shift and go to state 41
    COMILLA_SIMPLE  shift and go to state 42
    LBRACKET        shift and go to state 45
    NEW             shift and go to state 46

    valor                          shift and go to state 68
    number                         shift and go to state 32
    string                         shift and go to state 34
    estructuras_datos              shift and go to state 36
    funciones                      shift and go to state 37
    array                          shift and go to state 43
    queue                          shift and go to state 44

state 48

    (27) asignacion -> VARIABLE operador_asignacion . valor ENDLINE
    (28) asignacion -> VARIABLE operador_asignacion . expresion ENDLINE
    (15) valor -> . ARGUMENTO
    (16) valor -> . number
    (17) valor -> . BOOLEAN
    (18) valor -> . string
    (19) valor -> . VARIABLE
    (20) valor -> . estructuras_datos
    (21) valor -> . funciones
    (22) valor -> . valor
    (55) expresion -> . expresiones_logicas
    (56) expresion -> . expresion_aritmetica
    (66) number -> . INTEGER
    (67) number -> . FLOAT
    (23) string -> . STRING
    (24) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (25) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (39) estructuras_datos -> . array
    (40) estructuras_datos -> . queue
    (85) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (57) expresiones_logicas -> . valor
    (58) expresiones_logicas -> . valor operador expresiones_logicas
    (74) expresion_aritmetica -> . number
    (75) expresion_aritmetica -> . number operador_aritmetico expresion_aritmetica
    (82) array -> . LBRACKET valorArreglo RBRACKET ENDLINE
    (30) queue -> . NEW SPLQUEUE LPAREN RPAREN

    ARGUMENTO       shift and go to state 31
    BOOLEAN         shift and go to state 33
    VARIABLE        shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    COMILLA_DOBLE   shift and go to state 41
    COMILLA_SIMPLE  shift and go to state 42
    LBRACKET        shift and go to state 45
    NEW             shift and go to state 46

    valor                          shift and go to state 69
    expresion                      shift and go to state 70
    number                         shift and go to state 71
    string                         shift and go to state 34
    estructuras_datos              shift and go to state 36
    funciones                      shift and go to state 37
    expresiones_logicas            shift and go to state 72
    expresion_aritmetica           shift and go to state 73
    array                          shift and go to state 43
    queue                          shift and go to state 44

state 49

    (36) operador_asignacion -> EQUAL .

    ARGUMENTO       reduce using rule 36 (operador_asignacion -> EQUAL .)
    BOOLEAN         reduce using rule 36 (operador_asignacion -> EQUAL .)
    VARIABLE        reduce using rule 36 (operador_asignacion -> EQUAL .)
    INTEGER         reduce using rule 36 (operador_asignacion -> EQUAL .)
    FLOAT           reduce using rule 36 (operador_asignacion -> EQUAL .)
    STRING          reduce using rule 36 (operador_asignacion -> EQUAL .)
    COMILLA_DOBLE   reduce using rule 36 (operador_asignacion -> EQUAL .)
    COMILLA_SIMPLE  reduce using rule 36 (operador_asignacion -> EQUAL .)
    LBRACKET        reduce using rule 36 (operador_asignacion -> EQUAL .)
    NEW             reduce using rule 36 (operador_asignacion -> EQUAL .)


state 50

    (37) operador_asignacion -> PLUS_EQUAL .

    ARGUMENTO       reduce using rule 37 (operador_asignacion -> PLUS_EQUAL .)
    BOOLEAN         reduce using rule 37 (operador_asignacion -> PLUS_EQUAL .)
    VARIABLE        reduce using rule 37 (operador_asignacion -> PLUS_EQUAL .)
    INTEGER         reduce using rule 37 (operador_asignacion -> PLUS_EQUAL .)
    FLOAT           reduce using rule 37 (operador_asignacion -> PLUS_EQUAL .)
    STRING          reduce using rule 37 (operador_asignacion -> PLUS_EQUAL .)
    COMILLA_DOBLE   reduce using rule 37 (operador_asignacion -> PLUS_EQUAL .)
    COMILLA_SIMPLE  reduce using rule 37 (operador_asignacion -> PLUS_EQUAL .)
    LBRACKET        reduce using rule 37 (operador_asignacion -> PLUS_EQUAL .)
    NEW             reduce using rule 37 (operador_asignacion -> PLUS_EQUAL .)


state 51

    (38) operador_asignacion -> CONCAT_EQUAL .

    ARGUMENTO       reduce using rule 38 (operador_asignacion -> CONCAT_EQUAL .)
    BOOLEAN         reduce using rule 38 (operador_asignacion -> CONCAT_EQUAL .)
    VARIABLE        reduce using rule 38 (operador_asignacion -> CONCAT_EQUAL .)
    INTEGER         reduce using rule 38 (operador_asignacion -> CONCAT_EQUAL .)
    FLOAT           reduce using rule 38 (operador_asignacion -> CONCAT_EQUAL .)
    STRING          reduce using rule 38 (operador_asignacion -> CONCAT_EQUAL .)
    COMILLA_DOBLE   reduce using rule 38 (operador_asignacion -> CONCAT_EQUAL .)
    COMILLA_SIMPLE  reduce using rule 38 (operador_asignacion -> CONCAT_EQUAL .)
    LBRACKET        reduce using rule 38 (operador_asignacion -> CONCAT_EQUAL .)
    NEW             reduce using rule 38 (operador_asignacion -> CONCAT_EQUAL .)


state 52

    (29) asignacion -> queue_variable operador_asignacion . queue ENDLINE
    (30) queue -> . NEW SPLQUEUE LPAREN RPAREN

    NEW             shift and go to state 46

    queue                          shift and go to state 74

state 53

    (32) push -> queue_variable ARROW . PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> queue_variable ARROW . POP LPAREN RPAREN ENDLINE

    PUSH            shift and go to state 75
    POP             shift and go to state 76


state 54

    (26) function -> FUNCTION ARGUMENTO . LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY

    LPAREN          shift and go to state 77


state 55

    (54) else -> if ELSE . LKEY cuerpo RKEY

    LKEY            shift and go to state 78


state 56

    (76) abrir_archivo -> FOPEN LPAREN . string RPAREN
    (77) abrir_archivo -> FOPEN LPAREN . string RPAREN ENDLINE
    (23) string -> . STRING
    (24) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (25) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE

    STRING          shift and go to state 40
    COMILLA_DOBLE   shift and go to state 41
    COMILLA_SIMPLE  shift and go to state 42

    string                         shift and go to state 79

state 57

    (78) lectura_archivo -> FGETS LPAREN . abrir_archivo RPAREN ENDLINE
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE

    FOPEN           shift and go to state 20

    abrir_archivo                  shift and go to state 80

state 58

    (53) if -> IF LPAREN . expresion RPAREN LKEY cuerpo RKEY
    (55) expresion -> . expresiones_logicas
    (56) expresion -> . expresion_aritmetica
    (57) expresiones_logicas -> . valor
    (58) expresiones_logicas -> . valor operador expresiones_logicas
    (74) expresion_aritmetica -> . number
    (75) expresion_aritmetica -> . number operador_aritmetico expresion_aritmetica
    (15) valor -> . ARGUMENTO
    (16) valor -> . number
    (17) valor -> . BOOLEAN
    (18) valor -> . string
    (19) valor -> . VARIABLE
    (20) valor -> . estructuras_datos
    (21) valor -> . funciones
    (22) valor -> . valor
    (66) number -> . INTEGER
    (67) number -> . FLOAT
    (23) string -> . STRING
    (24) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (25) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (39) estructuras_datos -> . array
    (40) estructuras_datos -> . queue
    (85) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (82) array -> . LBRACKET valorArreglo RBRACKET ENDLINE
    (30) queue -> . NEW SPLQUEUE LPAREN RPAREN

    ARGUMENTO       shift and go to state 31
    BOOLEAN         shift and go to state 33
    VARIABLE        shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    COMILLA_DOBLE   shift and go to state 41
    COMILLA_SIMPLE  shift and go to state 42
    LBRACKET        shift and go to state 45
    NEW             shift and go to state 46

    expresion                      shift and go to state 81
    expresiones_logicas            shift and go to state 72
    expresion_aritmetica           shift and go to state 73
    valor                          shift and go to state 82
    number                         shift and go to state 83
    string                         shift and go to state 34
    estructuras_datos              shift and go to state 36
    funciones                      shift and go to state 37
    array                          shift and go to state 43
    queue                          shift and go to state 44

state 59

    (80) while -> WHILE LPAREN . valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> WHILE LPAREN . valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (15) valor -> . ARGUMENTO
    (16) valor -> . number
    (17) valor -> . BOOLEAN
    (18) valor -> . string
    (19) valor -> . VARIABLE
    (20) valor -> . estructuras_datos
    (21) valor -> . funciones
    (22) valor -> . valor
    (66) number -> . INTEGER
    (67) number -> . FLOAT
    (23) string -> . STRING
    (24) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (25) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (39) estructuras_datos -> . array
    (40) estructuras_datos -> . queue
    (85) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (82) array -> . LBRACKET valorArreglo RBRACKET ENDLINE
    (30) queue -> . NEW SPLQUEUE LPAREN RPAREN

    ARGUMENTO       shift and go to state 31
    BOOLEAN         shift and go to state 33
    VARIABLE        shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    COMILLA_DOBLE   shift and go to state 41
    COMILLA_SIMPLE  shift and go to state 42
    LBRACKET        shift and go to state 45
    NEW             shift and go to state 46

    valor                          shift and go to state 84
    number                         shift and go to state 32
    string                         shift and go to state 34
    estructuras_datos              shift and go to state 36
    funciones                      shift and go to state 37
    array                          shift and go to state 43
    queue                          shift and go to state 44

state 60

    (97) for -> FOR LPAREN . VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    VARIABLE        shift and go to state 85


state 61

    (13) salida -> ECHO valor ENDLINE .

    ECHO            reduce using rule 13 (salida -> ECHO valor ENDLINE .)
    PRINT           reduce using rule 13 (salida -> ECHO valor ENDLINE .)
    VARIABLE        reduce using rule 13 (salida -> ECHO valor ENDLINE .)
    FUNCTION        reduce using rule 13 (salida -> ECHO valor ENDLINE .)
    FOPEN           reduce using rule 13 (salida -> ECHO valor ENDLINE .)
    FGETS           reduce using rule 13 (salida -> ECHO valor ENDLINE .)
    IF              reduce using rule 13 (salida -> ECHO valor ENDLINE .)
    WHILE           reduce using rule 13 (salida -> ECHO valor ENDLINE .)
    FOR             reduce using rule 13 (salida -> ECHO valor ENDLINE .)
    $end            reduce using rule 13 (salida -> ECHO valor ENDLINE .)
    RKEY            reduce using rule 13 (salida -> ECHO valor ENDLINE .)


state 62

    (85) funciones -> valor LPAREN . valor RPAREN LKEY cuerpo RKEY
    (15) valor -> . ARGUMENTO
    (16) valor -> . number
    (17) valor -> . BOOLEAN
    (18) valor -> . string
    (19) valor -> . VARIABLE
    (20) valor -> . estructuras_datos
    (21) valor -> . funciones
    (22) valor -> . valor
    (66) number -> . INTEGER
    (67) number -> . FLOAT
    (23) string -> . STRING
    (24) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (25) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (39) estructuras_datos -> . array
    (40) estructuras_datos -> . queue
    (85) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (82) array -> . LBRACKET valorArreglo RBRACKET ENDLINE
    (30) queue -> . NEW SPLQUEUE LPAREN RPAREN

    ARGUMENTO       shift and go to state 31
    BOOLEAN         shift and go to state 33
    VARIABLE        shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    COMILLA_DOBLE   shift and go to state 41
    COMILLA_SIMPLE  shift and go to state 42
    LBRACKET        shift and go to state 45
    NEW             shift and go to state 46

    valor                          shift and go to state 86
    number                         shift and go to state 32
    string                         shift and go to state 34
    estructuras_datos              shift and go to state 36
    funciones                      shift and go to state 37
    array                          shift and go to state 43
    queue                          shift and go to state 44

state 63

    (24) string -> COMILLA_DOBLE STRING . COMILLA_DOBLE

    COMILLA_DOBLE   shift and go to state 87


state 64

    (25) string -> COMILLA_SIMPLE STRING . COMILLA_SIMPLE

    COMILLA_SIMPLE  shift and go to state 88


state 65

    (82) array -> LBRACKET valorArreglo . RBRACKET ENDLINE

    RBRACKET        shift and go to state 89


state 66

    (83) valorArreglo -> valor . COMA valorArreglo
    (84) valorArreglo -> valor .
    (22) valor -> valor .
    (85) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

  ! shift/reduce conflict for COMA resolved as shift
  ! reduce/reduce conflict for RBRACKET resolved using rule 22 (valor -> valor .)
  ! shift/reduce conflict for LPAREN resolved as shift
    COMA            shift and go to state 90
    RBRACKET        reduce using rule 22 (valor -> valor .)
    LPAREN          shift and go to state 62

  ! RBRACKET        [ reduce using rule 84 (valorArreglo -> valor .) ]
  ! COMA            [ reduce using rule 22 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 22 (valor -> valor .) ]


state 67

    (30) queue -> NEW SPLQUEUE . LPAREN RPAREN

    LPAREN          shift and go to state 91


state 68

    (14) salida -> PRINT LPAREN valor . RPAREN ENDLINE
    (22) valor -> valor .
    (85) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          shift and go to state 92
    LPAREN          shift and go to state 62

  ! RPAREN          [ reduce using rule 22 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 22 (valor -> valor .) ]


state 69

    (27) asignacion -> VARIABLE operador_asignacion valor . ENDLINE
    (22) valor -> valor .
    (85) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY
    (57) expresiones_logicas -> valor .
    (58) expresiones_logicas -> valor . operador expresiones_logicas
    (64) operador -> . operador_logico
    (65) operador -> . operador_comparacion
    (59) operador_logico -> . BOOLEAN_AND
    (60) operador_logico -> . BOOLEAN_OR
    (61) operador_logico -> . AND
    (62) operador_logico -> . OR
    (63) operador_logico -> . XOR
    (41) operador_comparacion -> . IS_EQUAL
    (42) operador_comparacion -> . IS_GREATER_OR_EQUAL
    (43) operador_comparacion -> . IS_NOT_EQUAL
    (44) operador_comparacion -> . IS_SMALLER_OR_EQUAL
    (45) operador_comparacion -> . IS_GREATER
    (46) operador_comparacion -> . IS_SMALLER

  ! shift/reduce conflict for ENDLINE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ENDLINE resolved as shift
  ! shift/reduce conflict for BOOLEAN_AND resolved as shift
  ! shift/reduce conflict for BOOLEAN_OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for IS_EQUAL resolved as shift
  ! shift/reduce conflict for IS_GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for IS_NOT_EQUAL resolved as shift
  ! shift/reduce conflict for IS_SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for IS_GREATER resolved as shift
  ! shift/reduce conflict for IS_SMALLER resolved as shift
    ENDLINE         shift and go to state 93
    LPAREN          shift and go to state 62
    BOOLEAN_AND     shift and go to state 97
    BOOLEAN_OR      shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    IS_EQUAL        shift and go to state 102
    IS_GREATER_OR_EQUAL shift and go to state 103
    IS_NOT_EQUAL    shift and go to state 104
    IS_SMALLER_OR_EQUAL shift and go to state 105
    IS_GREATER      shift and go to state 106
    IS_SMALLER      shift and go to state 107

  ! ENDLINE         [ reduce using rule 22 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 22 (valor -> valor .) ]
  ! BOOLEAN_AND     [ reduce using rule 22 (valor -> valor .) ]
  ! BOOLEAN_OR      [ reduce using rule 22 (valor -> valor .) ]
  ! AND             [ reduce using rule 22 (valor -> valor .) ]
  ! OR              [ reduce using rule 22 (valor -> valor .) ]
  ! XOR             [ reduce using rule 22 (valor -> valor .) ]
  ! IS_EQUAL        [ reduce using rule 22 (valor -> valor .) ]
  ! IS_GREATER_OR_EQUAL [ reduce using rule 22 (valor -> valor .) ]
  ! IS_NOT_EQUAL    [ reduce using rule 22 (valor -> valor .) ]
  ! IS_SMALLER_OR_EQUAL [ reduce using rule 22 (valor -> valor .) ]
  ! IS_GREATER      [ reduce using rule 22 (valor -> valor .) ]
  ! IS_SMALLER      [ reduce using rule 22 (valor -> valor .) ]
  ! ENDLINE         [ reduce using rule 57 (expresiones_logicas -> valor .) ]

    operador                       shift and go to state 94
    operador_logico                shift and go to state 95
    operador_comparacion           shift and go to state 96

state 70

    (28) asignacion -> VARIABLE operador_asignacion expresion . ENDLINE

    ENDLINE         shift and go to state 108


state 71

    (16) valor -> number .
    (74) expresion_aritmetica -> number .
    (75) expresion_aritmetica -> number . operador_aritmetico expresion_aritmetica
    (68) operador_aritmetico -> . ADDITION
    (69) operador_aritmetico -> . SUBTRACTION
    (70) operador_aritmetico -> . MULTIPLICATION
    (71) operador_aritmetico -> . DIVISION
    (72) operador_aritmetico -> . MODULO
    (73) operador_aritmetico -> . EXPONENTIATION

  ! reduce/reduce conflict for ENDLINE resolved using rule 16 (valor -> number .)
    ENDLINE         reduce using rule 16 (valor -> number .)
    LPAREN          reduce using rule 16 (valor -> number .)
    BOOLEAN_AND     reduce using rule 16 (valor -> number .)
    BOOLEAN_OR      reduce using rule 16 (valor -> number .)
    AND             reduce using rule 16 (valor -> number .)
    OR              reduce using rule 16 (valor -> number .)
    XOR             reduce using rule 16 (valor -> number .)
    IS_EQUAL        reduce using rule 16 (valor -> number .)
    IS_GREATER_OR_EQUAL reduce using rule 16 (valor -> number .)
    IS_NOT_EQUAL    reduce using rule 16 (valor -> number .)
    IS_SMALLER_OR_EQUAL reduce using rule 16 (valor -> number .)
    IS_GREATER      reduce using rule 16 (valor -> number .)
    IS_SMALLER      reduce using rule 16 (valor -> number .)
    ADDITION        shift and go to state 110
    SUBTRACTION     shift and go to state 111
    MULTIPLICATION  shift and go to state 112
    DIVISION        shift and go to state 113
    MODULO          shift and go to state 114
    EXPONENTIATION  shift and go to state 115

  ! ENDLINE         [ reduce using rule 74 (expresion_aritmetica -> number .) ]

    operador_aritmetico            shift and go to state 109

state 72

    (55) expresion -> expresiones_logicas .

    ENDLINE         reduce using rule 55 (expresion -> expresiones_logicas .)
    RPAREN          reduce using rule 55 (expresion -> expresiones_logicas .)


state 73

    (56) expresion -> expresion_aritmetica .

    ENDLINE         reduce using rule 56 (expresion -> expresion_aritmetica .)
    RPAREN          reduce using rule 56 (expresion -> expresion_aritmetica .)


state 74

    (29) asignacion -> queue_variable operador_asignacion queue . ENDLINE

    ENDLINE         shift and go to state 116


state 75

    (32) push -> queue_variable ARROW PUSH . LPAREN valor RPAREN ENDLINE

    LPAREN          shift and go to state 117


state 76

    (33) pop -> queue_variable ARROW POP . LPAREN RPAREN ENDLINE

    LPAREN          shift and go to state 118


state 77

    (26) function -> FUNCTION ARGUMENTO LPAREN . VARIABLE RPAREN LKEY ARGUMENTO RKEY

    VARIABLE        shift and go to state 119


state 78

    (54) else -> if ELSE LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . metodos
    (10) cuerpo -> . metodos cuerpo
    (11) cuerpo -> . abrir_archivo
    (12) cuerpo -> . lectura_archivo
    (13) salida -> . ECHO valor ENDLINE
    (14) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (27) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (29) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (26) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (48) estructuras_control -> . if
    (49) estructuras_control -> . else
    (50) estructuras_control -> . while
    (51) estructuras_control -> . for
    (52) estructuras_control -> . estructuras_control
    (34) metodos -> . push
    (35) metodos -> . pop
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (78) lectura_archivo -> . FGETS LPAREN abrir_archivo RPAREN ENDLINE
    (31) queue_variable -> . VARIABLE
    (53) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (54) else -> . if ELSE LKEY cuerpo RKEY
    (80) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (97) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (32) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    VARIABLE        shift and go to state 11
    FUNCTION        shift and go to state 13
    FOPEN           shift and go to state 20
    FGETS           shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24

    if                             shift and go to state 14
    cuerpo                         shift and go to state 120
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    metodos                        shift and go to state 6
    abrir_archivo                  shift and go to state 7
    lectura_archivo                shift and go to state 8
    queue_variable                 shift and go to state 12
    else                           shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    push                           shift and go to state 18
    pop                            shift and go to state 19

state 79

    (76) abrir_archivo -> FOPEN LPAREN string . RPAREN
    (77) abrir_archivo -> FOPEN LPAREN string . RPAREN ENDLINE

    RPAREN          shift and go to state 121


state 80

    (78) lectura_archivo -> FGETS LPAREN abrir_archivo . RPAREN ENDLINE

    RPAREN          shift and go to state 122


state 81

    (53) if -> IF LPAREN expresion . RPAREN LKEY cuerpo RKEY

    RPAREN          shift and go to state 123


state 82

    (57) expresiones_logicas -> valor .
    (58) expresiones_logicas -> valor . operador expresiones_logicas
    (22) valor -> valor .
    (85) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY
    (64) operador -> . operador_logico
    (65) operador -> . operador_comparacion
    (59) operador_logico -> . BOOLEAN_AND
    (60) operador_logico -> . BOOLEAN_OR
    (61) operador_logico -> . AND
    (62) operador_logico -> . OR
    (63) operador_logico -> . XOR
    (41) operador_comparacion -> . IS_EQUAL
    (42) operador_comparacion -> . IS_GREATER_OR_EQUAL
    (43) operador_comparacion -> . IS_NOT_EQUAL
    (44) operador_comparacion -> . IS_SMALLER_OR_EQUAL
    (45) operador_comparacion -> . IS_GREATER
    (46) operador_comparacion -> . IS_SMALLER

  ! reduce/reduce conflict for RPAREN resolved using rule 22 (valor -> valor .)
  ! reduce/reduce conflict for ENDLINE resolved using rule 22 (valor -> valor .)
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN_AND resolved as shift
  ! shift/reduce conflict for BOOLEAN_OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for IS_EQUAL resolved as shift
  ! shift/reduce conflict for IS_GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for IS_NOT_EQUAL resolved as shift
  ! shift/reduce conflict for IS_SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for IS_GREATER resolved as shift
  ! shift/reduce conflict for IS_SMALLER resolved as shift
    RPAREN          reduce using rule 22 (valor -> valor .)
    ENDLINE         reduce using rule 22 (valor -> valor .)
    LPAREN          shift and go to state 62
    BOOLEAN_AND     shift and go to state 97
    BOOLEAN_OR      shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    IS_EQUAL        shift and go to state 102
    IS_GREATER_OR_EQUAL shift and go to state 103
    IS_NOT_EQUAL    shift and go to state 104
    IS_SMALLER_OR_EQUAL shift and go to state 105
    IS_GREATER      shift and go to state 106
    IS_SMALLER      shift and go to state 107

  ! RPAREN          [ reduce using rule 57 (expresiones_logicas -> valor .) ]
  ! ENDLINE         [ reduce using rule 57 (expresiones_logicas -> valor .) ]
  ! LPAREN          [ reduce using rule 22 (valor -> valor .) ]
  ! BOOLEAN_AND     [ reduce using rule 22 (valor -> valor .) ]
  ! BOOLEAN_OR      [ reduce using rule 22 (valor -> valor .) ]
  ! AND             [ reduce using rule 22 (valor -> valor .) ]
  ! OR              [ reduce using rule 22 (valor -> valor .) ]
  ! XOR             [ reduce using rule 22 (valor -> valor .) ]
  ! IS_EQUAL        [ reduce using rule 22 (valor -> valor .) ]
  ! IS_GREATER_OR_EQUAL [ reduce using rule 22 (valor -> valor .) ]
  ! IS_NOT_EQUAL    [ reduce using rule 22 (valor -> valor .) ]
  ! IS_SMALLER_OR_EQUAL [ reduce using rule 22 (valor -> valor .) ]
  ! IS_GREATER      [ reduce using rule 22 (valor -> valor .) ]
  ! IS_SMALLER      [ reduce using rule 22 (valor -> valor .) ]

    operador                       shift and go to state 94
    operador_logico                shift and go to state 95
    operador_comparacion           shift and go to state 96

state 83

    (74) expresion_aritmetica -> number .
    (75) expresion_aritmetica -> number . operador_aritmetico expresion_aritmetica
    (16) valor -> number .
    (68) operador_aritmetico -> . ADDITION
    (69) operador_aritmetico -> . SUBTRACTION
    (70) operador_aritmetico -> . MULTIPLICATION
    (71) operador_aritmetico -> . DIVISION
    (72) operador_aritmetico -> . MODULO
    (73) operador_aritmetico -> . EXPONENTIATION

  ! reduce/reduce conflict for RPAREN resolved using rule 16 (valor -> number .)
    LPAREN          reduce using rule 16 (valor -> number .)
    BOOLEAN_AND     reduce using rule 16 (valor -> number .)
    BOOLEAN_OR      reduce using rule 16 (valor -> number .)
    AND             reduce using rule 16 (valor -> number .)
    OR              reduce using rule 16 (valor -> number .)
    XOR             reduce using rule 16 (valor -> number .)
    IS_EQUAL        reduce using rule 16 (valor -> number .)
    IS_GREATER_OR_EQUAL reduce using rule 16 (valor -> number .)
    IS_NOT_EQUAL    reduce using rule 16 (valor -> number .)
    IS_SMALLER_OR_EQUAL reduce using rule 16 (valor -> number .)
    IS_GREATER      reduce using rule 16 (valor -> number .)
    IS_SMALLER      reduce using rule 16 (valor -> number .)
    RPAREN          reduce using rule 16 (valor -> number .)
    ADDITION        shift and go to state 110
    SUBTRACTION     shift and go to state 111
    MULTIPLICATION  shift and go to state 112
    DIVISION        shift and go to state 113
    MODULO          shift and go to state 114
    EXPONENTIATION  shift and go to state 115

  ! RPAREN          [ reduce using rule 74 (expresion_aritmetica -> number .) ]

    operador_aritmetico            shift and go to state 109

state 84

    (80) while -> WHILE LPAREN valor . operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> WHILE LPAREN valor . operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (22) valor -> valor .
    (85) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY
    (41) operador_comparacion -> . IS_EQUAL
    (42) operador_comparacion -> . IS_GREATER_OR_EQUAL
    (43) operador_comparacion -> . IS_NOT_EQUAL
    (44) operador_comparacion -> . IS_SMALLER_OR_EQUAL
    (45) operador_comparacion -> . IS_GREATER
    (46) operador_comparacion -> . IS_SMALLER

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IS_EQUAL resolved as shift
  ! shift/reduce conflict for IS_GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for IS_NOT_EQUAL resolved as shift
  ! shift/reduce conflict for IS_SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for IS_GREATER resolved as shift
  ! shift/reduce conflict for IS_SMALLER resolved as shift
    LPAREN          shift and go to state 62
    IS_EQUAL        shift and go to state 102
    IS_GREATER_OR_EQUAL shift and go to state 103
    IS_NOT_EQUAL    shift and go to state 104
    IS_SMALLER_OR_EQUAL shift and go to state 105
    IS_GREATER      shift and go to state 106
    IS_SMALLER      shift and go to state 107

  ! LPAREN          [ reduce using rule 22 (valor -> valor .) ]
  ! IS_EQUAL        [ reduce using rule 22 (valor -> valor .) ]
  ! IS_GREATER_OR_EQUAL [ reduce using rule 22 (valor -> valor .) ]
  ! IS_NOT_EQUAL    [ reduce using rule 22 (valor -> valor .) ]
  ! IS_SMALLER_OR_EQUAL [ reduce using rule 22 (valor -> valor .) ]
  ! IS_GREATER      [ reduce using rule 22 (valor -> valor .) ]
  ! IS_SMALLER      [ reduce using rule 22 (valor -> valor .) ]

    operador_comparacion           shift and go to state 124

state 85

    (97) for -> FOR LPAREN VARIABLE . EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    EQUAL           shift and go to state 125


state 86

    (85) funciones -> valor LPAREN valor . RPAREN LKEY cuerpo RKEY
    (22) valor -> valor .
    (85) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          shift and go to state 126
    LPAREN          shift and go to state 62

  ! RPAREN          [ reduce using rule 22 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 22 (valor -> valor .) ]


state 87

    (24) string -> COMILLA_DOBLE STRING COMILLA_DOBLE .

    ENDLINE         reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    LPAREN          reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    COMA            reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    RBRACKET        reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    RPAREN          reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    BOOLEAN_AND     reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    BOOLEAN_OR      reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    AND             reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    OR              reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    XOR             reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    IS_EQUAL        reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    IS_GREATER_OR_EQUAL reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    IS_NOT_EQUAL    reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    IS_SMALLER_OR_EQUAL reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    IS_GREATER      reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    IS_SMALLER      reduce using rule 24 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)


state 88

    (25) string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .

    ENDLINE         reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    LPAREN          reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    COMA            reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    RBRACKET        reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    RPAREN          reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    BOOLEAN_AND     reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    BOOLEAN_OR      reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    AND             reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    OR              reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    XOR             reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    IS_EQUAL        reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    IS_GREATER_OR_EQUAL reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    IS_NOT_EQUAL    reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    IS_SMALLER_OR_EQUAL reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    IS_GREATER      reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    IS_SMALLER      reduce using rule 25 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)


state 89

    (82) array -> LBRACKET valorArreglo RBRACKET . ENDLINE

    ENDLINE         shift and go to state 127


state 90

    (83) valorArreglo -> valor COMA . valorArreglo
    (83) valorArreglo -> . valor COMA valorArreglo
    (84) valorArreglo -> . valor
    (15) valor -> . ARGUMENTO
    (16) valor -> . number
    (17) valor -> . BOOLEAN
    (18) valor -> . string
    (19) valor -> . VARIABLE
    (20) valor -> . estructuras_datos
    (21) valor -> . funciones
    (22) valor -> . valor
    (66) number -> . INTEGER
    (67) number -> . FLOAT
    (23) string -> . STRING
    (24) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (25) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (39) estructuras_datos -> . array
    (40) estructuras_datos -> . queue
    (85) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (82) array -> . LBRACKET valorArreglo RBRACKET ENDLINE
    (30) queue -> . NEW SPLQUEUE LPAREN RPAREN

    ARGUMENTO       shift and go to state 31
    BOOLEAN         shift and go to state 33
    VARIABLE        shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    COMILLA_DOBLE   shift and go to state 41
    COMILLA_SIMPLE  shift and go to state 42
    LBRACKET        shift and go to state 45
    NEW             shift and go to state 46

    valor                          shift and go to state 66
    valorArreglo                   shift and go to state 128
    number                         shift and go to state 32
    string                         shift and go to state 34
    estructuras_datos              shift and go to state 36
    funciones                      shift and go to state 37
    array                          shift and go to state 43
    queue                          shift and go to state 44

state 91

    (30) queue -> NEW SPLQUEUE LPAREN . RPAREN

    RPAREN          shift and go to state 129


state 92

    (14) salida -> PRINT LPAREN valor RPAREN . ENDLINE

    ENDLINE         shift and go to state 130


state 93

    (27) asignacion -> VARIABLE operador_asignacion valor ENDLINE .

    ECHO            reduce using rule 27 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    PRINT           reduce using rule 27 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    VARIABLE        reduce using rule 27 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    FUNCTION        reduce using rule 27 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    FOPEN           reduce using rule 27 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    FGETS           reduce using rule 27 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    IF              reduce using rule 27 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    WHILE           reduce using rule 27 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    FOR             reduce using rule 27 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    $end            reduce using rule 27 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    RKEY            reduce using rule 27 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)


state 94

    (58) expresiones_logicas -> valor operador . expresiones_logicas
    (57) expresiones_logicas -> . valor
    (58) expresiones_logicas -> . valor operador expresiones_logicas
    (15) valor -> . ARGUMENTO
    (16) valor -> . number
    (17) valor -> . BOOLEAN
    (18) valor -> . string
    (19) valor -> . VARIABLE
    (20) valor -> . estructuras_datos
    (21) valor -> . funciones
    (22) valor -> . valor
    (66) number -> . INTEGER
    (67) number -> . FLOAT
    (23) string -> . STRING
    (24) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (25) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (39) estructuras_datos -> . array
    (40) estructuras_datos -> . queue
    (85) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (82) array -> . LBRACKET valorArreglo RBRACKET ENDLINE
    (30) queue -> . NEW SPLQUEUE LPAREN RPAREN

    ARGUMENTO       shift and go to state 31
    BOOLEAN         shift and go to state 33
    VARIABLE        shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    COMILLA_DOBLE   shift and go to state 41
    COMILLA_SIMPLE  shift and go to state 42
    LBRACKET        shift and go to state 45
    NEW             shift and go to state 46

    valor                          shift and go to state 82
    expresiones_logicas            shift and go to state 131
    number                         shift and go to state 32
    string                         shift and go to state 34
    estructuras_datos              shift and go to state 36
    funciones                      shift and go to state 37
    array                          shift and go to state 43
    queue                          shift and go to state 44

state 95

    (64) operador -> operador_logico .

    ARGUMENTO       reduce using rule 64 (operador -> operador_logico .)
    BOOLEAN         reduce using rule 64 (operador -> operador_logico .)
    VARIABLE        reduce using rule 64 (operador -> operador_logico .)
    INTEGER         reduce using rule 64 (operador -> operador_logico .)
    FLOAT           reduce using rule 64 (operador -> operador_logico .)
    STRING          reduce using rule 64 (operador -> operador_logico .)
    COMILLA_DOBLE   reduce using rule 64 (operador -> operador_logico .)
    COMILLA_SIMPLE  reduce using rule 64 (operador -> operador_logico .)
    LBRACKET        reduce using rule 64 (operador -> operador_logico .)
    NEW             reduce using rule 64 (operador -> operador_logico .)


state 96

    (65) operador -> operador_comparacion .

    ARGUMENTO       reduce using rule 65 (operador -> operador_comparacion .)
    BOOLEAN         reduce using rule 65 (operador -> operador_comparacion .)
    VARIABLE        reduce using rule 65 (operador -> operador_comparacion .)
    INTEGER         reduce using rule 65 (operador -> operador_comparacion .)
    FLOAT           reduce using rule 65 (operador -> operador_comparacion .)
    STRING          reduce using rule 65 (operador -> operador_comparacion .)
    COMILLA_DOBLE   reduce using rule 65 (operador -> operador_comparacion .)
    COMILLA_SIMPLE  reduce using rule 65 (operador -> operador_comparacion .)
    LBRACKET        reduce using rule 65 (operador -> operador_comparacion .)
    NEW             reduce using rule 65 (operador -> operador_comparacion .)


state 97

    (59) operador_logico -> BOOLEAN_AND .

    ARGUMENTO       reduce using rule 59 (operador_logico -> BOOLEAN_AND .)
    BOOLEAN         reduce using rule 59 (operador_logico -> BOOLEAN_AND .)
    VARIABLE        reduce using rule 59 (operador_logico -> BOOLEAN_AND .)
    INTEGER         reduce using rule 59 (operador_logico -> BOOLEAN_AND .)
    FLOAT           reduce using rule 59 (operador_logico -> BOOLEAN_AND .)
    STRING          reduce using rule 59 (operador_logico -> BOOLEAN_AND .)
    COMILLA_DOBLE   reduce using rule 59 (operador_logico -> BOOLEAN_AND .)
    COMILLA_SIMPLE  reduce using rule 59 (operador_logico -> BOOLEAN_AND .)
    LBRACKET        reduce using rule 59 (operador_logico -> BOOLEAN_AND .)
    NEW             reduce using rule 59 (operador_logico -> BOOLEAN_AND .)


state 98

    (60) operador_logico -> BOOLEAN_OR .

    ARGUMENTO       reduce using rule 60 (operador_logico -> BOOLEAN_OR .)
    BOOLEAN         reduce using rule 60 (operador_logico -> BOOLEAN_OR .)
    VARIABLE        reduce using rule 60 (operador_logico -> BOOLEAN_OR .)
    INTEGER         reduce using rule 60 (operador_logico -> BOOLEAN_OR .)
    FLOAT           reduce using rule 60 (operador_logico -> BOOLEAN_OR .)
    STRING          reduce using rule 60 (operador_logico -> BOOLEAN_OR .)
    COMILLA_DOBLE   reduce using rule 60 (operador_logico -> BOOLEAN_OR .)
    COMILLA_SIMPLE  reduce using rule 60 (operador_logico -> BOOLEAN_OR .)
    LBRACKET        reduce using rule 60 (operador_logico -> BOOLEAN_OR .)
    NEW             reduce using rule 60 (operador_logico -> BOOLEAN_OR .)


state 99

    (61) operador_logico -> AND .

    ARGUMENTO       reduce using rule 61 (operador_logico -> AND .)
    BOOLEAN         reduce using rule 61 (operador_logico -> AND .)
    VARIABLE        reduce using rule 61 (operador_logico -> AND .)
    INTEGER         reduce using rule 61 (operador_logico -> AND .)
    FLOAT           reduce using rule 61 (operador_logico -> AND .)
    STRING          reduce using rule 61 (operador_logico -> AND .)
    COMILLA_DOBLE   reduce using rule 61 (operador_logico -> AND .)
    COMILLA_SIMPLE  reduce using rule 61 (operador_logico -> AND .)
    LBRACKET        reduce using rule 61 (operador_logico -> AND .)
    NEW             reduce using rule 61 (operador_logico -> AND .)


state 100

    (62) operador_logico -> OR .

    ARGUMENTO       reduce using rule 62 (operador_logico -> OR .)
    BOOLEAN         reduce using rule 62 (operador_logico -> OR .)
    VARIABLE        reduce using rule 62 (operador_logico -> OR .)
    INTEGER         reduce using rule 62 (operador_logico -> OR .)
    FLOAT           reduce using rule 62 (operador_logico -> OR .)
    STRING          reduce using rule 62 (operador_logico -> OR .)
    COMILLA_DOBLE   reduce using rule 62 (operador_logico -> OR .)
    COMILLA_SIMPLE  reduce using rule 62 (operador_logico -> OR .)
    LBRACKET        reduce using rule 62 (operador_logico -> OR .)
    NEW             reduce using rule 62 (operador_logico -> OR .)


state 101

    (63) operador_logico -> XOR .

    ARGUMENTO       reduce using rule 63 (operador_logico -> XOR .)
    BOOLEAN         reduce using rule 63 (operador_logico -> XOR .)
    VARIABLE        reduce using rule 63 (operador_logico -> XOR .)
    INTEGER         reduce using rule 63 (operador_logico -> XOR .)
    FLOAT           reduce using rule 63 (operador_logico -> XOR .)
    STRING          reduce using rule 63 (operador_logico -> XOR .)
    COMILLA_DOBLE   reduce using rule 63 (operador_logico -> XOR .)
    COMILLA_SIMPLE  reduce using rule 63 (operador_logico -> XOR .)
    LBRACKET        reduce using rule 63 (operador_logico -> XOR .)
    NEW             reduce using rule 63 (operador_logico -> XOR .)


state 102

    (41) operador_comparacion -> IS_EQUAL .

    ARGUMENTO       reduce using rule 41 (operador_comparacion -> IS_EQUAL .)
    BOOLEAN         reduce using rule 41 (operador_comparacion -> IS_EQUAL .)
    VARIABLE        reduce using rule 41 (operador_comparacion -> IS_EQUAL .)
    INTEGER         reduce using rule 41 (operador_comparacion -> IS_EQUAL .)
    FLOAT           reduce using rule 41 (operador_comparacion -> IS_EQUAL .)
    STRING          reduce using rule 41 (operador_comparacion -> IS_EQUAL .)
    COMILLA_DOBLE   reduce using rule 41 (operador_comparacion -> IS_EQUAL .)
    COMILLA_SIMPLE  reduce using rule 41 (operador_comparacion -> IS_EQUAL .)
    LBRACKET        reduce using rule 41 (operador_comparacion -> IS_EQUAL .)
    NEW             reduce using rule 41 (operador_comparacion -> IS_EQUAL .)


state 103

    (42) operador_comparacion -> IS_GREATER_OR_EQUAL .

    ARGUMENTO       reduce using rule 42 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    BOOLEAN         reduce using rule 42 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    VARIABLE        reduce using rule 42 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 42 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    FLOAT           reduce using rule 42 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    STRING          reduce using rule 42 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    COMILLA_DOBLE   reduce using rule 42 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    COMILLA_SIMPLE  reduce using rule 42 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    LBRACKET        reduce using rule 42 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    NEW             reduce using rule 42 (operador_comparacion -> IS_GREATER_OR_EQUAL .)


state 104

    (43) operador_comparacion -> IS_NOT_EQUAL .

    ARGUMENTO       reduce using rule 43 (operador_comparacion -> IS_NOT_EQUAL .)
    BOOLEAN         reduce using rule 43 (operador_comparacion -> IS_NOT_EQUAL .)
    VARIABLE        reduce using rule 43 (operador_comparacion -> IS_NOT_EQUAL .)
    INTEGER         reduce using rule 43 (operador_comparacion -> IS_NOT_EQUAL .)
    FLOAT           reduce using rule 43 (operador_comparacion -> IS_NOT_EQUAL .)
    STRING          reduce using rule 43 (operador_comparacion -> IS_NOT_EQUAL .)
    COMILLA_DOBLE   reduce using rule 43 (operador_comparacion -> IS_NOT_EQUAL .)
    COMILLA_SIMPLE  reduce using rule 43 (operador_comparacion -> IS_NOT_EQUAL .)
    LBRACKET        reduce using rule 43 (operador_comparacion -> IS_NOT_EQUAL .)
    NEW             reduce using rule 43 (operador_comparacion -> IS_NOT_EQUAL .)


state 105

    (44) operador_comparacion -> IS_SMALLER_OR_EQUAL .

    ARGUMENTO       reduce using rule 44 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    BOOLEAN         reduce using rule 44 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    VARIABLE        reduce using rule 44 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 44 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    FLOAT           reduce using rule 44 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    STRING          reduce using rule 44 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    COMILLA_DOBLE   reduce using rule 44 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    COMILLA_SIMPLE  reduce using rule 44 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    LBRACKET        reduce using rule 44 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    NEW             reduce using rule 44 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)


state 106

    (45) operador_comparacion -> IS_GREATER .

    ARGUMENTO       reduce using rule 45 (operador_comparacion -> IS_GREATER .)
    BOOLEAN         reduce using rule 45 (operador_comparacion -> IS_GREATER .)
    VARIABLE        reduce using rule 45 (operador_comparacion -> IS_GREATER .)
    INTEGER         reduce using rule 45 (operador_comparacion -> IS_GREATER .)
    FLOAT           reduce using rule 45 (operador_comparacion -> IS_GREATER .)
    STRING          reduce using rule 45 (operador_comparacion -> IS_GREATER .)
    COMILLA_DOBLE   reduce using rule 45 (operador_comparacion -> IS_GREATER .)
    COMILLA_SIMPLE  reduce using rule 45 (operador_comparacion -> IS_GREATER .)
    LBRACKET        reduce using rule 45 (operador_comparacion -> IS_GREATER .)
    NEW             reduce using rule 45 (operador_comparacion -> IS_GREATER .)


state 107

    (46) operador_comparacion -> IS_SMALLER .

    ARGUMENTO       reduce using rule 46 (operador_comparacion -> IS_SMALLER .)
    BOOLEAN         reduce using rule 46 (operador_comparacion -> IS_SMALLER .)
    VARIABLE        reduce using rule 46 (operador_comparacion -> IS_SMALLER .)
    INTEGER         reduce using rule 46 (operador_comparacion -> IS_SMALLER .)
    FLOAT           reduce using rule 46 (operador_comparacion -> IS_SMALLER .)
    STRING          reduce using rule 46 (operador_comparacion -> IS_SMALLER .)
    COMILLA_DOBLE   reduce using rule 46 (operador_comparacion -> IS_SMALLER .)
    COMILLA_SIMPLE  reduce using rule 46 (operador_comparacion -> IS_SMALLER .)
    LBRACKET        reduce using rule 46 (operador_comparacion -> IS_SMALLER .)
    NEW             reduce using rule 46 (operador_comparacion -> IS_SMALLER .)


state 108

    (28) asignacion -> VARIABLE operador_asignacion expresion ENDLINE .

    ECHO            reduce using rule 28 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    PRINT           reduce using rule 28 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    VARIABLE        reduce using rule 28 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    FUNCTION        reduce using rule 28 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    FOPEN           reduce using rule 28 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    FGETS           reduce using rule 28 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    IF              reduce using rule 28 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    WHILE           reduce using rule 28 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    FOR             reduce using rule 28 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    $end            reduce using rule 28 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    RKEY            reduce using rule 28 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)


state 109

    (75) expresion_aritmetica -> number operador_aritmetico . expresion_aritmetica
    (74) expresion_aritmetica -> . number
    (75) expresion_aritmetica -> . number operador_aritmetico expresion_aritmetica
    (66) number -> . INTEGER
    (67) number -> . FLOAT

    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39

    number                         shift and go to state 132
    expresion_aritmetica           shift and go to state 133

state 110

    (68) operador_aritmetico -> ADDITION .

    INTEGER         reduce using rule 68 (operador_aritmetico -> ADDITION .)
    FLOAT           reduce using rule 68 (operador_aritmetico -> ADDITION .)


state 111

    (69) operador_aritmetico -> SUBTRACTION .

    INTEGER         reduce using rule 69 (operador_aritmetico -> SUBTRACTION .)
    FLOAT           reduce using rule 69 (operador_aritmetico -> SUBTRACTION .)


state 112

    (70) operador_aritmetico -> MULTIPLICATION .

    INTEGER         reduce using rule 70 (operador_aritmetico -> MULTIPLICATION .)
    FLOAT           reduce using rule 70 (operador_aritmetico -> MULTIPLICATION .)


state 113

    (71) operador_aritmetico -> DIVISION .

    INTEGER         reduce using rule 71 (operador_aritmetico -> DIVISION .)
    FLOAT           reduce using rule 71 (operador_aritmetico -> DIVISION .)


state 114

    (72) operador_aritmetico -> MODULO .

    INTEGER         reduce using rule 72 (operador_aritmetico -> MODULO .)
    FLOAT           reduce using rule 72 (operador_aritmetico -> MODULO .)


state 115

    (73) operador_aritmetico -> EXPONENTIATION .

    INTEGER         reduce using rule 73 (operador_aritmetico -> EXPONENTIATION .)
    FLOAT           reduce using rule 73 (operador_aritmetico -> EXPONENTIATION .)


state 116

    (29) asignacion -> queue_variable operador_asignacion queue ENDLINE .

    ECHO            reduce using rule 29 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    PRINT           reduce using rule 29 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    VARIABLE        reduce using rule 29 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    FUNCTION        reduce using rule 29 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    FOPEN           reduce using rule 29 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    FGETS           reduce using rule 29 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    IF              reduce using rule 29 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    WHILE           reduce using rule 29 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    FOR             reduce using rule 29 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    $end            reduce using rule 29 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    RKEY            reduce using rule 29 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)


state 117

    (32) push -> queue_variable ARROW PUSH LPAREN . valor RPAREN ENDLINE
    (15) valor -> . ARGUMENTO
    (16) valor -> . number
    (17) valor -> . BOOLEAN
    (18) valor -> . string
    (19) valor -> . VARIABLE
    (20) valor -> . estructuras_datos
    (21) valor -> . funciones
    (22) valor -> . valor
    (66) number -> . INTEGER
    (67) number -> . FLOAT
    (23) string -> . STRING
    (24) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (25) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (39) estructuras_datos -> . array
    (40) estructuras_datos -> . queue
    (85) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (82) array -> . LBRACKET valorArreglo RBRACKET ENDLINE
    (30) queue -> . NEW SPLQUEUE LPAREN RPAREN

    ARGUMENTO       shift and go to state 31
    BOOLEAN         shift and go to state 33
    VARIABLE        shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    COMILLA_DOBLE   shift and go to state 41
    COMILLA_SIMPLE  shift and go to state 42
    LBRACKET        shift and go to state 45
    NEW             shift and go to state 46

    valor                          shift and go to state 134
    number                         shift and go to state 32
    string                         shift and go to state 34
    estructuras_datos              shift and go to state 36
    funciones                      shift and go to state 37
    array                          shift and go to state 43
    queue                          shift and go to state 44

state 118

    (33) pop -> queue_variable ARROW POP LPAREN . RPAREN ENDLINE

    RPAREN          shift and go to state 135


state 119

    (26) function -> FUNCTION ARGUMENTO LPAREN VARIABLE . RPAREN LKEY ARGUMENTO RKEY

    RPAREN          shift and go to state 136


state 120

    (54) else -> if ELSE LKEY cuerpo . RKEY

    RKEY            shift and go to state 137


state 121

    (76) abrir_archivo -> FOPEN LPAREN string RPAREN .
    (77) abrir_archivo -> FOPEN LPAREN string RPAREN . ENDLINE

    $end            reduce using rule 76 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    RKEY            reduce using rule 76 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    ECHO            reduce using rule 76 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    PRINT           reduce using rule 76 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    VARIABLE        reduce using rule 76 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    FUNCTION        reduce using rule 76 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    FOPEN           reduce using rule 76 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    FGETS           reduce using rule 76 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    IF              reduce using rule 76 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    WHILE           reduce using rule 76 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    FOR             reduce using rule 76 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    RPAREN          reduce using rule 76 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    ENDLINE         shift and go to state 138


state 122

    (78) lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN . ENDLINE

    ENDLINE         shift and go to state 139


state 123

    (53) if -> IF LPAREN expresion RPAREN . LKEY cuerpo RKEY

    LKEY            shift and go to state 140


state 124

    (80) while -> WHILE LPAREN valor operador_comparacion . valor RPAREN COLON cuerpo
    (81) while -> WHILE LPAREN valor operador_comparacion . valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (15) valor -> . ARGUMENTO
    (16) valor -> . number
    (17) valor -> . BOOLEAN
    (18) valor -> . string
    (19) valor -> . VARIABLE
    (20) valor -> . estructuras_datos
    (21) valor -> . funciones
    (22) valor -> . valor
    (66) number -> . INTEGER
    (67) number -> . FLOAT
    (23) string -> . STRING
    (24) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (25) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (39) estructuras_datos -> . array
    (40) estructuras_datos -> . queue
    (85) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (82) array -> . LBRACKET valorArreglo RBRACKET ENDLINE
    (30) queue -> . NEW SPLQUEUE LPAREN RPAREN

    ARGUMENTO       shift and go to state 31
    BOOLEAN         shift and go to state 33
    VARIABLE        shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    COMILLA_DOBLE   shift and go to state 41
    COMILLA_SIMPLE  shift and go to state 42
    LBRACKET        shift and go to state 45
    NEW             shift and go to state 46

    valor                          shift and go to state 141
    number                         shift and go to state 32
    string                         shift and go to state 34
    estructuras_datos              shift and go to state 36
    funciones                      shift and go to state 37
    array                          shift and go to state 43
    queue                          shift and go to state 44

state 125

    (97) for -> FOR LPAREN VARIABLE EQUAL . INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    INTEGER         shift and go to state 142


state 126

    (85) funciones -> valor LPAREN valor RPAREN . LKEY cuerpo RKEY

    LKEY            shift and go to state 143


state 127

    (82) array -> LBRACKET valorArreglo RBRACKET ENDLINE .

    ENDLINE         reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    LPAREN          reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    COMA            reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    RBRACKET        reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    RPAREN          reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    BOOLEAN_AND     reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    BOOLEAN_OR      reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    AND             reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    OR              reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    XOR             reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    IS_EQUAL        reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    IS_GREATER_OR_EQUAL reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    IS_NOT_EQUAL    reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    IS_SMALLER_OR_EQUAL reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    IS_GREATER      reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)
    IS_SMALLER      reduce using rule 82 (array -> LBRACKET valorArreglo RBRACKET ENDLINE .)


state 128

    (83) valorArreglo -> valor COMA valorArreglo .

    RBRACKET        reduce using rule 83 (valorArreglo -> valor COMA valorArreglo .)


state 129

    (30) queue -> NEW SPLQUEUE LPAREN RPAREN .

    ENDLINE         reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    LPAREN          reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    COMA            reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    RBRACKET        reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    RPAREN          reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    BOOLEAN_AND     reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    BOOLEAN_OR      reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    AND             reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    OR              reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    XOR             reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IS_EQUAL        reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IS_GREATER_OR_EQUAL reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IS_NOT_EQUAL    reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IS_SMALLER_OR_EQUAL reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IS_GREATER      reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IS_SMALLER      reduce using rule 30 (queue -> NEW SPLQUEUE LPAREN RPAREN .)


state 130

    (14) salida -> PRINT LPAREN valor RPAREN ENDLINE .

    ECHO            reduce using rule 14 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    PRINT           reduce using rule 14 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    VARIABLE        reduce using rule 14 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    FUNCTION        reduce using rule 14 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    FOPEN           reduce using rule 14 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    FGETS           reduce using rule 14 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    IF              reduce using rule 14 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    WHILE           reduce using rule 14 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    FOR             reduce using rule 14 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    $end            reduce using rule 14 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    RKEY            reduce using rule 14 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)


state 131

    (58) expresiones_logicas -> valor operador expresiones_logicas .

    ENDLINE         reduce using rule 58 (expresiones_logicas -> valor operador expresiones_logicas .)
    RPAREN          reduce using rule 58 (expresiones_logicas -> valor operador expresiones_logicas .)


state 132

    (74) expresion_aritmetica -> number .
    (75) expresion_aritmetica -> number . operador_aritmetico expresion_aritmetica
    (68) operador_aritmetico -> . ADDITION
    (69) operador_aritmetico -> . SUBTRACTION
    (70) operador_aritmetico -> . MULTIPLICATION
    (71) operador_aritmetico -> . DIVISION
    (72) operador_aritmetico -> . MODULO
    (73) operador_aritmetico -> . EXPONENTIATION

    ENDLINE         reduce using rule 74 (expresion_aritmetica -> number .)
    RPAREN          reduce using rule 74 (expresion_aritmetica -> number .)
    ADDITION        shift and go to state 110
    SUBTRACTION     shift and go to state 111
    MULTIPLICATION  shift and go to state 112
    DIVISION        shift and go to state 113
    MODULO          shift and go to state 114
    EXPONENTIATION  shift and go to state 115

    operador_aritmetico            shift and go to state 109

state 133

    (75) expresion_aritmetica -> number operador_aritmetico expresion_aritmetica .

    ENDLINE         reduce using rule 75 (expresion_aritmetica -> number operador_aritmetico expresion_aritmetica .)
    RPAREN          reduce using rule 75 (expresion_aritmetica -> number operador_aritmetico expresion_aritmetica .)


state 134

    (32) push -> queue_variable ARROW PUSH LPAREN valor . RPAREN ENDLINE
    (22) valor -> valor .
    (85) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          shift and go to state 144
    LPAREN          shift and go to state 62

  ! RPAREN          [ reduce using rule 22 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 22 (valor -> valor .) ]


state 135

    (33) pop -> queue_variable ARROW POP LPAREN RPAREN . ENDLINE

    ENDLINE         shift and go to state 145


state 136

    (26) function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN . LKEY ARGUMENTO RKEY

    LKEY            shift and go to state 146


state 137

    (54) else -> if ELSE LKEY cuerpo RKEY .

    ECHO            reduce using rule 54 (else -> if ELSE LKEY cuerpo RKEY .)
    PRINT           reduce using rule 54 (else -> if ELSE LKEY cuerpo RKEY .)
    VARIABLE        reduce using rule 54 (else -> if ELSE LKEY cuerpo RKEY .)
    FUNCTION        reduce using rule 54 (else -> if ELSE LKEY cuerpo RKEY .)
    FOPEN           reduce using rule 54 (else -> if ELSE LKEY cuerpo RKEY .)
    FGETS           reduce using rule 54 (else -> if ELSE LKEY cuerpo RKEY .)
    IF              reduce using rule 54 (else -> if ELSE LKEY cuerpo RKEY .)
    WHILE           reduce using rule 54 (else -> if ELSE LKEY cuerpo RKEY .)
    FOR             reduce using rule 54 (else -> if ELSE LKEY cuerpo RKEY .)
    $end            reduce using rule 54 (else -> if ELSE LKEY cuerpo RKEY .)
    RKEY            reduce using rule 54 (else -> if ELSE LKEY cuerpo RKEY .)


state 138

    (77) abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .

    $end            reduce using rule 77 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    RKEY            reduce using rule 77 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    ECHO            reduce using rule 77 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    PRINT           reduce using rule 77 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    VARIABLE        reduce using rule 77 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    FUNCTION        reduce using rule 77 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    FOPEN           reduce using rule 77 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    FGETS           reduce using rule 77 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    IF              reduce using rule 77 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    WHILE           reduce using rule 77 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    FOR             reduce using rule 77 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    RPAREN          reduce using rule 77 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)


state 139

    (78) lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE .

    $end            reduce using rule 78 (lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE .)
    RKEY            reduce using rule 78 (lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE .)
    ECHO            reduce using rule 78 (lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE .)
    PRINT           reduce using rule 78 (lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE .)
    VARIABLE        reduce using rule 78 (lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE .)
    FUNCTION        reduce using rule 78 (lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE .)
    FOPEN           reduce using rule 78 (lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE .)
    FGETS           reduce using rule 78 (lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE .)
    IF              reduce using rule 78 (lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE .)
    WHILE           reduce using rule 78 (lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE .)
    FOR             reduce using rule 78 (lectura_archivo -> FGETS LPAREN abrir_archivo RPAREN ENDLINE .)


state 140

    (53) if -> IF LPAREN expresion RPAREN LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . metodos
    (10) cuerpo -> . metodos cuerpo
    (11) cuerpo -> . abrir_archivo
    (12) cuerpo -> . lectura_archivo
    (13) salida -> . ECHO valor ENDLINE
    (14) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (27) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (29) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (26) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (48) estructuras_control -> . if
    (49) estructuras_control -> . else
    (50) estructuras_control -> . while
    (51) estructuras_control -> . for
    (52) estructuras_control -> . estructuras_control
    (34) metodos -> . push
    (35) metodos -> . pop
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (78) lectura_archivo -> . FGETS LPAREN abrir_archivo RPAREN ENDLINE
    (31) queue_variable -> . VARIABLE
    (53) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (54) else -> . if ELSE LKEY cuerpo RKEY
    (80) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (97) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (32) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    VARIABLE        shift and go to state 11
    FUNCTION        shift and go to state 13
    FOPEN           shift and go to state 20
    FGETS           shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24

    cuerpo                         shift and go to state 147
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    metodos                        shift and go to state 6
    abrir_archivo                  shift and go to state 7
    lectura_archivo                shift and go to state 8
    queue_variable                 shift and go to state 12
    if                             shift and go to state 14
    else                           shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    push                           shift and go to state 18
    pop                            shift and go to state 19

state 141

    (80) while -> WHILE LPAREN valor operador_comparacion valor . RPAREN COLON cuerpo
    (81) while -> WHILE LPAREN valor operador_comparacion valor . RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (22) valor -> valor .
    (85) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          shift and go to state 148
    LPAREN          shift and go to state 62

  ! RPAREN          [ reduce using rule 22 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 22 (valor -> valor .) ]


state 142

    (97) for -> FOR LPAREN VARIABLE EQUAL INTEGER . ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ENDLINE         shift and go to state 149


state 143

    (85) funciones -> valor LPAREN valor RPAREN LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . metodos
    (10) cuerpo -> . metodos cuerpo
    (11) cuerpo -> . abrir_archivo
    (12) cuerpo -> . lectura_archivo
    (13) salida -> . ECHO valor ENDLINE
    (14) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (27) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (29) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (26) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (48) estructuras_control -> . if
    (49) estructuras_control -> . else
    (50) estructuras_control -> . while
    (51) estructuras_control -> . for
    (52) estructuras_control -> . estructuras_control
    (34) metodos -> . push
    (35) metodos -> . pop
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (78) lectura_archivo -> . FGETS LPAREN abrir_archivo RPAREN ENDLINE
    (31) queue_variable -> . VARIABLE
    (53) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (54) else -> . if ELSE LKEY cuerpo RKEY
    (80) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (97) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (32) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    VARIABLE        shift and go to state 11
    FUNCTION        shift and go to state 13
    FOPEN           shift and go to state 20
    FGETS           shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24

    cuerpo                         shift and go to state 150
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    metodos                        shift and go to state 6
    abrir_archivo                  shift and go to state 7
    lectura_archivo                shift and go to state 8
    queue_variable                 shift and go to state 12
    if                             shift and go to state 14
    else                           shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    push                           shift and go to state 18
    pop                            shift and go to state 19

state 144

    (32) push -> queue_variable ARROW PUSH LPAREN valor RPAREN . ENDLINE

    ENDLINE         shift and go to state 151


state 145

    (33) pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .

    ECHO            reduce using rule 33 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    PRINT           reduce using rule 33 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    VARIABLE        reduce using rule 33 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    FUNCTION        reduce using rule 33 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    FOPEN           reduce using rule 33 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    FGETS           reduce using rule 33 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    IF              reduce using rule 33 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    WHILE           reduce using rule 33 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    FOR             reduce using rule 33 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    $end            reduce using rule 33 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    RKEY            reduce using rule 33 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)


state 146

    (26) function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY . ARGUMENTO RKEY

    ARGUMENTO       shift and go to state 152


state 147

    (53) if -> IF LPAREN expresion RPAREN LKEY cuerpo . RKEY

    RKEY            shift and go to state 153


state 148

    (80) while -> WHILE LPAREN valor operador_comparacion valor RPAREN . COLON cuerpo
    (81) while -> WHILE LPAREN valor operador_comparacion valor RPAREN . LKEY TAB_VERTICAL cuerpo RKEY

    COLON           shift and go to state 154
    LKEY            shift and go to state 155


state 149

    (97) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE . VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    VARIABLE        shift and go to state 156


state 150

    (85) funciones -> valor LPAREN valor RPAREN LKEY cuerpo . RKEY

    RKEY            shift and go to state 157


state 151

    (32) push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .

    ECHO            reduce using rule 32 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    PRINT           reduce using rule 32 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    VARIABLE        reduce using rule 32 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    FUNCTION        reduce using rule 32 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    FOPEN           reduce using rule 32 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    FGETS           reduce using rule 32 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    IF              reduce using rule 32 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    WHILE           reduce using rule 32 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    FOR             reduce using rule 32 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    $end            reduce using rule 32 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    RKEY            reduce using rule 32 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)


state 152

    (26) function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO . RKEY

    RKEY            shift and go to state 158


state 153

    (53) if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .

    ELSE            reduce using rule 53 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    ECHO            reduce using rule 53 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    PRINT           reduce using rule 53 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    VARIABLE        reduce using rule 53 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    FUNCTION        reduce using rule 53 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    FOPEN           reduce using rule 53 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    FGETS           reduce using rule 53 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    IF              reduce using rule 53 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    WHILE           reduce using rule 53 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    FOR             reduce using rule 53 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    $end            reduce using rule 53 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    RKEY            reduce using rule 53 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)


state 154

    (80) while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . metodos
    (10) cuerpo -> . metodos cuerpo
    (11) cuerpo -> . abrir_archivo
    (12) cuerpo -> . lectura_archivo
    (13) salida -> . ECHO valor ENDLINE
    (14) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (27) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (29) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (26) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (48) estructuras_control -> . if
    (49) estructuras_control -> . else
    (50) estructuras_control -> . while
    (51) estructuras_control -> . for
    (52) estructuras_control -> . estructuras_control
    (34) metodos -> . push
    (35) metodos -> . pop
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (78) lectura_archivo -> . FGETS LPAREN abrir_archivo RPAREN ENDLINE
    (31) queue_variable -> . VARIABLE
    (53) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (54) else -> . if ELSE LKEY cuerpo RKEY
    (80) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (97) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (32) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    VARIABLE        shift and go to state 11
    FUNCTION        shift and go to state 13
    FOPEN           shift and go to state 20
    FGETS           shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24

    cuerpo                         shift and go to state 159
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    metodos                        shift and go to state 6
    abrir_archivo                  shift and go to state 7
    lectura_archivo                shift and go to state 8
    queue_variable                 shift and go to state 12
    if                             shift and go to state 14
    else                           shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    push                           shift and go to state 18
    pop                            shift and go to state 19

state 155

    (81) while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY . TAB_VERTICAL cuerpo RKEY

    TAB_VERTICAL    shift and go to state 160


state 156

    (97) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE . operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (41) operador_comparacion -> . IS_EQUAL
    (42) operador_comparacion -> . IS_GREATER_OR_EQUAL
    (43) operador_comparacion -> . IS_NOT_EQUAL
    (44) operador_comparacion -> . IS_SMALLER_OR_EQUAL
    (45) operador_comparacion -> . IS_GREATER
    (46) operador_comparacion -> . IS_SMALLER

    IS_EQUAL        shift and go to state 102
    IS_GREATER_OR_EQUAL shift and go to state 103
    IS_NOT_EQUAL    shift and go to state 104
    IS_SMALLER_OR_EQUAL shift and go to state 105
    IS_GREATER      shift and go to state 106
    IS_SMALLER      shift and go to state 107

    operador_comparacion           shift and go to state 161

state 157

    (85) funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .

    ENDLINE         reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    LPAREN          reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    COMA            reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    RBRACKET        reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    RPAREN          reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    BOOLEAN_AND     reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    BOOLEAN_OR      reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    AND             reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    OR              reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    XOR             reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_EQUAL        reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_GREATER_OR_EQUAL reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_NOT_EQUAL    reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_SMALLER_OR_EQUAL reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_GREATER      reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_SMALLER      reduce using rule 85 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)


state 158

    (26) function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .

    ECHO            reduce using rule 26 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    PRINT           reduce using rule 26 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    VARIABLE        reduce using rule 26 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    FUNCTION        reduce using rule 26 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    FOPEN           reduce using rule 26 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    FGETS           reduce using rule 26 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    IF              reduce using rule 26 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    WHILE           reduce using rule 26 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    FOR             reduce using rule 26 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    $end            reduce using rule 26 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    RKEY            reduce using rule 26 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)


state 159

    (80) while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .

    ECHO            reduce using rule 80 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    PRINT           reduce using rule 80 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    VARIABLE        reduce using rule 80 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    FUNCTION        reduce using rule 80 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    FOPEN           reduce using rule 80 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    FGETS           reduce using rule 80 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    IF              reduce using rule 80 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    WHILE           reduce using rule 80 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    FOR             reduce using rule 80 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    $end            reduce using rule 80 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    RKEY            reduce using rule 80 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)


state 160

    (81) while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . metodos
    (10) cuerpo -> . metodos cuerpo
    (11) cuerpo -> . abrir_archivo
    (12) cuerpo -> . lectura_archivo
    (13) salida -> . ECHO valor ENDLINE
    (14) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (27) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (29) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (26) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (48) estructuras_control -> . if
    (49) estructuras_control -> . else
    (50) estructuras_control -> . while
    (51) estructuras_control -> . for
    (52) estructuras_control -> . estructuras_control
    (34) metodos -> . push
    (35) metodos -> . pop
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (78) lectura_archivo -> . FGETS LPAREN abrir_archivo RPAREN ENDLINE
    (31) queue_variable -> . VARIABLE
    (53) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (54) else -> . if ELSE LKEY cuerpo RKEY
    (80) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (97) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (32) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    VARIABLE        shift and go to state 11
    FUNCTION        shift and go to state 13
    FOPEN           shift and go to state 20
    FGETS           shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24

    cuerpo                         shift and go to state 162
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    metodos                        shift and go to state 6
    abrir_archivo                  shift and go to state 7
    lectura_archivo                shift and go to state 8
    queue_variable                 shift and go to state 12
    if                             shift and go to state 14
    else                           shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    push                           shift and go to state 18
    pop                            shift and go to state 19

state 161

    (97) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion . INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    INTEGER         shift and go to state 163


state 162

    (81) while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo . RKEY

    RKEY            shift and go to state 164


state 163

    (97) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER . ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ENDLINE         shift and go to state 165


state 164

    (81) while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .

    ECHO            reduce using rule 81 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    PRINT           reduce using rule 81 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    VARIABLE        reduce using rule 81 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    FUNCTION        reduce using rule 81 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    FOPEN           reduce using rule 81 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    FGETS           reduce using rule 81 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    IF              reduce using rule 81 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    WHILE           reduce using rule 81 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    FOR             reduce using rule 81 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    $end            reduce using rule 81 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    RKEY            reduce using rule 81 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)


state 165

    (97) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE . forma_operacion RPAREN LKEY cuerpo RKEY
    (92) forma_operacion -> . VARIABLE OPERADOR_INCREMENTO
    (93) forma_operacion -> . OPERADOR_INCREMENTO VARIABLE
    (94) forma_operacion -> . VARIABLE OPERADOR_DECREMENTO
    (95) forma_operacion -> . OPERADOR_DECREMENTO VARIABLE
    (96) forma_operacion -> . VARIABLE EQUAL VARIABLE tipo_operador INTEGER

    VARIABLE        shift and go to state 166
    OPERADOR_INCREMENTO shift and go to state 168
    OPERADOR_DECREMENTO shift and go to state 169

    forma_operacion                shift and go to state 167

state 166

    (92) forma_operacion -> VARIABLE . OPERADOR_INCREMENTO
    (94) forma_operacion -> VARIABLE . OPERADOR_DECREMENTO
    (96) forma_operacion -> VARIABLE . EQUAL VARIABLE tipo_operador INTEGER

    OPERADOR_INCREMENTO shift and go to state 170
    OPERADOR_DECREMENTO shift and go to state 171
    EQUAL           shift and go to state 172


state 167

    (97) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion . RPAREN LKEY cuerpo RKEY

    RPAREN          shift and go to state 173


state 168

    (93) forma_operacion -> OPERADOR_INCREMENTO . VARIABLE

    VARIABLE        shift and go to state 174


state 169

    (95) forma_operacion -> OPERADOR_DECREMENTO . VARIABLE

    VARIABLE        shift and go to state 175


state 170

    (92) forma_operacion -> VARIABLE OPERADOR_INCREMENTO .

    RPAREN          reduce using rule 92 (forma_operacion -> VARIABLE OPERADOR_INCREMENTO .)


state 171

    (94) forma_operacion -> VARIABLE OPERADOR_DECREMENTO .

    RPAREN          reduce using rule 94 (forma_operacion -> VARIABLE OPERADOR_DECREMENTO .)


state 172

    (96) forma_operacion -> VARIABLE EQUAL . VARIABLE tipo_operador INTEGER

    VARIABLE        shift and go to state 176


state 173

    (97) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN . LKEY cuerpo RKEY

    LKEY            shift and go to state 177


state 174

    (93) forma_operacion -> OPERADOR_INCREMENTO VARIABLE .

    RPAREN          reduce using rule 93 (forma_operacion -> OPERADOR_INCREMENTO VARIABLE .)


state 175

    (95) forma_operacion -> OPERADOR_DECREMENTO VARIABLE .

    RPAREN          reduce using rule 95 (forma_operacion -> OPERADOR_DECREMENTO VARIABLE .)


state 176

    (96) forma_operacion -> VARIABLE EQUAL VARIABLE . tipo_operador INTEGER
    (86) tipo_operador -> . ADDITION
    (87) tipo_operador -> . SUBTRACTION
    (88) tipo_operador -> . MULTIPLICATION
    (89) tipo_operador -> . DIVISION
    (90) tipo_operador -> . MODULO
    (91) tipo_operador -> . EXPONENTIATION

    ADDITION        shift and go to state 179
    SUBTRACTION     shift and go to state 180
    MULTIPLICATION  shift and go to state 181
    DIVISION        shift and go to state 182
    MODULO          shift and go to state 183
    EXPONENTIATION  shift and go to state 184

    tipo_operador                  shift and go to state 178

state 177

    (97) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . metodos
    (10) cuerpo -> . metodos cuerpo
    (11) cuerpo -> . abrir_archivo
    (12) cuerpo -> . lectura_archivo
    (13) salida -> . ECHO valor ENDLINE
    (14) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (27) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (29) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (26) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (48) estructuras_control -> . if
    (49) estructuras_control -> . else
    (50) estructuras_control -> . while
    (51) estructuras_control -> . for
    (52) estructuras_control -> . estructuras_control
    (34) metodos -> . push
    (35) metodos -> . pop
    (76) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (77) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (78) lectura_archivo -> . FGETS LPAREN abrir_archivo RPAREN ENDLINE
    (31) queue_variable -> . VARIABLE
    (53) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (54) else -> . if ELSE LKEY cuerpo RKEY
    (80) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (81) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (97) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (32) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (33) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    VARIABLE        shift and go to state 11
    FUNCTION        shift and go to state 13
    FOPEN           shift and go to state 20
    FGETS           shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24

    cuerpo                         shift and go to state 185
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    metodos                        shift and go to state 6
    abrir_archivo                  shift and go to state 7
    lectura_archivo                shift and go to state 8
    queue_variable                 shift and go to state 12
    if                             shift and go to state 14
    else                           shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    push                           shift and go to state 18
    pop                            shift and go to state 19

state 178

    (96) forma_operacion -> VARIABLE EQUAL VARIABLE tipo_operador . INTEGER

    INTEGER         shift and go to state 186


state 179

    (86) tipo_operador -> ADDITION .

    INTEGER         reduce using rule 86 (tipo_operador -> ADDITION .)


state 180

    (87) tipo_operador -> SUBTRACTION .

    INTEGER         reduce using rule 87 (tipo_operador -> SUBTRACTION .)


state 181

    (88) tipo_operador -> MULTIPLICATION .

    INTEGER         reduce using rule 88 (tipo_operador -> MULTIPLICATION .)


state 182

    (89) tipo_operador -> DIVISION .

    INTEGER         reduce using rule 89 (tipo_operador -> DIVISION .)


state 183

    (90) tipo_operador -> MODULO .

    INTEGER         reduce using rule 90 (tipo_operador -> MODULO .)


state 184

    (91) tipo_operador -> EXPONENTIATION .

    INTEGER         reduce using rule 91 (tipo_operador -> EXPONENTIATION .)


state 185

    (97) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo . RKEY

    RKEY            shift and go to state 187


state 186

    (96) forma_operacion -> VARIABLE EQUAL VARIABLE tipo_operador INTEGER .

    RPAREN          reduce using rule 96 (forma_operacion -> VARIABLE EQUAL VARIABLE tipo_operador INTEGER .)


state 187

    (97) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .

    ECHO            reduce using rule 97 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    PRINT           reduce using rule 97 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    VARIABLE        reduce using rule 97 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    FUNCTION        reduce using rule 97 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    FOPEN           reduce using rule 97 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    FGETS           reduce using rule 97 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    IF              reduce using rule 97 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    WHILE           reduce using rule 97 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    FOR             reduce using rule 97 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    $end            reduce using rule 97 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    RKEY            reduce using rule 97 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ECHO in state 2 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 2 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 2 resolved as shift
WARNING: shift/reduce conflict for FOPEN in state 2 resolved as shift
WARNING: shift/reduce conflict for FGETS in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 3 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 3 resolved as shift
WARNING: shift/reduce conflict for FOPEN in state 3 resolved as shift
WARNING: shift/reduce conflict for FGETS in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 4 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 4 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 4 resolved as shift
WARNING: shift/reduce conflict for FOPEN in state 4 resolved as shift
WARNING: shift/reduce conflict for FGETS in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 5 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 5 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 5 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 5 resolved as shift
WARNING: shift/reduce conflict for FOPEN in state 5 resolved as shift
WARNING: shift/reduce conflict for FGETS in state 5 resolved as shift
WARNING: shift/reduce conflict for IF in state 5 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 5 resolved as shift
WARNING: shift/reduce conflict for FOR in state 5 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 6 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 6 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 6 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 6 resolved as shift
WARNING: shift/reduce conflict for FOPEN in state 6 resolved as shift
WARNING: shift/reduce conflict for FGETS in state 6 resolved as shift
WARNING: shift/reduce conflict for IF in state 6 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 6 resolved as shift
WARNING: shift/reduce conflict for FOR in state 6 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 11 resolved as shift
WARNING: shift/reduce conflict for PLUS_EQUAL in state 11 resolved as shift
WARNING: shift/reduce conflict for CONCAT_EQUAL in state 11 resolved as shift
WARNING: shift/reduce conflict for ENDLINE in state 30 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 30 resolved as shift
WARNING: shift/reduce conflict for COMA in state 66 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 66 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 68 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 68 resolved as shift
WARNING: shift/reduce conflict for ENDLINE in state 69 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 69 resolved as shift
WARNING: shift/reduce conflict for ENDLINE in state 69 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_AND in state 69 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_OR in state 69 resolved as shift
WARNING: shift/reduce conflict for AND in state 69 resolved as shift
WARNING: shift/reduce conflict for OR in state 69 resolved as shift
WARNING: shift/reduce conflict for XOR in state 69 resolved as shift
WARNING: shift/reduce conflict for IS_EQUAL in state 69 resolved as shift
WARNING: shift/reduce conflict for IS_GREATER_OR_EQUAL in state 69 resolved as shift
WARNING: shift/reduce conflict for IS_NOT_EQUAL in state 69 resolved as shift
WARNING: shift/reduce conflict for IS_SMALLER_OR_EQUAL in state 69 resolved as shift
WARNING: shift/reduce conflict for IS_GREATER in state 69 resolved as shift
WARNING: shift/reduce conflict for IS_SMALLER in state 69 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 82 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_AND in state 82 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_OR in state 82 resolved as shift
WARNING: shift/reduce conflict for AND in state 82 resolved as shift
WARNING: shift/reduce conflict for OR in state 82 resolved as shift
WARNING: shift/reduce conflict for XOR in state 82 resolved as shift
WARNING: shift/reduce conflict for IS_EQUAL in state 82 resolved as shift
WARNING: shift/reduce conflict for IS_GREATER_OR_EQUAL in state 82 resolved as shift
WARNING: shift/reduce conflict for IS_NOT_EQUAL in state 82 resolved as shift
WARNING: shift/reduce conflict for IS_SMALLER_OR_EQUAL in state 82 resolved as shift
WARNING: shift/reduce conflict for IS_GREATER in state 82 resolved as shift
WARNING: shift/reduce conflict for IS_SMALLER in state 82 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 84 resolved as shift
WARNING: shift/reduce conflict for IS_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for IS_GREATER_OR_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for IS_NOT_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for IS_SMALLER_OR_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for IS_GREATER in state 84 resolved as shift
WARNING: shift/reduce conflict for IS_SMALLER in state 84 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 86 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 86 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 134 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 134 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 141 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 141 resolved as shift
WARNING: reduce/reduce conflict in state 5 resolved using rule (cuerpo -> estructuras_control)
WARNING: rejected rule (estructuras_control -> estructuras_control) in state 5
WARNING: reduce/reduce conflict in state 66 resolved using rule (valor -> valor)
WARNING: rejected rule (valorArreglo -> valor) in state 66
WARNING: reduce/reduce conflict in state 71 resolved using rule (valor -> number)
WARNING: rejected rule (expresion_aritmetica -> number) in state 71
WARNING: reduce/reduce conflict in state 82 resolved using rule (valor -> valor)
WARNING: rejected rule (expresiones_logicas -> valor) in state 82
WARNING: reduce/reduce conflict in state 83 resolved using rule (valor -> number)
WARNING: rejected rule (expresion_aritmetica -> number) in state 83
WARNING: Rule (estructuras_control -> estructuras_control) is never reduced
WARNING: Rule (valorArreglo -> valor) is never reduced
WARNING: Rule (expresiones_logicas -> valor) is never reduced
