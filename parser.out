Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADVANCE_PAGE
    CLOSE_TAG
    COMILLA_DOBLE
    ESCAPE
    FGETS
    FSCANF
    IDENTITY
    NEGATION
    NEW
    NULL
    OPEN_TAG
    OPERADOR_CONCATENACION
    PUSH
    READLINE
    SETSIZE
    SINTAXIS_ARRAY
    SPLEDOUBLYLINKEDLIST
    SPLFIXEDARRAY
    WHITESPACE

Grammar

Rule 0     S' -> cuerpo
Rule 1     cuerpo -> salida
Rule 2     cuerpo -> asignacion
Rule 3     cuerpo -> funcion
Rule 4     cuerpo -> estructuras_control
Rule 5     salida -> ECHO valor ENDLINE
Rule 6     salida -> PRINT LPAREN valor RPAREN ENDLINE
Rule 7     valor -> ARGUMENTO
Rule 8     valor -> INTEGER
Rule 9     valor -> FLOAT
Rule 10    valor -> BOOLEAN
Rule 11    valor -> STRING
Rule 12    valor -> VARIABLE
Rule 13    valor -> estructuras_datos
Rule 14    valor -> funciones
Rule 15    funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
Rule 16    asignacion -> VARIABLE operador_asignacion valor ENDLINE
Rule 17    operador_asignacion -> EQUAL
Rule 18    operador_asignacion -> PLUS_EQUAL
Rule 19    operador_asignacion -> CONCAT_EQUAL
Rule 20    estructuras_datos -> array
Rule 21    operador_comparacion -> IS_EQUAL
Rule 22    operador_comparacion -> IS_GREATER_OR_EQUAL
Rule 23    operador_comparacion -> IS_NOT_EQUAL
Rule 24    operador_comparacion -> IS_SMALLER_OR_EQUAL
Rule 25    operador_comparacion -> IS_GREATER
Rule 26    operador_comparacion -> IS_SMALLER
Rule 27    operacion_comparacion -> VARIABLE operador_comparacion VARIABLE
Rule 28    estructuras_control -> if
Rule 29    estructuras_control -> else
Rule 30    estructuras_control -> while
Rule 31    estructuras_control -> for
Rule 32    if -> IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY
Rule 33    else -> if ELSE LKEY cuerpo RKEY
Rule 34    expresion_logica -> BOOLEAN
Rule 35    expresion_logica -> valor AND valor
Rule 36    expresion_logica -> valor OR valor
Rule 37    expresion_logica -> valor XOR valor
Rule 38    expresion_logica -> NOT valor
Rule 39    expresion_logica -> valor BOOLEAN_AND valor
Rule 40    expresion_logica -> valor BOOLEAN_OR valor
Rule 41    while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
Rule 42    while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
Rule 43    array -> LBRACKET valor RBRACKET
Rule 44    funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY
Rule 45    tipo_operador -> ADDITION
Rule 46    tipo_operador -> SUBTRACTION
Rule 47    tipo_operador -> MULTIPLICATION
Rule 48    tipo_operador -> DIVISION
Rule 49    tipo_operador -> MODULO
Rule 50    tipo_operador -> EXPONENTIATION
Rule 51    forma_operacion -> VARIABLE OPERADOR_INCREMENTO
Rule 52    forma_operacion -> OPERADOR_INCREMENTO VARIABLE
Rule 53    forma_operacion -> VARIABLE OPERADOR_DECREMENTO
Rule 54    forma_operacion -> OPERADOR_DECREMENTO VARIABLE
Rule 55    forma_operacion -> VARIABLE EQUAL VARIABLE tipo_operador INTEGER
Rule 56    for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

Terminals, with rules where they appear

ADDITION             : 45
ADVANCE_PAGE         : 
AND                  : 35
ARGUMENTO            : 7 15 15
BOOLEAN              : 10 34
BOOLEAN_AND          : 39
BOOLEAN_OR           : 40
CLOSE_TAG            : 
COLON                : 41
COMILLA_DOBLE        : 
CONCAT_EQUAL         : 19
DIVISION             : 48
ECHO                 : 5
ELSE                 : 33
ENDLINE              : 5 6 16 56 56
EQUAL                : 17 55 56
ESCAPE               : 
EXPONENTIATION       : 50
FGETS                : 
FLOAT                : 9
FOR                  : 56
FSCANF               : 
FUNCTION             : 15
IDENTITY             : 
IF                   : 32
INTEGER              : 8 55 56 56
IS_EQUAL             : 21
IS_GREATER           : 25
IS_GREATER_OR_EQUAL  : 22
IS_NOT_EQUAL         : 23
IS_SMALLER           : 26
IS_SMALLER_OR_EQUAL  : 24
LBRACKET             : 43
LKEY                 : 15 32 33 42 44 56
LPAREN               : 6 15 32 41 42 44 56
MODULO               : 49
MULTIPLICATION       : 47
NEGATION             : 
NEW                  : 
NOT                  : 38
NULL                 : 
OPEN_TAG             : 
OPERADOR_CONCATENACION : 
OPERADOR_DECREMENTO  : 53 54
OPERADOR_INCREMENTO  : 51 52
OR                   : 36
PLUS_EQUAL           : 18
PRINT                : 6
PUSH                 : 
RBRACKET             : 43
READLINE             : 
RKEY                 : 15 32 33 42 44 56
RPAREN               : 6 15 32 41 42 44 56
SETSIZE              : 
SINTAXIS_ARRAY       : 
SPLEDOUBLYLINKEDLIST : 
SPLFIXEDARRAY        : 
STRING               : 11
SUBTRACTION          : 46
TAB_VERTICAL         : 42
VARIABLE             : 12 15 16 27 27 51 52 53 54 55 55 56 56
WHILE                : 41 42
WHITESPACE           : 
XOR                  : 37
error                : 

Nonterminals, with rules where they appear

array                : 20
asignacion           : 2
cuerpo               : 32 33 41 42 44 56 0
else                 : 29
estructuras_control  : 4
estructuras_datos    : 13
expresion_logica     : 32
for                  : 31
forma_operacion      : 56
funcion              : 3
funciones            : 14
if                   : 28 33
operacion_comparacion : 
operador_asignacion  : 16
operador_comparacion : 27 41 42 56
salida               : 1
tipo_operador        : 55
valor                : 5 6 16 35 35 36 36 37 37 38 39 39 40 40 41 41 42 42 43 44 44
while                : 30

Parsing method: LALR

state 0

    (0) S' -> . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . asignacion
    (3) cuerpo -> . funcion
    (4) cuerpo -> . estructuras_control
    (5) salida -> . ECHO valor ENDLINE
    (6) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (16) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (15) funcion -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (28) estructuras_control -> . if
    (29) estructuras_control -> . else
    (30) estructuras_control -> . while
    (31) estructuras_control -> . for
    (32) if -> . IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY
    (33) else -> . if ELSE LKEY cuerpo RKEY
    (41) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (42) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (56) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ECHO            shift and go to state 6
    PRINT           shift and go to state 7
    VARIABLE        shift and go to state 8
    FUNCTION        shift and go to state 9
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    FOR             shift and go to state 16

    cuerpo                         shift and go to state 1
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    funcion                        shift and go to state 4
    estructuras_control            shift and go to state 5
    if                             shift and go to state 10
    else                           shift and go to state 11
    while                          shift and go to state 12
    for                            shift and go to state 13

state 1

    (0) S' -> cuerpo .



state 2

    (1) cuerpo -> salida .

    $end            reduce using rule 1 (cuerpo -> salida .)
    RKEY            reduce using rule 1 (cuerpo -> salida .)


state 3

    (2) cuerpo -> asignacion .

    $end            reduce using rule 2 (cuerpo -> asignacion .)
    RKEY            reduce using rule 2 (cuerpo -> asignacion .)


state 4

    (3) cuerpo -> funcion .

    $end            reduce using rule 3 (cuerpo -> funcion .)
    RKEY            reduce using rule 3 (cuerpo -> funcion .)


state 5

    (4) cuerpo -> estructuras_control .

    $end            reduce using rule 4 (cuerpo -> estructuras_control .)
    RKEY            reduce using rule 4 (cuerpo -> estructuras_control .)


state 6

    (5) salida -> ECHO . valor ENDLINE
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 17
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 7

    (6) salida -> PRINT . LPAREN valor RPAREN ENDLINE

    LPAREN          shift and go to state 28


state 8

    (16) asignacion -> VARIABLE . operador_asignacion valor ENDLINE
    (17) operador_asignacion -> . EQUAL
    (18) operador_asignacion -> . PLUS_EQUAL
    (19) operador_asignacion -> . CONCAT_EQUAL

    EQUAL           shift and go to state 30
    PLUS_EQUAL      shift and go to state 31
    CONCAT_EQUAL    shift and go to state 32

    operador_asignacion            shift and go to state 29

state 9

    (15) funcion -> FUNCTION . ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY

    ARGUMENTO       shift and go to state 33


state 10

    (28) estructuras_control -> if .
    (33) else -> if . ELSE LKEY cuerpo RKEY

    $end            reduce using rule 28 (estructuras_control -> if .)
    RKEY            reduce using rule 28 (estructuras_control -> if .)
    ELSE            shift and go to state 34


state 11

    (29) estructuras_control -> else .

    $end            reduce using rule 29 (estructuras_control -> else .)
    RKEY            reduce using rule 29 (estructuras_control -> else .)


state 12

    (30) estructuras_control -> while .

    $end            reduce using rule 30 (estructuras_control -> while .)
    RKEY            reduce using rule 30 (estructuras_control -> while .)


state 13

    (31) estructuras_control -> for .

    $end            reduce using rule 31 (estructuras_control -> for .)
    RKEY            reduce using rule 31 (estructuras_control -> for .)


state 14

    (32) if -> IF . LPAREN expresion_logica RPAREN LKEY cuerpo RKEY

    LPAREN          shift and go to state 35


state 15

    (41) while -> WHILE . LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (42) while -> WHILE . LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY

    LPAREN          shift and go to state 36


state 16

    (56) for -> FOR . LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    LPAREN          shift and go to state 37


state 17

    (5) salida -> ECHO valor . ENDLINE
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    ENDLINE         shift and go to state 38
    LPAREN          shift and go to state 39


state 18

    (7) valor -> ARGUMENTO .

    ENDLINE         reduce using rule 7 (valor -> ARGUMENTO .)
    LPAREN          reduce using rule 7 (valor -> ARGUMENTO .)
    RBRACKET        reduce using rule 7 (valor -> ARGUMENTO .)
    RPAREN          reduce using rule 7 (valor -> ARGUMENTO .)
    AND             reduce using rule 7 (valor -> ARGUMENTO .)
    OR              reduce using rule 7 (valor -> ARGUMENTO .)
    XOR             reduce using rule 7 (valor -> ARGUMENTO .)
    BOOLEAN_AND     reduce using rule 7 (valor -> ARGUMENTO .)
    BOOLEAN_OR      reduce using rule 7 (valor -> ARGUMENTO .)
    IS_EQUAL        reduce using rule 7 (valor -> ARGUMENTO .)
    IS_GREATER_OR_EQUAL reduce using rule 7 (valor -> ARGUMENTO .)
    IS_NOT_EQUAL    reduce using rule 7 (valor -> ARGUMENTO .)
    IS_SMALLER_OR_EQUAL reduce using rule 7 (valor -> ARGUMENTO .)
    IS_GREATER      reduce using rule 7 (valor -> ARGUMENTO .)
    IS_SMALLER      reduce using rule 7 (valor -> ARGUMENTO .)


state 19

    (8) valor -> INTEGER .

    ENDLINE         reduce using rule 8 (valor -> INTEGER .)
    LPAREN          reduce using rule 8 (valor -> INTEGER .)
    RBRACKET        reduce using rule 8 (valor -> INTEGER .)
    RPAREN          reduce using rule 8 (valor -> INTEGER .)
    AND             reduce using rule 8 (valor -> INTEGER .)
    OR              reduce using rule 8 (valor -> INTEGER .)
    XOR             reduce using rule 8 (valor -> INTEGER .)
    BOOLEAN_AND     reduce using rule 8 (valor -> INTEGER .)
    BOOLEAN_OR      reduce using rule 8 (valor -> INTEGER .)
    IS_EQUAL        reduce using rule 8 (valor -> INTEGER .)
    IS_GREATER_OR_EQUAL reduce using rule 8 (valor -> INTEGER .)
    IS_NOT_EQUAL    reduce using rule 8 (valor -> INTEGER .)
    IS_SMALLER_OR_EQUAL reduce using rule 8 (valor -> INTEGER .)
    IS_GREATER      reduce using rule 8 (valor -> INTEGER .)
    IS_SMALLER      reduce using rule 8 (valor -> INTEGER .)


state 20

    (9) valor -> FLOAT .

    ENDLINE         reduce using rule 9 (valor -> FLOAT .)
    LPAREN          reduce using rule 9 (valor -> FLOAT .)
    RBRACKET        reduce using rule 9 (valor -> FLOAT .)
    RPAREN          reduce using rule 9 (valor -> FLOAT .)
    AND             reduce using rule 9 (valor -> FLOAT .)
    OR              reduce using rule 9 (valor -> FLOAT .)
    XOR             reduce using rule 9 (valor -> FLOAT .)
    BOOLEAN_AND     reduce using rule 9 (valor -> FLOAT .)
    BOOLEAN_OR      reduce using rule 9 (valor -> FLOAT .)
    IS_EQUAL        reduce using rule 9 (valor -> FLOAT .)
    IS_GREATER_OR_EQUAL reduce using rule 9 (valor -> FLOAT .)
    IS_NOT_EQUAL    reduce using rule 9 (valor -> FLOAT .)
    IS_SMALLER_OR_EQUAL reduce using rule 9 (valor -> FLOAT .)
    IS_GREATER      reduce using rule 9 (valor -> FLOAT .)
    IS_SMALLER      reduce using rule 9 (valor -> FLOAT .)


state 21

    (10) valor -> BOOLEAN .

    ENDLINE         reduce using rule 10 (valor -> BOOLEAN .)
    LPAREN          reduce using rule 10 (valor -> BOOLEAN .)
    RBRACKET        reduce using rule 10 (valor -> BOOLEAN .)
    RPAREN          reduce using rule 10 (valor -> BOOLEAN .)
    IS_EQUAL        reduce using rule 10 (valor -> BOOLEAN .)
    IS_GREATER_OR_EQUAL reduce using rule 10 (valor -> BOOLEAN .)
    IS_NOT_EQUAL    reduce using rule 10 (valor -> BOOLEAN .)
    IS_SMALLER_OR_EQUAL reduce using rule 10 (valor -> BOOLEAN .)
    IS_GREATER      reduce using rule 10 (valor -> BOOLEAN .)
    IS_SMALLER      reduce using rule 10 (valor -> BOOLEAN .)


state 22

    (11) valor -> STRING .

    ENDLINE         reduce using rule 11 (valor -> STRING .)
    LPAREN          reduce using rule 11 (valor -> STRING .)
    RBRACKET        reduce using rule 11 (valor -> STRING .)
    RPAREN          reduce using rule 11 (valor -> STRING .)
    AND             reduce using rule 11 (valor -> STRING .)
    OR              reduce using rule 11 (valor -> STRING .)
    XOR             reduce using rule 11 (valor -> STRING .)
    BOOLEAN_AND     reduce using rule 11 (valor -> STRING .)
    BOOLEAN_OR      reduce using rule 11 (valor -> STRING .)
    IS_EQUAL        reduce using rule 11 (valor -> STRING .)
    IS_GREATER_OR_EQUAL reduce using rule 11 (valor -> STRING .)
    IS_NOT_EQUAL    reduce using rule 11 (valor -> STRING .)
    IS_SMALLER_OR_EQUAL reduce using rule 11 (valor -> STRING .)
    IS_GREATER      reduce using rule 11 (valor -> STRING .)
    IS_SMALLER      reduce using rule 11 (valor -> STRING .)


state 23

    (12) valor -> VARIABLE .

    ENDLINE         reduce using rule 12 (valor -> VARIABLE .)
    LPAREN          reduce using rule 12 (valor -> VARIABLE .)
    RBRACKET        reduce using rule 12 (valor -> VARIABLE .)
    RPAREN          reduce using rule 12 (valor -> VARIABLE .)
    AND             reduce using rule 12 (valor -> VARIABLE .)
    OR              reduce using rule 12 (valor -> VARIABLE .)
    XOR             reduce using rule 12 (valor -> VARIABLE .)
    BOOLEAN_AND     reduce using rule 12 (valor -> VARIABLE .)
    BOOLEAN_OR      reduce using rule 12 (valor -> VARIABLE .)
    IS_EQUAL        reduce using rule 12 (valor -> VARIABLE .)
    IS_GREATER_OR_EQUAL reduce using rule 12 (valor -> VARIABLE .)
    IS_NOT_EQUAL    reduce using rule 12 (valor -> VARIABLE .)
    IS_SMALLER_OR_EQUAL reduce using rule 12 (valor -> VARIABLE .)
    IS_GREATER      reduce using rule 12 (valor -> VARIABLE .)
    IS_SMALLER      reduce using rule 12 (valor -> VARIABLE .)


state 24

    (13) valor -> estructuras_datos .

    ENDLINE         reduce using rule 13 (valor -> estructuras_datos .)
    LPAREN          reduce using rule 13 (valor -> estructuras_datos .)
    RBRACKET        reduce using rule 13 (valor -> estructuras_datos .)
    RPAREN          reduce using rule 13 (valor -> estructuras_datos .)
    AND             reduce using rule 13 (valor -> estructuras_datos .)
    OR              reduce using rule 13 (valor -> estructuras_datos .)
    XOR             reduce using rule 13 (valor -> estructuras_datos .)
    BOOLEAN_AND     reduce using rule 13 (valor -> estructuras_datos .)
    BOOLEAN_OR      reduce using rule 13 (valor -> estructuras_datos .)
    IS_EQUAL        reduce using rule 13 (valor -> estructuras_datos .)
    IS_GREATER_OR_EQUAL reduce using rule 13 (valor -> estructuras_datos .)
    IS_NOT_EQUAL    reduce using rule 13 (valor -> estructuras_datos .)
    IS_SMALLER_OR_EQUAL reduce using rule 13 (valor -> estructuras_datos .)
    IS_GREATER      reduce using rule 13 (valor -> estructuras_datos .)
    IS_SMALLER      reduce using rule 13 (valor -> estructuras_datos .)


state 25

    (14) valor -> funciones .

    ENDLINE         reduce using rule 14 (valor -> funciones .)
    LPAREN          reduce using rule 14 (valor -> funciones .)
    RBRACKET        reduce using rule 14 (valor -> funciones .)
    RPAREN          reduce using rule 14 (valor -> funciones .)
    AND             reduce using rule 14 (valor -> funciones .)
    OR              reduce using rule 14 (valor -> funciones .)
    XOR             reduce using rule 14 (valor -> funciones .)
    BOOLEAN_AND     reduce using rule 14 (valor -> funciones .)
    BOOLEAN_OR      reduce using rule 14 (valor -> funciones .)
    IS_EQUAL        reduce using rule 14 (valor -> funciones .)
    IS_GREATER_OR_EQUAL reduce using rule 14 (valor -> funciones .)
    IS_NOT_EQUAL    reduce using rule 14 (valor -> funciones .)
    IS_SMALLER_OR_EQUAL reduce using rule 14 (valor -> funciones .)
    IS_GREATER      reduce using rule 14 (valor -> funciones .)
    IS_SMALLER      reduce using rule 14 (valor -> funciones .)


state 26

    (20) estructuras_datos -> array .

    ENDLINE         reduce using rule 20 (estructuras_datos -> array .)
    LPAREN          reduce using rule 20 (estructuras_datos -> array .)
    RBRACKET        reduce using rule 20 (estructuras_datos -> array .)
    RPAREN          reduce using rule 20 (estructuras_datos -> array .)
    AND             reduce using rule 20 (estructuras_datos -> array .)
    OR              reduce using rule 20 (estructuras_datos -> array .)
    XOR             reduce using rule 20 (estructuras_datos -> array .)
    BOOLEAN_AND     reduce using rule 20 (estructuras_datos -> array .)
    BOOLEAN_OR      reduce using rule 20 (estructuras_datos -> array .)
    IS_EQUAL        reduce using rule 20 (estructuras_datos -> array .)
    IS_GREATER_OR_EQUAL reduce using rule 20 (estructuras_datos -> array .)
    IS_NOT_EQUAL    reduce using rule 20 (estructuras_datos -> array .)
    IS_SMALLER_OR_EQUAL reduce using rule 20 (estructuras_datos -> array .)
    IS_GREATER      reduce using rule 20 (estructuras_datos -> array .)
    IS_SMALLER      reduce using rule 20 (estructuras_datos -> array .)


state 27

    (43) array -> LBRACKET . valor RBRACKET
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 40
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 28

    (6) salida -> PRINT LPAREN . valor RPAREN ENDLINE
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 41
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 29

    (16) asignacion -> VARIABLE operador_asignacion . valor ENDLINE
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 42
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 30

    (17) operador_asignacion -> EQUAL .

    ARGUMENTO       reduce using rule 17 (operador_asignacion -> EQUAL .)
    INTEGER         reduce using rule 17 (operador_asignacion -> EQUAL .)
    FLOAT           reduce using rule 17 (operador_asignacion -> EQUAL .)
    BOOLEAN         reduce using rule 17 (operador_asignacion -> EQUAL .)
    STRING          reduce using rule 17 (operador_asignacion -> EQUAL .)
    VARIABLE        reduce using rule 17 (operador_asignacion -> EQUAL .)
    LBRACKET        reduce using rule 17 (operador_asignacion -> EQUAL .)


state 31

    (18) operador_asignacion -> PLUS_EQUAL .

    ARGUMENTO       reduce using rule 18 (operador_asignacion -> PLUS_EQUAL .)
    INTEGER         reduce using rule 18 (operador_asignacion -> PLUS_EQUAL .)
    FLOAT           reduce using rule 18 (operador_asignacion -> PLUS_EQUAL .)
    BOOLEAN         reduce using rule 18 (operador_asignacion -> PLUS_EQUAL .)
    STRING          reduce using rule 18 (operador_asignacion -> PLUS_EQUAL .)
    VARIABLE        reduce using rule 18 (operador_asignacion -> PLUS_EQUAL .)
    LBRACKET        reduce using rule 18 (operador_asignacion -> PLUS_EQUAL .)


state 32

    (19) operador_asignacion -> CONCAT_EQUAL .

    ARGUMENTO       reduce using rule 19 (operador_asignacion -> CONCAT_EQUAL .)
    INTEGER         reduce using rule 19 (operador_asignacion -> CONCAT_EQUAL .)
    FLOAT           reduce using rule 19 (operador_asignacion -> CONCAT_EQUAL .)
    BOOLEAN         reduce using rule 19 (operador_asignacion -> CONCAT_EQUAL .)
    STRING          reduce using rule 19 (operador_asignacion -> CONCAT_EQUAL .)
    VARIABLE        reduce using rule 19 (operador_asignacion -> CONCAT_EQUAL .)
    LBRACKET        reduce using rule 19 (operador_asignacion -> CONCAT_EQUAL .)


state 33

    (15) funcion -> FUNCTION ARGUMENTO . LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY

    LPAREN          shift and go to state 43


state 34

    (33) else -> if ELSE . LKEY cuerpo RKEY

    LKEY            shift and go to state 44


state 35

    (32) if -> IF LPAREN . expresion_logica RPAREN LKEY cuerpo RKEY
    (34) expresion_logica -> . BOOLEAN
    (35) expresion_logica -> . valor AND valor
    (36) expresion_logica -> . valor OR valor
    (37) expresion_logica -> . valor XOR valor
    (38) expresion_logica -> . NOT valor
    (39) expresion_logica -> . valor BOOLEAN_AND valor
    (40) expresion_logica -> . valor BOOLEAN_OR valor
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    BOOLEAN         shift and go to state 46
    NOT             shift and go to state 48
    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    expresion_logica               shift and go to state 45
    valor                          shift and go to state 47
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 36

    (41) while -> WHILE LPAREN . valor operador_comparacion valor RPAREN COLON cuerpo
    (42) while -> WHILE LPAREN . valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 49
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 37

    (56) for -> FOR LPAREN . VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    VARIABLE        shift and go to state 50


state 38

    (5) salida -> ECHO valor ENDLINE .

    $end            reduce using rule 5 (salida -> ECHO valor ENDLINE .)
    RKEY            reduce using rule 5 (salida -> ECHO valor ENDLINE .)


state 39

    (44) funciones -> valor LPAREN . valor RPAREN LKEY cuerpo RKEY
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 51
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 40

    (43) array -> LBRACKET valor . RBRACKET
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    RBRACKET        shift and go to state 52
    LPAREN          shift and go to state 39


state 41

    (6) salida -> PRINT LPAREN valor . RPAREN ENDLINE
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    RPAREN          shift and go to state 53
    LPAREN          shift and go to state 39


state 42

    (16) asignacion -> VARIABLE operador_asignacion valor . ENDLINE
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    ENDLINE         shift and go to state 54
    LPAREN          shift and go to state 39


state 43

    (15) funcion -> FUNCTION ARGUMENTO LPAREN . VARIABLE RPAREN LKEY ARGUMENTO RKEY

    VARIABLE        shift and go to state 55


state 44

    (33) else -> if ELSE LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . asignacion
    (3) cuerpo -> . funcion
    (4) cuerpo -> . estructuras_control
    (5) salida -> . ECHO valor ENDLINE
    (6) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (16) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (15) funcion -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (28) estructuras_control -> . if
    (29) estructuras_control -> . else
    (30) estructuras_control -> . while
    (31) estructuras_control -> . for
    (32) if -> . IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY
    (33) else -> . if ELSE LKEY cuerpo RKEY
    (41) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (42) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (56) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ECHO            shift and go to state 6
    PRINT           shift and go to state 7
    VARIABLE        shift and go to state 8
    FUNCTION        shift and go to state 9
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    FOR             shift and go to state 16

    if                             shift and go to state 10
    cuerpo                         shift and go to state 56
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    funcion                        shift and go to state 4
    estructuras_control            shift and go to state 5
    else                           shift and go to state 11
    while                          shift and go to state 12
    for                            shift and go to state 13

state 45

    (32) if -> IF LPAREN expresion_logica . RPAREN LKEY cuerpo RKEY

    RPAREN          shift and go to state 57


state 46

    (34) expresion_logica -> BOOLEAN .
    (10) valor -> BOOLEAN .

    RPAREN          reduce using rule 34 (expresion_logica -> BOOLEAN .)
    AND             reduce using rule 10 (valor -> BOOLEAN .)
    OR              reduce using rule 10 (valor -> BOOLEAN .)
    XOR             reduce using rule 10 (valor -> BOOLEAN .)
    BOOLEAN_AND     reduce using rule 10 (valor -> BOOLEAN .)
    BOOLEAN_OR      reduce using rule 10 (valor -> BOOLEAN .)
    LPAREN          reduce using rule 10 (valor -> BOOLEAN .)


state 47

    (35) expresion_logica -> valor . AND valor
    (36) expresion_logica -> valor . OR valor
    (37) expresion_logica -> valor . XOR valor
    (39) expresion_logica -> valor . BOOLEAN_AND valor
    (40) expresion_logica -> valor . BOOLEAN_OR valor
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    AND             shift and go to state 58
    OR              shift and go to state 59
    XOR             shift and go to state 60
    BOOLEAN_AND     shift and go to state 61
    BOOLEAN_OR      shift and go to state 62
    LPAREN          shift and go to state 39


state 48

    (38) expresion_logica -> NOT . valor
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 63
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 49

    (41) while -> WHILE LPAREN valor . operador_comparacion valor RPAREN COLON cuerpo
    (42) while -> WHILE LPAREN valor . operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY
    (21) operador_comparacion -> . IS_EQUAL
    (22) operador_comparacion -> . IS_GREATER_OR_EQUAL
    (23) operador_comparacion -> . IS_NOT_EQUAL
    (24) operador_comparacion -> . IS_SMALLER_OR_EQUAL
    (25) operador_comparacion -> . IS_GREATER
    (26) operador_comparacion -> . IS_SMALLER

    LPAREN          shift and go to state 39
    IS_EQUAL        shift and go to state 65
    IS_GREATER_OR_EQUAL shift and go to state 66
    IS_NOT_EQUAL    shift and go to state 67
    IS_SMALLER_OR_EQUAL shift and go to state 68
    IS_GREATER      shift and go to state 69
    IS_SMALLER      shift and go to state 70

    operador_comparacion           shift and go to state 64

state 50

    (56) for -> FOR LPAREN VARIABLE . EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    EQUAL           shift and go to state 71


state 51

    (44) funciones -> valor LPAREN valor . RPAREN LKEY cuerpo RKEY
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    RPAREN          shift and go to state 72
    LPAREN          shift and go to state 39


state 52

    (43) array -> LBRACKET valor RBRACKET .

    ENDLINE         reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    LPAREN          reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    RBRACKET        reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    RPAREN          reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    AND             reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    OR              reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    XOR             reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    BOOLEAN_AND     reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    BOOLEAN_OR      reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    IS_EQUAL        reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    IS_GREATER_OR_EQUAL reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    IS_NOT_EQUAL    reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    IS_SMALLER_OR_EQUAL reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    IS_GREATER      reduce using rule 43 (array -> LBRACKET valor RBRACKET .)
    IS_SMALLER      reduce using rule 43 (array -> LBRACKET valor RBRACKET .)


state 53

    (6) salida -> PRINT LPAREN valor RPAREN . ENDLINE

    ENDLINE         shift and go to state 73


state 54

    (16) asignacion -> VARIABLE operador_asignacion valor ENDLINE .

    $end            reduce using rule 16 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    RKEY            reduce using rule 16 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)


state 55

    (15) funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE . RPAREN LKEY ARGUMENTO RKEY

    RPAREN          shift and go to state 74


state 56

    (33) else -> if ELSE LKEY cuerpo . RKEY

    RKEY            shift and go to state 75


state 57

    (32) if -> IF LPAREN expresion_logica RPAREN . LKEY cuerpo RKEY

    LKEY            shift and go to state 76


state 58

    (35) expresion_logica -> valor AND . valor
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 77
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 59

    (36) expresion_logica -> valor OR . valor
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 78
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 60

    (37) expresion_logica -> valor XOR . valor
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 79
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 61

    (39) expresion_logica -> valor BOOLEAN_AND . valor
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 80
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 62

    (40) expresion_logica -> valor BOOLEAN_OR . valor
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 81
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 63

    (38) expresion_logica -> NOT valor .
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    RPAREN          reduce using rule 38 (expresion_logica -> NOT valor .)
    LPAREN          shift and go to state 39


state 64

    (41) while -> WHILE LPAREN valor operador_comparacion . valor RPAREN COLON cuerpo
    (42) while -> WHILE LPAREN valor operador_comparacion . valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (7) valor -> . ARGUMENTO
    (8) valor -> . INTEGER
    (9) valor -> . FLOAT
    (10) valor -> . BOOLEAN
    (11) valor -> . STRING
    (12) valor -> . VARIABLE
    (13) valor -> . estructuras_datos
    (14) valor -> . funciones
    (20) estructuras_datos -> . array
    (44) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (43) array -> . LBRACKET valor RBRACKET

    ARGUMENTO       shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    VARIABLE        shift and go to state 23
    LBRACKET        shift and go to state 27

    valor                          shift and go to state 82
    estructuras_datos              shift and go to state 24
    funciones                      shift and go to state 25
    array                          shift and go to state 26

state 65

    (21) operador_comparacion -> IS_EQUAL .

    ARGUMENTO       reduce using rule 21 (operador_comparacion -> IS_EQUAL .)
    INTEGER         reduce using rule 21 (operador_comparacion -> IS_EQUAL .)
    FLOAT           reduce using rule 21 (operador_comparacion -> IS_EQUAL .)
    BOOLEAN         reduce using rule 21 (operador_comparacion -> IS_EQUAL .)
    STRING          reduce using rule 21 (operador_comparacion -> IS_EQUAL .)
    VARIABLE        reduce using rule 21 (operador_comparacion -> IS_EQUAL .)
    LBRACKET        reduce using rule 21 (operador_comparacion -> IS_EQUAL .)


state 66

    (22) operador_comparacion -> IS_GREATER_OR_EQUAL .

    ARGUMENTO       reduce using rule 22 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 22 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    FLOAT           reduce using rule 22 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    BOOLEAN         reduce using rule 22 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    STRING          reduce using rule 22 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    VARIABLE        reduce using rule 22 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    LBRACKET        reduce using rule 22 (operador_comparacion -> IS_GREATER_OR_EQUAL .)


state 67

    (23) operador_comparacion -> IS_NOT_EQUAL .

    ARGUMENTO       reduce using rule 23 (operador_comparacion -> IS_NOT_EQUAL .)
    INTEGER         reduce using rule 23 (operador_comparacion -> IS_NOT_EQUAL .)
    FLOAT           reduce using rule 23 (operador_comparacion -> IS_NOT_EQUAL .)
    BOOLEAN         reduce using rule 23 (operador_comparacion -> IS_NOT_EQUAL .)
    STRING          reduce using rule 23 (operador_comparacion -> IS_NOT_EQUAL .)
    VARIABLE        reduce using rule 23 (operador_comparacion -> IS_NOT_EQUAL .)
    LBRACKET        reduce using rule 23 (operador_comparacion -> IS_NOT_EQUAL .)


state 68

    (24) operador_comparacion -> IS_SMALLER_OR_EQUAL .

    ARGUMENTO       reduce using rule 24 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 24 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    FLOAT           reduce using rule 24 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    BOOLEAN         reduce using rule 24 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    STRING          reduce using rule 24 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    VARIABLE        reduce using rule 24 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    LBRACKET        reduce using rule 24 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)


state 69

    (25) operador_comparacion -> IS_GREATER .

    ARGUMENTO       reduce using rule 25 (operador_comparacion -> IS_GREATER .)
    INTEGER         reduce using rule 25 (operador_comparacion -> IS_GREATER .)
    FLOAT           reduce using rule 25 (operador_comparacion -> IS_GREATER .)
    BOOLEAN         reduce using rule 25 (operador_comparacion -> IS_GREATER .)
    STRING          reduce using rule 25 (operador_comparacion -> IS_GREATER .)
    VARIABLE        reduce using rule 25 (operador_comparacion -> IS_GREATER .)
    LBRACKET        reduce using rule 25 (operador_comparacion -> IS_GREATER .)


state 70

    (26) operador_comparacion -> IS_SMALLER .

    ARGUMENTO       reduce using rule 26 (operador_comparacion -> IS_SMALLER .)
    INTEGER         reduce using rule 26 (operador_comparacion -> IS_SMALLER .)
    FLOAT           reduce using rule 26 (operador_comparacion -> IS_SMALLER .)
    BOOLEAN         reduce using rule 26 (operador_comparacion -> IS_SMALLER .)
    STRING          reduce using rule 26 (operador_comparacion -> IS_SMALLER .)
    VARIABLE        reduce using rule 26 (operador_comparacion -> IS_SMALLER .)
    LBRACKET        reduce using rule 26 (operador_comparacion -> IS_SMALLER .)


state 71

    (56) for -> FOR LPAREN VARIABLE EQUAL . INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    INTEGER         shift and go to state 83


state 72

    (44) funciones -> valor LPAREN valor RPAREN . LKEY cuerpo RKEY

    LKEY            shift and go to state 84


state 73

    (6) salida -> PRINT LPAREN valor RPAREN ENDLINE .

    $end            reduce using rule 6 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    RKEY            reduce using rule 6 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)


state 74

    (15) funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN . LKEY ARGUMENTO RKEY

    LKEY            shift and go to state 85


state 75

    (33) else -> if ELSE LKEY cuerpo RKEY .

    $end            reduce using rule 33 (else -> if ELSE LKEY cuerpo RKEY .)
    RKEY            reduce using rule 33 (else -> if ELSE LKEY cuerpo RKEY .)


state 76

    (32) if -> IF LPAREN expresion_logica RPAREN LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . asignacion
    (3) cuerpo -> . funcion
    (4) cuerpo -> . estructuras_control
    (5) salida -> . ECHO valor ENDLINE
    (6) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (16) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (15) funcion -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (28) estructuras_control -> . if
    (29) estructuras_control -> . else
    (30) estructuras_control -> . while
    (31) estructuras_control -> . for
    (32) if -> . IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY
    (33) else -> . if ELSE LKEY cuerpo RKEY
    (41) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (42) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (56) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ECHO            shift and go to state 6
    PRINT           shift and go to state 7
    VARIABLE        shift and go to state 8
    FUNCTION        shift and go to state 9
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    FOR             shift and go to state 16

    cuerpo                         shift and go to state 86
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    funcion                        shift and go to state 4
    estructuras_control            shift and go to state 5
    if                             shift and go to state 10
    else                           shift and go to state 11
    while                          shift and go to state 12
    for                            shift and go to state 13

state 77

    (35) expresion_logica -> valor AND valor .
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    RPAREN          reduce using rule 35 (expresion_logica -> valor AND valor .)
    LPAREN          shift and go to state 39


state 78

    (36) expresion_logica -> valor OR valor .
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    RPAREN          reduce using rule 36 (expresion_logica -> valor OR valor .)
    LPAREN          shift and go to state 39


state 79

    (37) expresion_logica -> valor XOR valor .
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    RPAREN          reduce using rule 37 (expresion_logica -> valor XOR valor .)
    LPAREN          shift and go to state 39


state 80

    (39) expresion_logica -> valor BOOLEAN_AND valor .
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    RPAREN          reduce using rule 39 (expresion_logica -> valor BOOLEAN_AND valor .)
    LPAREN          shift and go to state 39


state 81

    (40) expresion_logica -> valor BOOLEAN_OR valor .
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    RPAREN          reduce using rule 40 (expresion_logica -> valor BOOLEAN_OR valor .)
    LPAREN          shift and go to state 39


state 82

    (41) while -> WHILE LPAREN valor operador_comparacion valor . RPAREN COLON cuerpo
    (42) while -> WHILE LPAREN valor operador_comparacion valor . RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (44) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

    RPAREN          shift and go to state 87
    LPAREN          shift and go to state 39


state 83

    (56) for -> FOR LPAREN VARIABLE EQUAL INTEGER . ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ENDLINE         shift and go to state 88


state 84

    (44) funciones -> valor LPAREN valor RPAREN LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . asignacion
    (3) cuerpo -> . funcion
    (4) cuerpo -> . estructuras_control
    (5) salida -> . ECHO valor ENDLINE
    (6) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (16) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (15) funcion -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (28) estructuras_control -> . if
    (29) estructuras_control -> . else
    (30) estructuras_control -> . while
    (31) estructuras_control -> . for
    (32) if -> . IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY
    (33) else -> . if ELSE LKEY cuerpo RKEY
    (41) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (42) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (56) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ECHO            shift and go to state 6
    PRINT           shift and go to state 7
    VARIABLE        shift and go to state 8
    FUNCTION        shift and go to state 9
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    FOR             shift and go to state 16

    cuerpo                         shift and go to state 89
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    funcion                        shift and go to state 4
    estructuras_control            shift and go to state 5
    if                             shift and go to state 10
    else                           shift and go to state 11
    while                          shift and go to state 12
    for                            shift and go to state 13

state 85

    (15) funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY . ARGUMENTO RKEY

    ARGUMENTO       shift and go to state 90


state 86

    (32) if -> IF LPAREN expresion_logica RPAREN LKEY cuerpo . RKEY

    RKEY            shift and go to state 91


state 87

    (41) while -> WHILE LPAREN valor operador_comparacion valor RPAREN . COLON cuerpo
    (42) while -> WHILE LPAREN valor operador_comparacion valor RPAREN . LKEY TAB_VERTICAL cuerpo RKEY

    COLON           shift and go to state 92
    LKEY            shift and go to state 93


state 88

    (56) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE . VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    VARIABLE        shift and go to state 94


state 89

    (44) funciones -> valor LPAREN valor RPAREN LKEY cuerpo . RKEY

    RKEY            shift and go to state 95


state 90

    (15) funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO . RKEY

    RKEY            shift and go to state 96


state 91

    (32) if -> IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY .

    ELSE            reduce using rule 32 (if -> IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY .)
    $end            reduce using rule 32 (if -> IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY .)
    RKEY            reduce using rule 32 (if -> IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY .)


state 92

    (41) while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . asignacion
    (3) cuerpo -> . funcion
    (4) cuerpo -> . estructuras_control
    (5) salida -> . ECHO valor ENDLINE
    (6) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (16) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (15) funcion -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (28) estructuras_control -> . if
    (29) estructuras_control -> . else
    (30) estructuras_control -> . while
    (31) estructuras_control -> . for
    (32) if -> . IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY
    (33) else -> . if ELSE LKEY cuerpo RKEY
    (41) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (42) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (56) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ECHO            shift and go to state 6
    PRINT           shift and go to state 7
    VARIABLE        shift and go to state 8
    FUNCTION        shift and go to state 9
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    FOR             shift and go to state 16

    cuerpo                         shift and go to state 97
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    funcion                        shift and go to state 4
    estructuras_control            shift and go to state 5
    if                             shift and go to state 10
    else                           shift and go to state 11
    while                          shift and go to state 12
    for                            shift and go to state 13

state 93

    (42) while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY . TAB_VERTICAL cuerpo RKEY

    TAB_VERTICAL    shift and go to state 98


state 94

    (56) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE . operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (21) operador_comparacion -> . IS_EQUAL
    (22) operador_comparacion -> . IS_GREATER_OR_EQUAL
    (23) operador_comparacion -> . IS_NOT_EQUAL
    (24) operador_comparacion -> . IS_SMALLER_OR_EQUAL
    (25) operador_comparacion -> . IS_GREATER
    (26) operador_comparacion -> . IS_SMALLER

    IS_EQUAL        shift and go to state 65
    IS_GREATER_OR_EQUAL shift and go to state 66
    IS_NOT_EQUAL    shift and go to state 67
    IS_SMALLER_OR_EQUAL shift and go to state 68
    IS_GREATER      shift and go to state 69
    IS_SMALLER      shift and go to state 70

    operador_comparacion           shift and go to state 99

state 95

    (44) funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .

    ENDLINE         reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    LPAREN          reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    RBRACKET        reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    RPAREN          reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    AND             reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    OR              reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    XOR             reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    BOOLEAN_AND     reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    BOOLEAN_OR      reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_EQUAL        reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_GREATER_OR_EQUAL reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_NOT_EQUAL    reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_SMALLER_OR_EQUAL reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_GREATER      reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_SMALLER      reduce using rule 44 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)


state 96

    (15) funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .

    $end            reduce using rule 15 (funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    RKEY            reduce using rule 15 (funcion -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)


state 97

    (41) while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .

    $end            reduce using rule 41 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    RKEY            reduce using rule 41 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)


state 98

    (42) while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . asignacion
    (3) cuerpo -> . funcion
    (4) cuerpo -> . estructuras_control
    (5) salida -> . ECHO valor ENDLINE
    (6) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (16) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (15) funcion -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (28) estructuras_control -> . if
    (29) estructuras_control -> . else
    (30) estructuras_control -> . while
    (31) estructuras_control -> . for
    (32) if -> . IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY
    (33) else -> . if ELSE LKEY cuerpo RKEY
    (41) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (42) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (56) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ECHO            shift and go to state 6
    PRINT           shift and go to state 7
    VARIABLE        shift and go to state 8
    FUNCTION        shift and go to state 9
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    FOR             shift and go to state 16

    cuerpo                         shift and go to state 100
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    funcion                        shift and go to state 4
    estructuras_control            shift and go to state 5
    if                             shift and go to state 10
    else                           shift and go to state 11
    while                          shift and go to state 12
    for                            shift and go to state 13

state 99

    (56) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion . INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    INTEGER         shift and go to state 101


state 100

    (42) while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo . RKEY

    RKEY            shift and go to state 102


state 101

    (56) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER . ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ENDLINE         shift and go to state 103


state 102

    (42) while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .

    $end            reduce using rule 42 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    RKEY            reduce using rule 42 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)


state 103

    (56) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE . forma_operacion RPAREN LKEY cuerpo RKEY
    (51) forma_operacion -> . VARIABLE OPERADOR_INCREMENTO
    (52) forma_operacion -> . OPERADOR_INCREMENTO VARIABLE
    (53) forma_operacion -> . VARIABLE OPERADOR_DECREMENTO
    (54) forma_operacion -> . OPERADOR_DECREMENTO VARIABLE
    (55) forma_operacion -> . VARIABLE EQUAL VARIABLE tipo_operador INTEGER

    VARIABLE        shift and go to state 104
    OPERADOR_INCREMENTO shift and go to state 106
    OPERADOR_DECREMENTO shift and go to state 107

    forma_operacion                shift and go to state 105

state 104

    (51) forma_operacion -> VARIABLE . OPERADOR_INCREMENTO
    (53) forma_operacion -> VARIABLE . OPERADOR_DECREMENTO
    (55) forma_operacion -> VARIABLE . EQUAL VARIABLE tipo_operador INTEGER

    OPERADOR_INCREMENTO shift and go to state 108
    OPERADOR_DECREMENTO shift and go to state 109
    EQUAL           shift and go to state 110


state 105

    (56) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion . RPAREN LKEY cuerpo RKEY

    RPAREN          shift and go to state 111


state 106

    (52) forma_operacion -> OPERADOR_INCREMENTO . VARIABLE

    VARIABLE        shift and go to state 112


state 107

    (54) forma_operacion -> OPERADOR_DECREMENTO . VARIABLE

    VARIABLE        shift and go to state 113


state 108

    (51) forma_operacion -> VARIABLE OPERADOR_INCREMENTO .

    RPAREN          reduce using rule 51 (forma_operacion -> VARIABLE OPERADOR_INCREMENTO .)


state 109

    (53) forma_operacion -> VARIABLE OPERADOR_DECREMENTO .

    RPAREN          reduce using rule 53 (forma_operacion -> VARIABLE OPERADOR_DECREMENTO .)


state 110

    (55) forma_operacion -> VARIABLE EQUAL . VARIABLE tipo_operador INTEGER

    VARIABLE        shift and go to state 114


state 111

    (56) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN . LKEY cuerpo RKEY

    LKEY            shift and go to state 115


state 112

    (52) forma_operacion -> OPERADOR_INCREMENTO VARIABLE .

    RPAREN          reduce using rule 52 (forma_operacion -> OPERADOR_INCREMENTO VARIABLE .)


state 113

    (54) forma_operacion -> OPERADOR_DECREMENTO VARIABLE .

    RPAREN          reduce using rule 54 (forma_operacion -> OPERADOR_DECREMENTO VARIABLE .)


state 114

    (55) forma_operacion -> VARIABLE EQUAL VARIABLE . tipo_operador INTEGER
    (45) tipo_operador -> . ADDITION
    (46) tipo_operador -> . SUBTRACTION
    (47) tipo_operador -> . MULTIPLICATION
    (48) tipo_operador -> . DIVISION
    (49) tipo_operador -> . MODULO
    (50) tipo_operador -> . EXPONENTIATION

    ADDITION        shift and go to state 117
    SUBTRACTION     shift and go to state 118
    MULTIPLICATION  shift and go to state 119
    DIVISION        shift and go to state 120
    MODULO          shift and go to state 121
    EXPONENTIATION  shift and go to state 122

    tipo_operador                  shift and go to state 116

state 115

    (56) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . asignacion
    (3) cuerpo -> . funcion
    (4) cuerpo -> . estructuras_control
    (5) salida -> . ECHO valor ENDLINE
    (6) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (16) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (15) funcion -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (28) estructuras_control -> . if
    (29) estructuras_control -> . else
    (30) estructuras_control -> . while
    (31) estructuras_control -> . for
    (32) if -> . IF LPAREN expresion_logica RPAREN LKEY cuerpo RKEY
    (33) else -> . if ELSE LKEY cuerpo RKEY
    (41) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (42) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (56) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ECHO            shift and go to state 6
    PRINT           shift and go to state 7
    VARIABLE        shift and go to state 8
    FUNCTION        shift and go to state 9
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    FOR             shift and go to state 16

    cuerpo                         shift and go to state 123
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    funcion                        shift and go to state 4
    estructuras_control            shift and go to state 5
    if                             shift and go to state 10
    else                           shift and go to state 11
    while                          shift and go to state 12
    for                            shift and go to state 13

state 116

    (55) forma_operacion -> VARIABLE EQUAL VARIABLE tipo_operador . INTEGER

    INTEGER         shift and go to state 124


state 117

    (45) tipo_operador -> ADDITION .

    INTEGER         reduce using rule 45 (tipo_operador -> ADDITION .)


state 118

    (46) tipo_operador -> SUBTRACTION .

    INTEGER         reduce using rule 46 (tipo_operador -> SUBTRACTION .)


state 119

    (47) tipo_operador -> MULTIPLICATION .

    INTEGER         reduce using rule 47 (tipo_operador -> MULTIPLICATION .)


state 120

    (48) tipo_operador -> DIVISION .

    INTEGER         reduce using rule 48 (tipo_operador -> DIVISION .)


state 121

    (49) tipo_operador -> MODULO .

    INTEGER         reduce using rule 49 (tipo_operador -> MODULO .)


state 122

    (50) tipo_operador -> EXPONENTIATION .

    INTEGER         reduce using rule 50 (tipo_operador -> EXPONENTIATION .)


state 123

    (56) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo . RKEY

    RKEY            shift and go to state 125


state 124

    (55) forma_operacion -> VARIABLE EQUAL VARIABLE tipo_operador INTEGER .

    RPAREN          reduce using rule 55 (forma_operacion -> VARIABLE EQUAL VARIABLE tipo_operador INTEGER .)


state 125

    (56) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .

    $end            reduce using rule 56 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    RKEY            reduce using rule 56 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)

