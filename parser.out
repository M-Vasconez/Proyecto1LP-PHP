Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADVANCE_PAGE
    ARRAY
    CLOSE_TAG
    ESCAPE
    FGETS
    IDENTITY
    LBRACKET
    NEGATION
    NOT
    NULL
    OPEN_TAG
    OPERADOR_CONCATENACION
    RBRACKET
    READLINE
    SETSIZE
    SINTAXIS_ARRAY
    WHITESPACE

Grammar

Rule 0     S' -> cuerpo
Rule 1     cuerpo -> salida
Rule 2     cuerpo -> salida cuerpo
Rule 3     cuerpo -> asignacion
Rule 4     cuerpo -> asignacion cuerpo
Rule 5     cuerpo -> function
Rule 6     cuerpo -> function cuerpo
Rule 7     cuerpo -> estructuras_control
Rule 8     cuerpo -> estructuras_control cuerpo
Rule 9     cuerpo -> estructuras_datos
Rule 10    cuerpo -> metodos
Rule 11    cuerpo -> metodos cuerpo
Rule 12    cuerpo -> abrir_archivo
Rule 13    cuerpo -> lectura_archivo
Rule 14    salida -> ECHO valor ENDLINE
Rule 15    salida -> PRINT LPAREN valor RPAREN ENDLINE
Rule 16    valor -> ARGUMENTO
Rule 17    valor -> number
Rule 18    valor -> BOOLEAN
Rule 19    valor -> string
Rule 20    valor -> VARIABLE
Rule 21    valor -> estructuras_datos
Rule 22    valor -> funciones
Rule 23    valor -> valor
Rule 24    string -> STRING
Rule 25    string -> COMILLA_DOBLE STRING COMILLA_DOBLE
Rule 26    string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE
Rule 27    function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
Rule 28    asignacion -> VARIABLE operador_asignacion valor ENDLINE
Rule 29    asignacion -> VARIABLE operador_asignacion expresion ENDLINE
Rule 30    asignacion -> queue_variable operador_asignacion queue ENDLINE
Rule 31    queue -> NEW SPLQUEUE LPAREN RPAREN
Rule 32    queue_variable -> VARIABLE
Rule 33    asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE
Rule 34    splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
Rule 35    splfixedarray_variable -> VARIABLE
Rule 36    push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
Rule 37    pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE
Rule 38    metodos -> push
Rule 39    metodos -> pop
Rule 40    operador_asignacion -> EQUAL
Rule 41    operador_asignacion -> PLUS_EQUAL
Rule 42    operador_asignacion -> CONCAT_EQUAL
Rule 43    estructuras_datos -> array
Rule 44    estructuras_datos -> queue
Rule 45    estructuras_datos -> splfixedarray
Rule 46    operador_comparacion -> IS_EQUAL
Rule 47    operador_comparacion -> IS_GREATER_OR_EQUAL
Rule 48    operador_comparacion -> IS_NOT_EQUAL
Rule 49    operador_comparacion -> IS_SMALLER_OR_EQUAL
Rule 50    operador_comparacion -> IS_GREATER
Rule 51    operador_comparacion -> IS_SMALLER
Rule 52    operacion_comparacion -> VARIABLE operador_comparacion VARIABLE
Rule 53    estructuras_control -> if
Rule 54    estructuras_control -> else
Rule 55    estructuras_control -> while
Rule 56    estructuras_control -> for
Rule 57    estructuras_control -> estructuras_control
Rule 58    if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY
Rule 59    else -> if ELSE LKEY cuerpo RKEY
Rule 60    expresion -> expresiones_logicas
Rule 61    expresion -> expresion_aritmetica
Rule 62    expresiones_logicas -> valor
Rule 63    expresiones_logicas -> valor operador expresiones_logicas
Rule 64    operador_logico -> BOOLEAN_AND
Rule 65    operador_logico -> BOOLEAN_OR
Rule 66    operador_logico -> AND
Rule 67    operador_logico -> OR
Rule 68    operador_logico -> XOR
Rule 69    operador -> operador_logico
Rule 70    operador -> operador_comparacion
Rule 71    number -> INTEGER
Rule 72    number -> FLOAT
Rule 73    operador_aritmetico -> ADDITION
Rule 74    operador_aritmetico -> SUBTRACTION
Rule 75    operador_aritmetico -> MULTIPLICATION
Rule 76    operador_aritmetico -> DIVISION
Rule 77    operador_aritmetico -> MODULO
Rule 78    operador_aritmetico -> EXPONENTIATION
Rule 79    expresion_aritmetica -> number
Rule 80    expresion_aritmetica -> number operador_aritmetico expresion_aritmetica
Rule 81    abrir_archivo -> FOPEN LPAREN string RPAREN
Rule 82    abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE
Rule 83    lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
Rule 84    while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
Rule 85    while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
Rule 86    array -> LPAREN valorArreglo RPAREN ENDLINE
Rule 87    valorArreglo -> valor COMA valorArreglo
Rule 88    valorArreglo -> valor
Rule 89    funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY
Rule 90    tipo_operador -> ADDITION
Rule 91    tipo_operador -> SUBTRACTION
Rule 92    tipo_operador -> MULTIPLICATION
Rule 93    tipo_operador -> DIVISION
Rule 94    tipo_operador -> MODULO
Rule 95    tipo_operador -> EXPONENTIATION
Rule 96    forma_operacion -> VARIABLE OPERADOR_INCREMENTO
Rule 97    forma_operacion -> OPERADOR_INCREMENTO VARIABLE
Rule 98    forma_operacion -> VARIABLE OPERADOR_DECREMENTO
Rule 99    forma_operacion -> OPERADOR_DECREMENTO VARIABLE
Rule 100   forma_operacion -> VARIABLE EQUAL VARIABLE tipo_operador INTEGER
Rule 101   for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

Terminals, with rules where they appear

ADDITION             : 73 90
ADVANCE_PAGE         : 
AND                  : 66
ARGUMENTO            : 16 27 27
ARRAY                : 
ARROW                : 36 37
BOOLEAN              : 18
BOOLEAN_AND          : 64
BOOLEAN_OR           : 65
CLOSE_TAG            : 
COLON                : 84
COMA                 : 83 87
COMILLA_DOBLE        : 25 25
COMILLA_SIMPLE       : 26 26
CONCAT_EQUAL         : 42
DIVISION             : 76 93
ECHO                 : 14
ELSE                 : 59
ENDLINE              : 14 15 28 29 30 33 36 37 82 83 86 101 101
EQUAL                : 40 100 101
ESCAPE               : 
EXPONENTIATION       : 78 95
FGETS                : 
FLOAT                : 72
FOPEN                : 81 82
FOR                  : 101
FSCANF               : 83
FUNCTION             : 27
IDENTITY             : 
IF                   : 58
INTEGER              : 34 71 100 101 101
IS_EQUAL             : 46
IS_GREATER           : 50
IS_GREATER_OR_EQUAL  : 47
IS_NOT_EQUAL         : 48
IS_SMALLER           : 51
IS_SMALLER_OR_EQUAL  : 49
LBRACKET             : 
LKEY                 : 27 58 59 85 89 101
LPAREN               : 15 27 31 34 36 37 58 81 82 83 84 85 86 89 101
MODULO               : 77 94
MULTIPLICATION       : 75 92
NEGATION             : 
NEW                  : 31 34
NOT                  : 
NULL                 : 
OPEN_TAG             : 
OPERADOR_CONCATENACION : 
OPERADOR_DECREMENTO  : 98 99
OPERADOR_INCREMENTO  : 96 97
OR                   : 67
PLUS_EQUAL           : 41
POP                  : 37
PRINT                : 15
PUSH                 : 36
RBRACKET             : 
READLINE             : 
RKEY                 : 27 58 59 85 89 101
RPAREN               : 15 27 31 34 36 37 58 81 82 83 84 85 86 89 101
SETSIZE              : 
SINTAXIS_ARRAY       : 
SPLFIXEDARRAY        : 34
SPLQUEUE             : 31
STRING               : 24 25 26
SUBTRACTION          : 74 91
TAB_VERTICAL         : 85
VARIABLE             : 20 27 28 29 32 35 52 52 96 97 98 99 100 100 101 101
WHILE                : 84 85
WHITESPACE           : 
XOR                  : 68
error                : 

Nonterminals, with rules where they appear

abrir_archivo        : 12 83
array                : 43
asignacion           : 3 4
cuerpo               : 2 4 6 8 11 58 59 84 85 89 101 0
else                 : 54
estructuras_control  : 7 8 57
estructuras_datos    : 9 21
expresion            : 29 58
expresion_aritmetica : 61 80
expresiones_logicas  : 60 63
for                  : 56
forma_operacion      : 101
funciones            : 22
function             : 5 6
if                   : 53 59
lectura_archivo      : 13
metodos              : 10 11
number               : 17 79 80
operacion_comparacion : 
operador             : 63
operador_aritmetico  : 80
operador_asignacion  : 28 29 30 33
operador_comparacion : 52 70 84 85 101
operador_logico      : 69
pop                  : 39
push                 : 38
queue                : 30 44
queue_variable       : 30 36 37
salida               : 1 2
splfixedarray        : 33 45
splfixedarray_variable : 33
string               : 19 81 82 83
tipo_operador        : 100
valor                : 14 15 23 28 36 62 63 84 84 85 85 87 88 89 89
valorArreglo         : 86 87
while                : 55

Parsing method: LALR

state 0

    (0) S' -> . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . estructuras_datos
    (10) cuerpo -> . metodos
    (11) cuerpo -> . metodos cuerpo
    (12) cuerpo -> . abrir_archivo
    (13) cuerpo -> . lectura_archivo
    (14) salida -> . ECHO valor ENDLINE
    (15) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (29) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (30) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (33) asignacion -> . splfixedarray_variable operador_asignacion splfixedarray ENDLINE
    (27) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (53) estructuras_control -> . if
    (54) estructuras_control -> . else
    (55) estructuras_control -> . while
    (56) estructuras_control -> . for
    (57) estructuras_control -> . estructuras_control
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (38) metodos -> . push
    (39) metodos -> . pop
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (83) lectura_archivo -> . FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
    (32) queue_variable -> . VARIABLE
    (35) splfixedarray_variable -> . VARIABLE
    (58) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (59) else -> . if ELSE LKEY cuerpo RKEY
    (84) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (101) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
    (36) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 10
    PRINT           shift and go to state 11
    VARIABLE        shift and go to state 13
    FUNCTION        shift and go to state 18
    FOPEN           shift and go to state 26
    FSCANF          shift and go to state 27
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    cuerpo                         shift and go to state 1
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    estructuras_datos              shift and go to state 6
    metodos                        shift and go to state 7
    abrir_archivo                  shift and go to state 8
    lectura_archivo                shift and go to state 9
    queue_variable                 shift and go to state 14
    queue                          shift and go to state 15
    splfixedarray_variable         shift and go to state 16
    splfixedarray                  shift and go to state 17
    if                             shift and go to state 19
    else                           shift and go to state 20
    while                          shift and go to state 21
    for                            shift and go to state 22
    array                          shift and go to state 23
    push                           shift and go to state 24
    pop                            shift and go to state 25

state 1

    (0) S' -> cuerpo .



state 2

    (1) cuerpo -> salida .
    (2) cuerpo -> salida . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . estructuras_datos
    (10) cuerpo -> . metodos
    (11) cuerpo -> . metodos cuerpo
    (12) cuerpo -> . abrir_archivo
    (13) cuerpo -> . lectura_archivo
    (14) salida -> . ECHO valor ENDLINE
    (15) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (29) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (30) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (33) asignacion -> . splfixedarray_variable operador_asignacion splfixedarray ENDLINE
    (27) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (53) estructuras_control -> . if
    (54) estructuras_control -> . else
    (55) estructuras_control -> . while
    (56) estructuras_control -> . for
    (57) estructuras_control -> . estructuras_control
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (38) metodos -> . push
    (39) metodos -> . pop
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (83) lectura_archivo -> . FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
    (32) queue_variable -> . VARIABLE
    (35) splfixedarray_variable -> . VARIABLE
    (58) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (59) else -> . if ELSE LKEY cuerpo RKEY
    (84) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (101) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
    (36) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FOPEN resolved as shift
  ! shift/reduce conflict for FSCANF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
    $end            reduce using rule 1 (cuerpo -> salida .)
    RKEY            reduce using rule 1 (cuerpo -> salida .)
    ECHO            shift and go to state 10
    PRINT           shift and go to state 11
    VARIABLE        shift and go to state 13
    FUNCTION        shift and go to state 18
    FOPEN           shift and go to state 26
    FSCANF          shift and go to state 27
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

  ! ECHO            [ reduce using rule 1 (cuerpo -> salida .) ]
  ! PRINT           [ reduce using rule 1 (cuerpo -> salida .) ]
  ! VARIABLE        [ reduce using rule 1 (cuerpo -> salida .) ]
  ! FUNCTION        [ reduce using rule 1 (cuerpo -> salida .) ]
  ! FOPEN           [ reduce using rule 1 (cuerpo -> salida .) ]
  ! FSCANF          [ reduce using rule 1 (cuerpo -> salida .) ]
  ! IF              [ reduce using rule 1 (cuerpo -> salida .) ]
  ! WHILE           [ reduce using rule 1 (cuerpo -> salida .) ]
  ! FOR             [ reduce using rule 1 (cuerpo -> salida .) ]
  ! LPAREN          [ reduce using rule 1 (cuerpo -> salida .) ]
  ! NEW             [ reduce using rule 1 (cuerpo -> salida .) ]

    salida                         shift and go to state 2
    cuerpo                         shift and go to state 32
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    estructuras_datos              shift and go to state 6
    metodos                        shift and go to state 7
    abrir_archivo                  shift and go to state 8
    lectura_archivo                shift and go to state 9
    queue_variable                 shift and go to state 14
    queue                          shift and go to state 15
    splfixedarray_variable         shift and go to state 16
    splfixedarray                  shift and go to state 17
    if                             shift and go to state 19
    else                           shift and go to state 20
    while                          shift and go to state 21
    for                            shift and go to state 22
    array                          shift and go to state 23
    push                           shift and go to state 24
    pop                            shift and go to state 25

state 3

    (3) cuerpo -> asignacion .
    (4) cuerpo -> asignacion . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . estructuras_datos
    (10) cuerpo -> . metodos
    (11) cuerpo -> . metodos cuerpo
    (12) cuerpo -> . abrir_archivo
    (13) cuerpo -> . lectura_archivo
    (14) salida -> . ECHO valor ENDLINE
    (15) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (29) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (30) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (33) asignacion -> . splfixedarray_variable operador_asignacion splfixedarray ENDLINE
    (27) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (53) estructuras_control -> . if
    (54) estructuras_control -> . else
    (55) estructuras_control -> . while
    (56) estructuras_control -> . for
    (57) estructuras_control -> . estructuras_control
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (38) metodos -> . push
    (39) metodos -> . pop
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (83) lectura_archivo -> . FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
    (32) queue_variable -> . VARIABLE
    (35) splfixedarray_variable -> . VARIABLE
    (58) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (59) else -> . if ELSE LKEY cuerpo RKEY
    (84) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (101) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
    (36) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FOPEN resolved as shift
  ! shift/reduce conflict for FSCANF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
    $end            reduce using rule 3 (cuerpo -> asignacion .)
    RKEY            reduce using rule 3 (cuerpo -> asignacion .)
    ECHO            shift and go to state 10
    PRINT           shift and go to state 11
    VARIABLE        shift and go to state 13
    FUNCTION        shift and go to state 18
    FOPEN           shift and go to state 26
    FSCANF          shift and go to state 27
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

  ! ECHO            [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! PRINT           [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! VARIABLE        [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! FUNCTION        [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! FOPEN           [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! FSCANF          [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! IF              [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! WHILE           [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! FOR             [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! LPAREN          [ reduce using rule 3 (cuerpo -> asignacion .) ]
  ! NEW             [ reduce using rule 3 (cuerpo -> asignacion .) ]

    asignacion                     shift and go to state 3
    cuerpo                         shift and go to state 33
    salida                         shift and go to state 2
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    estructuras_datos              shift and go to state 6
    metodos                        shift and go to state 7
    abrir_archivo                  shift and go to state 8
    lectura_archivo                shift and go to state 9
    queue_variable                 shift and go to state 14
    queue                          shift and go to state 15
    splfixedarray_variable         shift and go to state 16
    splfixedarray                  shift and go to state 17
    if                             shift and go to state 19
    else                           shift and go to state 20
    while                          shift and go to state 21
    for                            shift and go to state 22
    array                          shift and go to state 23
    push                           shift and go to state 24
    pop                            shift and go to state 25

state 4

    (5) cuerpo -> function .
    (6) cuerpo -> function . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . estructuras_datos
    (10) cuerpo -> . metodos
    (11) cuerpo -> . metodos cuerpo
    (12) cuerpo -> . abrir_archivo
    (13) cuerpo -> . lectura_archivo
    (14) salida -> . ECHO valor ENDLINE
    (15) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (29) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (30) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (33) asignacion -> . splfixedarray_variable operador_asignacion splfixedarray ENDLINE
    (27) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (53) estructuras_control -> . if
    (54) estructuras_control -> . else
    (55) estructuras_control -> . while
    (56) estructuras_control -> . for
    (57) estructuras_control -> . estructuras_control
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (38) metodos -> . push
    (39) metodos -> . pop
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (83) lectura_archivo -> . FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
    (32) queue_variable -> . VARIABLE
    (35) splfixedarray_variable -> . VARIABLE
    (58) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (59) else -> . if ELSE LKEY cuerpo RKEY
    (84) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (101) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
    (36) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FOPEN resolved as shift
  ! shift/reduce conflict for FSCANF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
    $end            reduce using rule 5 (cuerpo -> function .)
    RKEY            reduce using rule 5 (cuerpo -> function .)
    ECHO            shift and go to state 10
    PRINT           shift and go to state 11
    VARIABLE        shift and go to state 13
    FUNCTION        shift and go to state 18
    FOPEN           shift and go to state 26
    FSCANF          shift and go to state 27
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

  ! ECHO            [ reduce using rule 5 (cuerpo -> function .) ]
  ! PRINT           [ reduce using rule 5 (cuerpo -> function .) ]
  ! VARIABLE        [ reduce using rule 5 (cuerpo -> function .) ]
  ! FUNCTION        [ reduce using rule 5 (cuerpo -> function .) ]
  ! FOPEN           [ reduce using rule 5 (cuerpo -> function .) ]
  ! FSCANF          [ reduce using rule 5 (cuerpo -> function .) ]
  ! IF              [ reduce using rule 5 (cuerpo -> function .) ]
  ! WHILE           [ reduce using rule 5 (cuerpo -> function .) ]
  ! FOR             [ reduce using rule 5 (cuerpo -> function .) ]
  ! LPAREN          [ reduce using rule 5 (cuerpo -> function .) ]
  ! NEW             [ reduce using rule 5 (cuerpo -> function .) ]

    function                       shift and go to state 4
    cuerpo                         shift and go to state 34
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    estructuras_control            shift and go to state 5
    estructuras_datos              shift and go to state 6
    metodos                        shift and go to state 7
    abrir_archivo                  shift and go to state 8
    lectura_archivo                shift and go to state 9
    queue_variable                 shift and go to state 14
    queue                          shift and go to state 15
    splfixedarray_variable         shift and go to state 16
    splfixedarray                  shift and go to state 17
    if                             shift and go to state 19
    else                           shift and go to state 20
    while                          shift and go to state 21
    for                            shift and go to state 22
    array                          shift and go to state 23
    push                           shift and go to state 24
    pop                            shift and go to state 25

state 5

    (7) cuerpo -> estructuras_control .
    (8) cuerpo -> estructuras_control . cuerpo
    (57) estructuras_control -> estructuras_control .
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . estructuras_datos
    (10) cuerpo -> . metodos
    (11) cuerpo -> . metodos cuerpo
    (12) cuerpo -> . abrir_archivo
    (13) cuerpo -> . lectura_archivo
    (14) salida -> . ECHO valor ENDLINE
    (15) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (29) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (30) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (33) asignacion -> . splfixedarray_variable operador_asignacion splfixedarray ENDLINE
    (27) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (53) estructuras_control -> . if
    (54) estructuras_control -> . else
    (55) estructuras_control -> . while
    (56) estructuras_control -> . for
    (57) estructuras_control -> . estructuras_control
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (38) metodos -> . push
    (39) metodos -> . pop
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (83) lectura_archivo -> . FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
    (32) queue_variable -> . VARIABLE
    (35) splfixedarray_variable -> . VARIABLE
    (58) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (59) else -> . if ELSE LKEY cuerpo RKEY
    (84) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (101) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
    (36) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

  ! reduce/reduce conflict for ECHO resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for PRINT resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for FOPEN resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for FSCANF resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for IF resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for WHILE resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for FOR resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for LPAREN resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for NEW resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for $end resolved using rule 7 (cuerpo -> estructuras_control .)
  ! reduce/reduce conflict for RKEY resolved using rule 7 (cuerpo -> estructuras_control .)
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FOPEN resolved as shift
  ! shift/reduce conflict for FSCANF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
    $end            reduce using rule 7 (cuerpo -> estructuras_control .)
    RKEY            reduce using rule 7 (cuerpo -> estructuras_control .)
    ECHO            shift and go to state 10
    PRINT           shift and go to state 11
    VARIABLE        shift and go to state 13
    FUNCTION        shift and go to state 18
    FOPEN           shift and go to state 26
    FSCANF          shift and go to state 27
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

  ! ECHO            [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! PRINT           [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! VARIABLE        [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! FUNCTION        [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! FOPEN           [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! FSCANF          [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! IF              [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! WHILE           [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! FOR             [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! LPAREN          [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! NEW             [ reduce using rule 7 (cuerpo -> estructuras_control .) ]
  ! ECHO            [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]
  ! PRINT           [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]
  ! VARIABLE        [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]
  ! FUNCTION        [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]
  ! FOPEN           [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]
  ! FSCANF          [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]
  ! IF              [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]
  ! WHILE           [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]
  ! FOR             [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]
  ! LPAREN          [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]
  ! NEW             [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]
  ! $end            [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]
  ! RKEY            [ reduce using rule 57 (estructuras_control -> estructuras_control .) ]

    estructuras_control            shift and go to state 5
    cuerpo                         shift and go to state 35
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_datos              shift and go to state 6
    metodos                        shift and go to state 7
    abrir_archivo                  shift and go to state 8
    lectura_archivo                shift and go to state 9
    queue_variable                 shift and go to state 14
    queue                          shift and go to state 15
    splfixedarray_variable         shift and go to state 16
    splfixedarray                  shift and go to state 17
    if                             shift and go to state 19
    else                           shift and go to state 20
    while                          shift and go to state 21
    for                            shift and go to state 22
    array                          shift and go to state 23
    push                           shift and go to state 24
    pop                            shift and go to state 25

state 6

    (9) cuerpo -> estructuras_datos .

    $end            reduce using rule 9 (cuerpo -> estructuras_datos .)
    RKEY            reduce using rule 9 (cuerpo -> estructuras_datos .)
    ECHO            reduce using rule 9 (cuerpo -> estructuras_datos .)
    PRINT           reduce using rule 9 (cuerpo -> estructuras_datos .)
    VARIABLE        reduce using rule 9 (cuerpo -> estructuras_datos .)
    FUNCTION        reduce using rule 9 (cuerpo -> estructuras_datos .)
    FOPEN           reduce using rule 9 (cuerpo -> estructuras_datos .)
    FSCANF          reduce using rule 9 (cuerpo -> estructuras_datos .)
    IF              reduce using rule 9 (cuerpo -> estructuras_datos .)
    WHILE           reduce using rule 9 (cuerpo -> estructuras_datos .)
    FOR             reduce using rule 9 (cuerpo -> estructuras_datos .)
    LPAREN          reduce using rule 9 (cuerpo -> estructuras_datos .)
    NEW             reduce using rule 9 (cuerpo -> estructuras_datos .)


state 7

    (10) cuerpo -> metodos .
    (11) cuerpo -> metodos . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . estructuras_datos
    (10) cuerpo -> . metodos
    (11) cuerpo -> . metodos cuerpo
    (12) cuerpo -> . abrir_archivo
    (13) cuerpo -> . lectura_archivo
    (14) salida -> . ECHO valor ENDLINE
    (15) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (29) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (30) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (33) asignacion -> . splfixedarray_variable operador_asignacion splfixedarray ENDLINE
    (27) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (53) estructuras_control -> . if
    (54) estructuras_control -> . else
    (55) estructuras_control -> . while
    (56) estructuras_control -> . for
    (57) estructuras_control -> . estructuras_control
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (38) metodos -> . push
    (39) metodos -> . pop
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (83) lectura_archivo -> . FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
    (32) queue_variable -> . VARIABLE
    (35) splfixedarray_variable -> . VARIABLE
    (58) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (59) else -> . if ELSE LKEY cuerpo RKEY
    (84) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (101) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
    (36) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FOPEN resolved as shift
  ! shift/reduce conflict for FSCANF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
    $end            reduce using rule 10 (cuerpo -> metodos .)
    RKEY            reduce using rule 10 (cuerpo -> metodos .)
    ECHO            shift and go to state 10
    PRINT           shift and go to state 11
    VARIABLE        shift and go to state 13
    FUNCTION        shift and go to state 18
    FOPEN           shift and go to state 26
    FSCANF          shift and go to state 27
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

  ! ECHO            [ reduce using rule 10 (cuerpo -> metodos .) ]
  ! PRINT           [ reduce using rule 10 (cuerpo -> metodos .) ]
  ! VARIABLE        [ reduce using rule 10 (cuerpo -> metodos .) ]
  ! FUNCTION        [ reduce using rule 10 (cuerpo -> metodos .) ]
  ! FOPEN           [ reduce using rule 10 (cuerpo -> metodos .) ]
  ! FSCANF          [ reduce using rule 10 (cuerpo -> metodos .) ]
  ! IF              [ reduce using rule 10 (cuerpo -> metodos .) ]
  ! WHILE           [ reduce using rule 10 (cuerpo -> metodos .) ]
  ! FOR             [ reduce using rule 10 (cuerpo -> metodos .) ]
  ! LPAREN          [ reduce using rule 10 (cuerpo -> metodos .) ]
  ! NEW             [ reduce using rule 10 (cuerpo -> metodos .) ]

    metodos                        shift and go to state 7
    cuerpo                         shift and go to state 36
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    estructuras_datos              shift and go to state 6
    abrir_archivo                  shift and go to state 8
    lectura_archivo                shift and go to state 9
    queue_variable                 shift and go to state 14
    queue                          shift and go to state 15
    splfixedarray_variable         shift and go to state 16
    splfixedarray                  shift and go to state 17
    if                             shift and go to state 19
    else                           shift and go to state 20
    while                          shift and go to state 21
    for                            shift and go to state 22
    array                          shift and go to state 23
    push                           shift and go to state 24
    pop                            shift and go to state 25

state 8

    (12) cuerpo -> abrir_archivo .

    $end            reduce using rule 12 (cuerpo -> abrir_archivo .)
    RKEY            reduce using rule 12 (cuerpo -> abrir_archivo .)
    ECHO            reduce using rule 12 (cuerpo -> abrir_archivo .)
    PRINT           reduce using rule 12 (cuerpo -> abrir_archivo .)
    VARIABLE        reduce using rule 12 (cuerpo -> abrir_archivo .)
    FUNCTION        reduce using rule 12 (cuerpo -> abrir_archivo .)
    FOPEN           reduce using rule 12 (cuerpo -> abrir_archivo .)
    FSCANF          reduce using rule 12 (cuerpo -> abrir_archivo .)
    IF              reduce using rule 12 (cuerpo -> abrir_archivo .)
    WHILE           reduce using rule 12 (cuerpo -> abrir_archivo .)
    FOR             reduce using rule 12 (cuerpo -> abrir_archivo .)
    LPAREN          reduce using rule 12 (cuerpo -> abrir_archivo .)
    NEW             reduce using rule 12 (cuerpo -> abrir_archivo .)


state 9

    (13) cuerpo -> lectura_archivo .

    $end            reduce using rule 13 (cuerpo -> lectura_archivo .)
    RKEY            reduce using rule 13 (cuerpo -> lectura_archivo .)
    ECHO            reduce using rule 13 (cuerpo -> lectura_archivo .)
    PRINT           reduce using rule 13 (cuerpo -> lectura_archivo .)
    VARIABLE        reduce using rule 13 (cuerpo -> lectura_archivo .)
    FUNCTION        reduce using rule 13 (cuerpo -> lectura_archivo .)
    FOPEN           reduce using rule 13 (cuerpo -> lectura_archivo .)
    FSCANF          reduce using rule 13 (cuerpo -> lectura_archivo .)
    IF              reduce using rule 13 (cuerpo -> lectura_archivo .)
    WHILE           reduce using rule 13 (cuerpo -> lectura_archivo .)
    FOR             reduce using rule 13 (cuerpo -> lectura_archivo .)
    LPAREN          reduce using rule 13 (cuerpo -> lectura_archivo .)
    NEW             reduce using rule 13 (cuerpo -> lectura_archivo .)


state 10

    (14) salida -> ECHO . valor ENDLINE
    (16) valor -> . ARGUMENTO
    (17) valor -> . number
    (18) valor -> . BOOLEAN
    (19) valor -> . string
    (20) valor -> . VARIABLE
    (21) valor -> . estructuras_datos
    (22) valor -> . funciones
    (23) valor -> . valor
    (71) number -> . INTEGER
    (72) number -> . FLOAT
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (89) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN

    ARGUMENTO       shift and go to state 38
    BOOLEAN         shift and go to state 40
    VARIABLE        shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    valor                          shift and go to state 37
    number                         shift and go to state 39
    string                         shift and go to state 41
    estructuras_datos              shift and go to state 43
    funciones                      shift and go to state 44
    array                          shift and go to state 23
    queue                          shift and go to state 15
    splfixedarray                  shift and go to state 17

state 11

    (15) salida -> PRINT . LPAREN valor RPAREN ENDLINE

    LPAREN          shift and go to state 50


state 12

    (86) array -> LPAREN . valorArreglo RPAREN ENDLINE
    (87) valorArreglo -> . valor COMA valorArreglo
    (88) valorArreglo -> . valor
    (16) valor -> . ARGUMENTO
    (17) valor -> . number
    (18) valor -> . BOOLEAN
    (19) valor -> . string
    (20) valor -> . VARIABLE
    (21) valor -> . estructuras_datos
    (22) valor -> . funciones
    (23) valor -> . valor
    (71) number -> . INTEGER
    (72) number -> . FLOAT
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (89) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN

    ARGUMENTO       shift and go to state 38
    BOOLEAN         shift and go to state 40
    VARIABLE        shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    valorArreglo                   shift and go to state 51
    valor                          shift and go to state 52
    number                         shift and go to state 39
    string                         shift and go to state 41
    estructuras_datos              shift and go to state 43
    funciones                      shift and go to state 44
    array                          shift and go to state 23
    queue                          shift and go to state 15
    splfixedarray                  shift and go to state 17

state 13

    (28) asignacion -> VARIABLE . operador_asignacion valor ENDLINE
    (29) asignacion -> VARIABLE . operador_asignacion expresion ENDLINE
    (32) queue_variable -> VARIABLE .
    (35) splfixedarray_variable -> VARIABLE .
    (40) operador_asignacion -> . EQUAL
    (41) operador_asignacion -> . PLUS_EQUAL
    (42) operador_asignacion -> . CONCAT_EQUAL

  ! reduce/reduce conflict for EQUAL resolved using rule 32 (queue_variable -> VARIABLE .)
  ! reduce/reduce conflict for PLUS_EQUAL resolved using rule 32 (queue_variable -> VARIABLE .)
  ! reduce/reduce conflict for CONCAT_EQUAL resolved using rule 32 (queue_variable -> VARIABLE .)
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for PLUS_EQUAL resolved as shift
  ! shift/reduce conflict for CONCAT_EQUAL resolved as shift
    ARROW           reduce using rule 32 (queue_variable -> VARIABLE .)
    EQUAL           shift and go to state 54
    PLUS_EQUAL      shift and go to state 55
    CONCAT_EQUAL    shift and go to state 56

  ! EQUAL           [ reduce using rule 32 (queue_variable -> VARIABLE .) ]
  ! PLUS_EQUAL      [ reduce using rule 32 (queue_variable -> VARIABLE .) ]
  ! CONCAT_EQUAL    [ reduce using rule 32 (queue_variable -> VARIABLE .) ]
  ! EQUAL           [ reduce using rule 35 (splfixedarray_variable -> VARIABLE .) ]
  ! PLUS_EQUAL      [ reduce using rule 35 (splfixedarray_variable -> VARIABLE .) ]
  ! CONCAT_EQUAL    [ reduce using rule 35 (splfixedarray_variable -> VARIABLE .) ]

    operador_asignacion            shift and go to state 53

state 14

    (30) asignacion -> queue_variable . operador_asignacion queue ENDLINE
    (36) push -> queue_variable . ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> queue_variable . ARROW POP LPAREN RPAREN ENDLINE
    (40) operador_asignacion -> . EQUAL
    (41) operador_asignacion -> . PLUS_EQUAL
    (42) operador_asignacion -> . CONCAT_EQUAL

    ARROW           shift and go to state 58
    EQUAL           shift and go to state 54
    PLUS_EQUAL      shift and go to state 55
    CONCAT_EQUAL    shift and go to state 56

    operador_asignacion            shift and go to state 57

state 15

    (44) estructuras_datos -> queue .

    $end            reduce using rule 44 (estructuras_datos -> queue .)
    RKEY            reduce using rule 44 (estructuras_datos -> queue .)
    ECHO            reduce using rule 44 (estructuras_datos -> queue .)
    PRINT           reduce using rule 44 (estructuras_datos -> queue .)
    VARIABLE        reduce using rule 44 (estructuras_datos -> queue .)
    FUNCTION        reduce using rule 44 (estructuras_datos -> queue .)
    FOPEN           reduce using rule 44 (estructuras_datos -> queue .)
    FSCANF          reduce using rule 44 (estructuras_datos -> queue .)
    IF              reduce using rule 44 (estructuras_datos -> queue .)
    WHILE           reduce using rule 44 (estructuras_datos -> queue .)
    FOR             reduce using rule 44 (estructuras_datos -> queue .)
    LPAREN          reduce using rule 44 (estructuras_datos -> queue .)
    NEW             reduce using rule 44 (estructuras_datos -> queue .)
    ENDLINE         reduce using rule 44 (estructuras_datos -> queue .)
    COMA            reduce using rule 44 (estructuras_datos -> queue .)
    RPAREN          reduce using rule 44 (estructuras_datos -> queue .)
    BOOLEAN_AND     reduce using rule 44 (estructuras_datos -> queue .)
    BOOLEAN_OR      reduce using rule 44 (estructuras_datos -> queue .)
    AND             reduce using rule 44 (estructuras_datos -> queue .)
    OR              reduce using rule 44 (estructuras_datos -> queue .)
    XOR             reduce using rule 44 (estructuras_datos -> queue .)
    IS_EQUAL        reduce using rule 44 (estructuras_datos -> queue .)
    IS_GREATER_OR_EQUAL reduce using rule 44 (estructuras_datos -> queue .)
    IS_NOT_EQUAL    reduce using rule 44 (estructuras_datos -> queue .)
    IS_SMALLER_OR_EQUAL reduce using rule 44 (estructuras_datos -> queue .)
    IS_GREATER      reduce using rule 44 (estructuras_datos -> queue .)
    IS_SMALLER      reduce using rule 44 (estructuras_datos -> queue .)


state 16

    (33) asignacion -> splfixedarray_variable . operador_asignacion splfixedarray ENDLINE
    (40) operador_asignacion -> . EQUAL
    (41) operador_asignacion -> . PLUS_EQUAL
    (42) operador_asignacion -> . CONCAT_EQUAL

    EQUAL           shift and go to state 54
    PLUS_EQUAL      shift and go to state 55
    CONCAT_EQUAL    shift and go to state 56

    operador_asignacion            shift and go to state 59

state 17

    (45) estructuras_datos -> splfixedarray .

    $end            reduce using rule 45 (estructuras_datos -> splfixedarray .)
    RKEY            reduce using rule 45 (estructuras_datos -> splfixedarray .)
    ECHO            reduce using rule 45 (estructuras_datos -> splfixedarray .)
    PRINT           reduce using rule 45 (estructuras_datos -> splfixedarray .)
    VARIABLE        reduce using rule 45 (estructuras_datos -> splfixedarray .)
    FUNCTION        reduce using rule 45 (estructuras_datos -> splfixedarray .)
    FOPEN           reduce using rule 45 (estructuras_datos -> splfixedarray .)
    FSCANF          reduce using rule 45 (estructuras_datos -> splfixedarray .)
    IF              reduce using rule 45 (estructuras_datos -> splfixedarray .)
    WHILE           reduce using rule 45 (estructuras_datos -> splfixedarray .)
    FOR             reduce using rule 45 (estructuras_datos -> splfixedarray .)
    LPAREN          reduce using rule 45 (estructuras_datos -> splfixedarray .)
    NEW             reduce using rule 45 (estructuras_datos -> splfixedarray .)
    ENDLINE         reduce using rule 45 (estructuras_datos -> splfixedarray .)
    COMA            reduce using rule 45 (estructuras_datos -> splfixedarray .)
    RPAREN          reduce using rule 45 (estructuras_datos -> splfixedarray .)
    BOOLEAN_AND     reduce using rule 45 (estructuras_datos -> splfixedarray .)
    BOOLEAN_OR      reduce using rule 45 (estructuras_datos -> splfixedarray .)
    AND             reduce using rule 45 (estructuras_datos -> splfixedarray .)
    OR              reduce using rule 45 (estructuras_datos -> splfixedarray .)
    XOR             reduce using rule 45 (estructuras_datos -> splfixedarray .)
    IS_EQUAL        reduce using rule 45 (estructuras_datos -> splfixedarray .)
    IS_GREATER_OR_EQUAL reduce using rule 45 (estructuras_datos -> splfixedarray .)
    IS_NOT_EQUAL    reduce using rule 45 (estructuras_datos -> splfixedarray .)
    IS_SMALLER_OR_EQUAL reduce using rule 45 (estructuras_datos -> splfixedarray .)
    IS_GREATER      reduce using rule 45 (estructuras_datos -> splfixedarray .)
    IS_SMALLER      reduce using rule 45 (estructuras_datos -> splfixedarray .)


state 18

    (27) function -> FUNCTION . ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY

    ARGUMENTO       shift and go to state 60


state 19

    (53) estructuras_control -> if .
    (59) else -> if . ELSE LKEY cuerpo RKEY

    ECHO            reduce using rule 53 (estructuras_control -> if .)
    PRINT           reduce using rule 53 (estructuras_control -> if .)
    VARIABLE        reduce using rule 53 (estructuras_control -> if .)
    FUNCTION        reduce using rule 53 (estructuras_control -> if .)
    FOPEN           reduce using rule 53 (estructuras_control -> if .)
    FSCANF          reduce using rule 53 (estructuras_control -> if .)
    IF              reduce using rule 53 (estructuras_control -> if .)
    WHILE           reduce using rule 53 (estructuras_control -> if .)
    FOR             reduce using rule 53 (estructuras_control -> if .)
    LPAREN          reduce using rule 53 (estructuras_control -> if .)
    NEW             reduce using rule 53 (estructuras_control -> if .)
    $end            reduce using rule 53 (estructuras_control -> if .)
    RKEY            reduce using rule 53 (estructuras_control -> if .)
    ELSE            shift and go to state 61


state 20

    (54) estructuras_control -> else .

    ECHO            reduce using rule 54 (estructuras_control -> else .)
    PRINT           reduce using rule 54 (estructuras_control -> else .)
    VARIABLE        reduce using rule 54 (estructuras_control -> else .)
    FUNCTION        reduce using rule 54 (estructuras_control -> else .)
    FOPEN           reduce using rule 54 (estructuras_control -> else .)
    FSCANF          reduce using rule 54 (estructuras_control -> else .)
    IF              reduce using rule 54 (estructuras_control -> else .)
    WHILE           reduce using rule 54 (estructuras_control -> else .)
    FOR             reduce using rule 54 (estructuras_control -> else .)
    LPAREN          reduce using rule 54 (estructuras_control -> else .)
    NEW             reduce using rule 54 (estructuras_control -> else .)
    $end            reduce using rule 54 (estructuras_control -> else .)
    RKEY            reduce using rule 54 (estructuras_control -> else .)


state 21

    (55) estructuras_control -> while .

    ECHO            reduce using rule 55 (estructuras_control -> while .)
    PRINT           reduce using rule 55 (estructuras_control -> while .)
    VARIABLE        reduce using rule 55 (estructuras_control -> while .)
    FUNCTION        reduce using rule 55 (estructuras_control -> while .)
    FOPEN           reduce using rule 55 (estructuras_control -> while .)
    FSCANF          reduce using rule 55 (estructuras_control -> while .)
    IF              reduce using rule 55 (estructuras_control -> while .)
    WHILE           reduce using rule 55 (estructuras_control -> while .)
    FOR             reduce using rule 55 (estructuras_control -> while .)
    LPAREN          reduce using rule 55 (estructuras_control -> while .)
    NEW             reduce using rule 55 (estructuras_control -> while .)
    $end            reduce using rule 55 (estructuras_control -> while .)
    RKEY            reduce using rule 55 (estructuras_control -> while .)


state 22

    (56) estructuras_control -> for .

    ECHO            reduce using rule 56 (estructuras_control -> for .)
    PRINT           reduce using rule 56 (estructuras_control -> for .)
    VARIABLE        reduce using rule 56 (estructuras_control -> for .)
    FUNCTION        reduce using rule 56 (estructuras_control -> for .)
    FOPEN           reduce using rule 56 (estructuras_control -> for .)
    FSCANF          reduce using rule 56 (estructuras_control -> for .)
    IF              reduce using rule 56 (estructuras_control -> for .)
    WHILE           reduce using rule 56 (estructuras_control -> for .)
    FOR             reduce using rule 56 (estructuras_control -> for .)
    LPAREN          reduce using rule 56 (estructuras_control -> for .)
    NEW             reduce using rule 56 (estructuras_control -> for .)
    $end            reduce using rule 56 (estructuras_control -> for .)
    RKEY            reduce using rule 56 (estructuras_control -> for .)


state 23

    (43) estructuras_datos -> array .

    $end            reduce using rule 43 (estructuras_datos -> array .)
    RKEY            reduce using rule 43 (estructuras_datos -> array .)
    ECHO            reduce using rule 43 (estructuras_datos -> array .)
    PRINT           reduce using rule 43 (estructuras_datos -> array .)
    VARIABLE        reduce using rule 43 (estructuras_datos -> array .)
    FUNCTION        reduce using rule 43 (estructuras_datos -> array .)
    FOPEN           reduce using rule 43 (estructuras_datos -> array .)
    FSCANF          reduce using rule 43 (estructuras_datos -> array .)
    IF              reduce using rule 43 (estructuras_datos -> array .)
    WHILE           reduce using rule 43 (estructuras_datos -> array .)
    FOR             reduce using rule 43 (estructuras_datos -> array .)
    LPAREN          reduce using rule 43 (estructuras_datos -> array .)
    NEW             reduce using rule 43 (estructuras_datos -> array .)
    ENDLINE         reduce using rule 43 (estructuras_datos -> array .)
    COMA            reduce using rule 43 (estructuras_datos -> array .)
    RPAREN          reduce using rule 43 (estructuras_datos -> array .)
    BOOLEAN_AND     reduce using rule 43 (estructuras_datos -> array .)
    BOOLEAN_OR      reduce using rule 43 (estructuras_datos -> array .)
    AND             reduce using rule 43 (estructuras_datos -> array .)
    OR              reduce using rule 43 (estructuras_datos -> array .)
    XOR             reduce using rule 43 (estructuras_datos -> array .)
    IS_EQUAL        reduce using rule 43 (estructuras_datos -> array .)
    IS_GREATER_OR_EQUAL reduce using rule 43 (estructuras_datos -> array .)
    IS_NOT_EQUAL    reduce using rule 43 (estructuras_datos -> array .)
    IS_SMALLER_OR_EQUAL reduce using rule 43 (estructuras_datos -> array .)
    IS_GREATER      reduce using rule 43 (estructuras_datos -> array .)
    IS_SMALLER      reduce using rule 43 (estructuras_datos -> array .)


state 24

    (38) metodos -> push .

    ECHO            reduce using rule 38 (metodos -> push .)
    PRINT           reduce using rule 38 (metodos -> push .)
    VARIABLE        reduce using rule 38 (metodos -> push .)
    FUNCTION        reduce using rule 38 (metodos -> push .)
    FOPEN           reduce using rule 38 (metodos -> push .)
    FSCANF          reduce using rule 38 (metodos -> push .)
    IF              reduce using rule 38 (metodos -> push .)
    WHILE           reduce using rule 38 (metodos -> push .)
    FOR             reduce using rule 38 (metodos -> push .)
    LPAREN          reduce using rule 38 (metodos -> push .)
    NEW             reduce using rule 38 (metodos -> push .)
    $end            reduce using rule 38 (metodos -> push .)
    RKEY            reduce using rule 38 (metodos -> push .)


state 25

    (39) metodos -> pop .

    ECHO            reduce using rule 39 (metodos -> pop .)
    PRINT           reduce using rule 39 (metodos -> pop .)
    VARIABLE        reduce using rule 39 (metodos -> pop .)
    FUNCTION        reduce using rule 39 (metodos -> pop .)
    FOPEN           reduce using rule 39 (metodos -> pop .)
    FSCANF          reduce using rule 39 (metodos -> pop .)
    IF              reduce using rule 39 (metodos -> pop .)
    WHILE           reduce using rule 39 (metodos -> pop .)
    FOR             reduce using rule 39 (metodos -> pop .)
    LPAREN          reduce using rule 39 (metodos -> pop .)
    NEW             reduce using rule 39 (metodos -> pop .)
    $end            reduce using rule 39 (metodos -> pop .)
    RKEY            reduce using rule 39 (metodos -> pop .)


state 26

    (81) abrir_archivo -> FOPEN . LPAREN string RPAREN
    (82) abrir_archivo -> FOPEN . LPAREN string RPAREN ENDLINE

    LPAREN          shift and go to state 62


state 27

    (83) lectura_archivo -> FSCANF . LPAREN abrir_archivo COMA string RPAREN ENDLINE

    LPAREN          shift and go to state 63


state 28

    (58) if -> IF . LPAREN expresion RPAREN LKEY cuerpo RKEY

    LPAREN          shift and go to state 64


state 29

    (84) while -> WHILE . LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> WHILE . LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY

    LPAREN          shift and go to state 65


state 30

    (101) for -> FOR . LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    LPAREN          shift and go to state 66


state 31

    (31) queue -> NEW . SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> NEW . SPLFIXEDARRAY LPAREN INTEGER RPAREN

    SPLQUEUE        shift and go to state 67
    SPLFIXEDARRAY   shift and go to state 68


state 32

    (2) cuerpo -> salida cuerpo .

    $end            reduce using rule 2 (cuerpo -> salida cuerpo .)
    RKEY            reduce using rule 2 (cuerpo -> salida cuerpo .)
    ECHO            reduce using rule 2 (cuerpo -> salida cuerpo .)
    PRINT           reduce using rule 2 (cuerpo -> salida cuerpo .)
    VARIABLE        reduce using rule 2 (cuerpo -> salida cuerpo .)
    FUNCTION        reduce using rule 2 (cuerpo -> salida cuerpo .)
    FOPEN           reduce using rule 2 (cuerpo -> salida cuerpo .)
    FSCANF          reduce using rule 2 (cuerpo -> salida cuerpo .)
    IF              reduce using rule 2 (cuerpo -> salida cuerpo .)
    WHILE           reduce using rule 2 (cuerpo -> salida cuerpo .)
    FOR             reduce using rule 2 (cuerpo -> salida cuerpo .)
    LPAREN          reduce using rule 2 (cuerpo -> salida cuerpo .)
    NEW             reduce using rule 2 (cuerpo -> salida cuerpo .)


state 33

    (4) cuerpo -> asignacion cuerpo .

    $end            reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    RKEY            reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    ECHO            reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    PRINT           reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    VARIABLE        reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    FUNCTION        reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    FOPEN           reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    FSCANF          reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    IF              reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    WHILE           reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    FOR             reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    LPAREN          reduce using rule 4 (cuerpo -> asignacion cuerpo .)
    NEW             reduce using rule 4 (cuerpo -> asignacion cuerpo .)


state 34

    (6) cuerpo -> function cuerpo .

    $end            reduce using rule 6 (cuerpo -> function cuerpo .)
    RKEY            reduce using rule 6 (cuerpo -> function cuerpo .)
    ECHO            reduce using rule 6 (cuerpo -> function cuerpo .)
    PRINT           reduce using rule 6 (cuerpo -> function cuerpo .)
    VARIABLE        reduce using rule 6 (cuerpo -> function cuerpo .)
    FUNCTION        reduce using rule 6 (cuerpo -> function cuerpo .)
    FOPEN           reduce using rule 6 (cuerpo -> function cuerpo .)
    FSCANF          reduce using rule 6 (cuerpo -> function cuerpo .)
    IF              reduce using rule 6 (cuerpo -> function cuerpo .)
    WHILE           reduce using rule 6 (cuerpo -> function cuerpo .)
    FOR             reduce using rule 6 (cuerpo -> function cuerpo .)
    LPAREN          reduce using rule 6 (cuerpo -> function cuerpo .)
    NEW             reduce using rule 6 (cuerpo -> function cuerpo .)


state 35

    (8) cuerpo -> estructuras_control cuerpo .

    $end            reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    RKEY            reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    ECHO            reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    PRINT           reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    VARIABLE        reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    FUNCTION        reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    FOPEN           reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    FSCANF          reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    IF              reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    WHILE           reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    FOR             reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    LPAREN          reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)
    NEW             reduce using rule 8 (cuerpo -> estructuras_control cuerpo .)


state 36

    (11) cuerpo -> metodos cuerpo .

    $end            reduce using rule 11 (cuerpo -> metodos cuerpo .)
    RKEY            reduce using rule 11 (cuerpo -> metodos cuerpo .)
    ECHO            reduce using rule 11 (cuerpo -> metodos cuerpo .)
    PRINT           reduce using rule 11 (cuerpo -> metodos cuerpo .)
    VARIABLE        reduce using rule 11 (cuerpo -> metodos cuerpo .)
    FUNCTION        reduce using rule 11 (cuerpo -> metodos cuerpo .)
    FOPEN           reduce using rule 11 (cuerpo -> metodos cuerpo .)
    FSCANF          reduce using rule 11 (cuerpo -> metodos cuerpo .)
    IF              reduce using rule 11 (cuerpo -> metodos cuerpo .)
    WHILE           reduce using rule 11 (cuerpo -> metodos cuerpo .)
    FOR             reduce using rule 11 (cuerpo -> metodos cuerpo .)
    LPAREN          reduce using rule 11 (cuerpo -> metodos cuerpo .)
    NEW             reduce using rule 11 (cuerpo -> metodos cuerpo .)


state 37

    (14) salida -> ECHO valor . ENDLINE
    (23) valor -> valor .
    (89) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

  ! shift/reduce conflict for ENDLINE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ENDLINE         shift and go to state 69
    LPAREN          shift and go to state 70

  ! ENDLINE         [ reduce using rule 23 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 23 (valor -> valor .) ]


state 38

    (16) valor -> ARGUMENTO .

    ENDLINE         reduce using rule 16 (valor -> ARGUMENTO .)
    LPAREN          reduce using rule 16 (valor -> ARGUMENTO .)
    COMA            reduce using rule 16 (valor -> ARGUMENTO .)
    RPAREN          reduce using rule 16 (valor -> ARGUMENTO .)
    BOOLEAN_AND     reduce using rule 16 (valor -> ARGUMENTO .)
    BOOLEAN_OR      reduce using rule 16 (valor -> ARGUMENTO .)
    AND             reduce using rule 16 (valor -> ARGUMENTO .)
    OR              reduce using rule 16 (valor -> ARGUMENTO .)
    XOR             reduce using rule 16 (valor -> ARGUMENTO .)
    IS_EQUAL        reduce using rule 16 (valor -> ARGUMENTO .)
    IS_GREATER_OR_EQUAL reduce using rule 16 (valor -> ARGUMENTO .)
    IS_NOT_EQUAL    reduce using rule 16 (valor -> ARGUMENTO .)
    IS_SMALLER_OR_EQUAL reduce using rule 16 (valor -> ARGUMENTO .)
    IS_GREATER      reduce using rule 16 (valor -> ARGUMENTO .)
    IS_SMALLER      reduce using rule 16 (valor -> ARGUMENTO .)


state 39

    (17) valor -> number .

    ENDLINE         reduce using rule 17 (valor -> number .)
    LPAREN          reduce using rule 17 (valor -> number .)
    COMA            reduce using rule 17 (valor -> number .)
    RPAREN          reduce using rule 17 (valor -> number .)
    IS_EQUAL        reduce using rule 17 (valor -> number .)
    IS_GREATER_OR_EQUAL reduce using rule 17 (valor -> number .)
    IS_NOT_EQUAL    reduce using rule 17 (valor -> number .)
    IS_SMALLER_OR_EQUAL reduce using rule 17 (valor -> number .)
    IS_GREATER      reduce using rule 17 (valor -> number .)
    IS_SMALLER      reduce using rule 17 (valor -> number .)
    BOOLEAN_AND     reduce using rule 17 (valor -> number .)
    BOOLEAN_OR      reduce using rule 17 (valor -> number .)
    AND             reduce using rule 17 (valor -> number .)
    OR              reduce using rule 17 (valor -> number .)
    XOR             reduce using rule 17 (valor -> number .)


state 40

    (18) valor -> BOOLEAN .

    ENDLINE         reduce using rule 18 (valor -> BOOLEAN .)
    LPAREN          reduce using rule 18 (valor -> BOOLEAN .)
    COMA            reduce using rule 18 (valor -> BOOLEAN .)
    RPAREN          reduce using rule 18 (valor -> BOOLEAN .)
    BOOLEAN_AND     reduce using rule 18 (valor -> BOOLEAN .)
    BOOLEAN_OR      reduce using rule 18 (valor -> BOOLEAN .)
    AND             reduce using rule 18 (valor -> BOOLEAN .)
    OR              reduce using rule 18 (valor -> BOOLEAN .)
    XOR             reduce using rule 18 (valor -> BOOLEAN .)
    IS_EQUAL        reduce using rule 18 (valor -> BOOLEAN .)
    IS_GREATER_OR_EQUAL reduce using rule 18 (valor -> BOOLEAN .)
    IS_NOT_EQUAL    reduce using rule 18 (valor -> BOOLEAN .)
    IS_SMALLER_OR_EQUAL reduce using rule 18 (valor -> BOOLEAN .)
    IS_GREATER      reduce using rule 18 (valor -> BOOLEAN .)
    IS_SMALLER      reduce using rule 18 (valor -> BOOLEAN .)


state 41

    (19) valor -> string .

    ENDLINE         reduce using rule 19 (valor -> string .)
    LPAREN          reduce using rule 19 (valor -> string .)
    COMA            reduce using rule 19 (valor -> string .)
    RPAREN          reduce using rule 19 (valor -> string .)
    BOOLEAN_AND     reduce using rule 19 (valor -> string .)
    BOOLEAN_OR      reduce using rule 19 (valor -> string .)
    AND             reduce using rule 19 (valor -> string .)
    OR              reduce using rule 19 (valor -> string .)
    XOR             reduce using rule 19 (valor -> string .)
    IS_EQUAL        reduce using rule 19 (valor -> string .)
    IS_GREATER_OR_EQUAL reduce using rule 19 (valor -> string .)
    IS_NOT_EQUAL    reduce using rule 19 (valor -> string .)
    IS_SMALLER_OR_EQUAL reduce using rule 19 (valor -> string .)
    IS_GREATER      reduce using rule 19 (valor -> string .)
    IS_SMALLER      reduce using rule 19 (valor -> string .)


state 42

    (20) valor -> VARIABLE .

    ENDLINE         reduce using rule 20 (valor -> VARIABLE .)
    LPAREN          reduce using rule 20 (valor -> VARIABLE .)
    COMA            reduce using rule 20 (valor -> VARIABLE .)
    RPAREN          reduce using rule 20 (valor -> VARIABLE .)
    BOOLEAN_AND     reduce using rule 20 (valor -> VARIABLE .)
    BOOLEAN_OR      reduce using rule 20 (valor -> VARIABLE .)
    AND             reduce using rule 20 (valor -> VARIABLE .)
    OR              reduce using rule 20 (valor -> VARIABLE .)
    XOR             reduce using rule 20 (valor -> VARIABLE .)
    IS_EQUAL        reduce using rule 20 (valor -> VARIABLE .)
    IS_GREATER_OR_EQUAL reduce using rule 20 (valor -> VARIABLE .)
    IS_NOT_EQUAL    reduce using rule 20 (valor -> VARIABLE .)
    IS_SMALLER_OR_EQUAL reduce using rule 20 (valor -> VARIABLE .)
    IS_GREATER      reduce using rule 20 (valor -> VARIABLE .)
    IS_SMALLER      reduce using rule 20 (valor -> VARIABLE .)


state 43

    (21) valor -> estructuras_datos .

    ENDLINE         reduce using rule 21 (valor -> estructuras_datos .)
    LPAREN          reduce using rule 21 (valor -> estructuras_datos .)
    COMA            reduce using rule 21 (valor -> estructuras_datos .)
    RPAREN          reduce using rule 21 (valor -> estructuras_datos .)
    BOOLEAN_AND     reduce using rule 21 (valor -> estructuras_datos .)
    BOOLEAN_OR      reduce using rule 21 (valor -> estructuras_datos .)
    AND             reduce using rule 21 (valor -> estructuras_datos .)
    OR              reduce using rule 21 (valor -> estructuras_datos .)
    XOR             reduce using rule 21 (valor -> estructuras_datos .)
    IS_EQUAL        reduce using rule 21 (valor -> estructuras_datos .)
    IS_GREATER_OR_EQUAL reduce using rule 21 (valor -> estructuras_datos .)
    IS_NOT_EQUAL    reduce using rule 21 (valor -> estructuras_datos .)
    IS_SMALLER_OR_EQUAL reduce using rule 21 (valor -> estructuras_datos .)
    IS_GREATER      reduce using rule 21 (valor -> estructuras_datos .)
    IS_SMALLER      reduce using rule 21 (valor -> estructuras_datos .)


state 44

    (22) valor -> funciones .

    ENDLINE         reduce using rule 22 (valor -> funciones .)
    LPAREN          reduce using rule 22 (valor -> funciones .)
    COMA            reduce using rule 22 (valor -> funciones .)
    RPAREN          reduce using rule 22 (valor -> funciones .)
    BOOLEAN_AND     reduce using rule 22 (valor -> funciones .)
    BOOLEAN_OR      reduce using rule 22 (valor -> funciones .)
    AND             reduce using rule 22 (valor -> funciones .)
    OR              reduce using rule 22 (valor -> funciones .)
    XOR             reduce using rule 22 (valor -> funciones .)
    IS_EQUAL        reduce using rule 22 (valor -> funciones .)
    IS_GREATER_OR_EQUAL reduce using rule 22 (valor -> funciones .)
    IS_NOT_EQUAL    reduce using rule 22 (valor -> funciones .)
    IS_SMALLER_OR_EQUAL reduce using rule 22 (valor -> funciones .)
    IS_GREATER      reduce using rule 22 (valor -> funciones .)
    IS_SMALLER      reduce using rule 22 (valor -> funciones .)


state 45

    (71) number -> INTEGER .

    ENDLINE         reduce using rule 71 (number -> INTEGER .)
    LPAREN          reduce using rule 71 (number -> INTEGER .)
    COMA            reduce using rule 71 (number -> INTEGER .)
    RPAREN          reduce using rule 71 (number -> INTEGER .)
    ADDITION        reduce using rule 71 (number -> INTEGER .)
    SUBTRACTION     reduce using rule 71 (number -> INTEGER .)
    MULTIPLICATION  reduce using rule 71 (number -> INTEGER .)
    DIVISION        reduce using rule 71 (number -> INTEGER .)
    MODULO          reduce using rule 71 (number -> INTEGER .)
    EXPONENTIATION  reduce using rule 71 (number -> INTEGER .)
    BOOLEAN_AND     reduce using rule 71 (number -> INTEGER .)
    BOOLEAN_OR      reduce using rule 71 (number -> INTEGER .)
    AND             reduce using rule 71 (number -> INTEGER .)
    OR              reduce using rule 71 (number -> INTEGER .)
    XOR             reduce using rule 71 (number -> INTEGER .)
    IS_EQUAL        reduce using rule 71 (number -> INTEGER .)
    IS_GREATER_OR_EQUAL reduce using rule 71 (number -> INTEGER .)
    IS_NOT_EQUAL    reduce using rule 71 (number -> INTEGER .)
    IS_SMALLER_OR_EQUAL reduce using rule 71 (number -> INTEGER .)
    IS_GREATER      reduce using rule 71 (number -> INTEGER .)
    IS_SMALLER      reduce using rule 71 (number -> INTEGER .)


state 46

    (72) number -> FLOAT .

    ENDLINE         reduce using rule 72 (number -> FLOAT .)
    LPAREN          reduce using rule 72 (number -> FLOAT .)
    COMA            reduce using rule 72 (number -> FLOAT .)
    RPAREN          reduce using rule 72 (number -> FLOAT .)
    ADDITION        reduce using rule 72 (number -> FLOAT .)
    SUBTRACTION     reduce using rule 72 (number -> FLOAT .)
    MULTIPLICATION  reduce using rule 72 (number -> FLOAT .)
    DIVISION        reduce using rule 72 (number -> FLOAT .)
    MODULO          reduce using rule 72 (number -> FLOAT .)
    EXPONENTIATION  reduce using rule 72 (number -> FLOAT .)
    BOOLEAN_AND     reduce using rule 72 (number -> FLOAT .)
    BOOLEAN_OR      reduce using rule 72 (number -> FLOAT .)
    AND             reduce using rule 72 (number -> FLOAT .)
    OR              reduce using rule 72 (number -> FLOAT .)
    XOR             reduce using rule 72 (number -> FLOAT .)
    IS_EQUAL        reduce using rule 72 (number -> FLOAT .)
    IS_GREATER_OR_EQUAL reduce using rule 72 (number -> FLOAT .)
    IS_NOT_EQUAL    reduce using rule 72 (number -> FLOAT .)
    IS_SMALLER_OR_EQUAL reduce using rule 72 (number -> FLOAT .)
    IS_GREATER      reduce using rule 72 (number -> FLOAT .)
    IS_SMALLER      reduce using rule 72 (number -> FLOAT .)


state 47

    (24) string -> STRING .

    ENDLINE         reduce using rule 24 (string -> STRING .)
    LPAREN          reduce using rule 24 (string -> STRING .)
    COMA            reduce using rule 24 (string -> STRING .)
    RPAREN          reduce using rule 24 (string -> STRING .)
    BOOLEAN_AND     reduce using rule 24 (string -> STRING .)
    BOOLEAN_OR      reduce using rule 24 (string -> STRING .)
    AND             reduce using rule 24 (string -> STRING .)
    OR              reduce using rule 24 (string -> STRING .)
    XOR             reduce using rule 24 (string -> STRING .)
    IS_EQUAL        reduce using rule 24 (string -> STRING .)
    IS_GREATER_OR_EQUAL reduce using rule 24 (string -> STRING .)
    IS_NOT_EQUAL    reduce using rule 24 (string -> STRING .)
    IS_SMALLER_OR_EQUAL reduce using rule 24 (string -> STRING .)
    IS_GREATER      reduce using rule 24 (string -> STRING .)
    IS_SMALLER      reduce using rule 24 (string -> STRING .)


state 48

    (25) string -> COMILLA_DOBLE . STRING COMILLA_DOBLE

    STRING          shift and go to state 71


state 49

    (26) string -> COMILLA_SIMPLE . STRING COMILLA_SIMPLE

    STRING          shift and go to state 72


state 50

    (15) salida -> PRINT LPAREN . valor RPAREN ENDLINE
    (16) valor -> . ARGUMENTO
    (17) valor -> . number
    (18) valor -> . BOOLEAN
    (19) valor -> . string
    (20) valor -> . VARIABLE
    (21) valor -> . estructuras_datos
    (22) valor -> . funciones
    (23) valor -> . valor
    (71) number -> . INTEGER
    (72) number -> . FLOAT
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (89) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN

    ARGUMENTO       shift and go to state 38
    BOOLEAN         shift and go to state 40
    VARIABLE        shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    valor                          shift and go to state 73
    number                         shift and go to state 39
    string                         shift and go to state 41
    estructuras_datos              shift and go to state 43
    funciones                      shift and go to state 44
    array                          shift and go to state 23
    queue                          shift and go to state 15
    splfixedarray                  shift and go to state 17

state 51

    (86) array -> LPAREN valorArreglo . RPAREN ENDLINE

    RPAREN          shift and go to state 74


state 52

    (87) valorArreglo -> valor . COMA valorArreglo
    (88) valorArreglo -> valor .
    (23) valor -> valor .
    (89) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

  ! shift/reduce conflict for COMA resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 23 (valor -> valor .)
  ! shift/reduce conflict for LPAREN resolved as shift
    COMA            shift and go to state 75
    RPAREN          reduce using rule 23 (valor -> valor .)
    LPAREN          shift and go to state 70

  ! RPAREN          [ reduce using rule 88 (valorArreglo -> valor .) ]
  ! COMA            [ reduce using rule 23 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 23 (valor -> valor .) ]


state 53

    (28) asignacion -> VARIABLE operador_asignacion . valor ENDLINE
    (29) asignacion -> VARIABLE operador_asignacion . expresion ENDLINE
    (16) valor -> . ARGUMENTO
    (17) valor -> . number
    (18) valor -> . BOOLEAN
    (19) valor -> . string
    (20) valor -> . VARIABLE
    (21) valor -> . estructuras_datos
    (22) valor -> . funciones
    (23) valor -> . valor
    (60) expresion -> . expresiones_logicas
    (61) expresion -> . expresion_aritmetica
    (71) number -> . INTEGER
    (72) number -> . FLOAT
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (89) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (62) expresiones_logicas -> . valor
    (63) expresiones_logicas -> . valor operador expresiones_logicas
    (79) expresion_aritmetica -> . number
    (80) expresion_aritmetica -> . number operador_aritmetico expresion_aritmetica
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN

    ARGUMENTO       shift and go to state 38
    BOOLEAN         shift and go to state 40
    VARIABLE        shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    valor                          shift and go to state 76
    expresion                      shift and go to state 77
    number                         shift and go to state 78
    string                         shift and go to state 41
    estructuras_datos              shift and go to state 43
    funciones                      shift and go to state 44
    expresiones_logicas            shift and go to state 79
    expresion_aritmetica           shift and go to state 80
    array                          shift and go to state 23
    queue                          shift and go to state 15
    splfixedarray                  shift and go to state 17

state 54

    (40) operador_asignacion -> EQUAL .

    ARGUMENTO       reduce using rule 40 (operador_asignacion -> EQUAL .)
    BOOLEAN         reduce using rule 40 (operador_asignacion -> EQUAL .)
    VARIABLE        reduce using rule 40 (operador_asignacion -> EQUAL .)
    INTEGER         reduce using rule 40 (operador_asignacion -> EQUAL .)
    FLOAT           reduce using rule 40 (operador_asignacion -> EQUAL .)
    STRING          reduce using rule 40 (operador_asignacion -> EQUAL .)
    COMILLA_DOBLE   reduce using rule 40 (operador_asignacion -> EQUAL .)
    COMILLA_SIMPLE  reduce using rule 40 (operador_asignacion -> EQUAL .)
    LPAREN          reduce using rule 40 (operador_asignacion -> EQUAL .)
    NEW             reduce using rule 40 (operador_asignacion -> EQUAL .)


state 55

    (41) operador_asignacion -> PLUS_EQUAL .

    ARGUMENTO       reduce using rule 41 (operador_asignacion -> PLUS_EQUAL .)
    BOOLEAN         reduce using rule 41 (operador_asignacion -> PLUS_EQUAL .)
    VARIABLE        reduce using rule 41 (operador_asignacion -> PLUS_EQUAL .)
    INTEGER         reduce using rule 41 (operador_asignacion -> PLUS_EQUAL .)
    FLOAT           reduce using rule 41 (operador_asignacion -> PLUS_EQUAL .)
    STRING          reduce using rule 41 (operador_asignacion -> PLUS_EQUAL .)
    COMILLA_DOBLE   reduce using rule 41 (operador_asignacion -> PLUS_EQUAL .)
    COMILLA_SIMPLE  reduce using rule 41 (operador_asignacion -> PLUS_EQUAL .)
    LPAREN          reduce using rule 41 (operador_asignacion -> PLUS_EQUAL .)
    NEW             reduce using rule 41 (operador_asignacion -> PLUS_EQUAL .)


state 56

    (42) operador_asignacion -> CONCAT_EQUAL .

    ARGUMENTO       reduce using rule 42 (operador_asignacion -> CONCAT_EQUAL .)
    BOOLEAN         reduce using rule 42 (operador_asignacion -> CONCAT_EQUAL .)
    VARIABLE        reduce using rule 42 (operador_asignacion -> CONCAT_EQUAL .)
    INTEGER         reduce using rule 42 (operador_asignacion -> CONCAT_EQUAL .)
    FLOAT           reduce using rule 42 (operador_asignacion -> CONCAT_EQUAL .)
    STRING          reduce using rule 42 (operador_asignacion -> CONCAT_EQUAL .)
    COMILLA_DOBLE   reduce using rule 42 (operador_asignacion -> CONCAT_EQUAL .)
    COMILLA_SIMPLE  reduce using rule 42 (operador_asignacion -> CONCAT_EQUAL .)
    LPAREN          reduce using rule 42 (operador_asignacion -> CONCAT_EQUAL .)
    NEW             reduce using rule 42 (operador_asignacion -> CONCAT_EQUAL .)


state 57

    (30) asignacion -> queue_variable operador_asignacion . queue ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN

    NEW             shift and go to state 82

    queue                          shift and go to state 81

state 58

    (36) push -> queue_variable ARROW . PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> queue_variable ARROW . POP LPAREN RPAREN ENDLINE

    PUSH            shift and go to state 83
    POP             shift and go to state 84


state 59

    (33) asignacion -> splfixedarray_variable operador_asignacion . splfixedarray ENDLINE
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN

    NEW             shift and go to state 86

    splfixedarray                  shift and go to state 85

state 60

    (27) function -> FUNCTION ARGUMENTO . LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY

    LPAREN          shift and go to state 87


state 61

    (59) else -> if ELSE . LKEY cuerpo RKEY

    LKEY            shift and go to state 88


state 62

    (81) abrir_archivo -> FOPEN LPAREN . string RPAREN
    (82) abrir_archivo -> FOPEN LPAREN . string RPAREN ENDLINE
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE

    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49

    string                         shift and go to state 89

state 63

    (83) lectura_archivo -> FSCANF LPAREN . abrir_archivo COMA string RPAREN ENDLINE
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE

    FOPEN           shift and go to state 26

    abrir_archivo                  shift and go to state 90

state 64

    (58) if -> IF LPAREN . expresion RPAREN LKEY cuerpo RKEY
    (60) expresion -> . expresiones_logicas
    (61) expresion -> . expresion_aritmetica
    (62) expresiones_logicas -> . valor
    (63) expresiones_logicas -> . valor operador expresiones_logicas
    (79) expresion_aritmetica -> . number
    (80) expresion_aritmetica -> . number operador_aritmetico expresion_aritmetica
    (16) valor -> . ARGUMENTO
    (17) valor -> . number
    (18) valor -> . BOOLEAN
    (19) valor -> . string
    (20) valor -> . VARIABLE
    (21) valor -> . estructuras_datos
    (22) valor -> . funciones
    (23) valor -> . valor
    (71) number -> . INTEGER
    (72) number -> . FLOAT
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (89) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN

    ARGUMENTO       shift and go to state 38
    BOOLEAN         shift and go to state 40
    VARIABLE        shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    expresion                      shift and go to state 91
    expresiones_logicas            shift and go to state 79
    expresion_aritmetica           shift and go to state 80
    valor                          shift and go to state 92
    number                         shift and go to state 93
    string                         shift and go to state 41
    estructuras_datos              shift and go to state 43
    funciones                      shift and go to state 44
    array                          shift and go to state 23
    queue                          shift and go to state 15
    splfixedarray                  shift and go to state 17

state 65

    (84) while -> WHILE LPAREN . valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> WHILE LPAREN . valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (16) valor -> . ARGUMENTO
    (17) valor -> . number
    (18) valor -> . BOOLEAN
    (19) valor -> . string
    (20) valor -> . VARIABLE
    (21) valor -> . estructuras_datos
    (22) valor -> . funciones
    (23) valor -> . valor
    (71) number -> . INTEGER
    (72) number -> . FLOAT
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (89) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN

    ARGUMENTO       shift and go to state 38
    BOOLEAN         shift and go to state 40
    VARIABLE        shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    valor                          shift and go to state 94
    number                         shift and go to state 39
    string                         shift and go to state 41
    estructuras_datos              shift and go to state 43
    funciones                      shift and go to state 44
    array                          shift and go to state 23
    queue                          shift and go to state 15
    splfixedarray                  shift and go to state 17

state 66

    (101) for -> FOR LPAREN . VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    VARIABLE        shift and go to state 95


state 67

    (31) queue -> NEW SPLQUEUE . LPAREN RPAREN

    LPAREN          shift and go to state 96


state 68

    (34) splfixedarray -> NEW SPLFIXEDARRAY . LPAREN INTEGER RPAREN

    LPAREN          shift and go to state 97


state 69

    (14) salida -> ECHO valor ENDLINE .

    ECHO            reduce using rule 14 (salida -> ECHO valor ENDLINE .)
    PRINT           reduce using rule 14 (salida -> ECHO valor ENDLINE .)
    VARIABLE        reduce using rule 14 (salida -> ECHO valor ENDLINE .)
    FUNCTION        reduce using rule 14 (salida -> ECHO valor ENDLINE .)
    FOPEN           reduce using rule 14 (salida -> ECHO valor ENDLINE .)
    FSCANF          reduce using rule 14 (salida -> ECHO valor ENDLINE .)
    IF              reduce using rule 14 (salida -> ECHO valor ENDLINE .)
    WHILE           reduce using rule 14 (salida -> ECHO valor ENDLINE .)
    FOR             reduce using rule 14 (salida -> ECHO valor ENDLINE .)
    LPAREN          reduce using rule 14 (salida -> ECHO valor ENDLINE .)
    NEW             reduce using rule 14 (salida -> ECHO valor ENDLINE .)
    $end            reduce using rule 14 (salida -> ECHO valor ENDLINE .)
    RKEY            reduce using rule 14 (salida -> ECHO valor ENDLINE .)


state 70

    (89) funciones -> valor LPAREN . valor RPAREN LKEY cuerpo RKEY
    (16) valor -> . ARGUMENTO
    (17) valor -> . number
    (18) valor -> . BOOLEAN
    (19) valor -> . string
    (20) valor -> . VARIABLE
    (21) valor -> . estructuras_datos
    (22) valor -> . funciones
    (23) valor -> . valor
    (71) number -> . INTEGER
    (72) number -> . FLOAT
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (89) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN

    ARGUMENTO       shift and go to state 38
    BOOLEAN         shift and go to state 40
    VARIABLE        shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    valor                          shift and go to state 98
    number                         shift and go to state 39
    string                         shift and go to state 41
    estructuras_datos              shift and go to state 43
    funciones                      shift and go to state 44
    array                          shift and go to state 23
    queue                          shift and go to state 15
    splfixedarray                  shift and go to state 17

state 71

    (25) string -> COMILLA_DOBLE STRING . COMILLA_DOBLE

    COMILLA_DOBLE   shift and go to state 99


state 72

    (26) string -> COMILLA_SIMPLE STRING . COMILLA_SIMPLE

    COMILLA_SIMPLE  shift and go to state 100


state 73

    (15) salida -> PRINT LPAREN valor . RPAREN ENDLINE
    (23) valor -> valor .
    (89) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          shift and go to state 101
    LPAREN          shift and go to state 70

  ! RPAREN          [ reduce using rule 23 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 23 (valor -> valor .) ]


state 74

    (86) array -> LPAREN valorArreglo RPAREN . ENDLINE

    ENDLINE         shift and go to state 102


state 75

    (87) valorArreglo -> valor COMA . valorArreglo
    (87) valorArreglo -> . valor COMA valorArreglo
    (88) valorArreglo -> . valor
    (16) valor -> . ARGUMENTO
    (17) valor -> . number
    (18) valor -> . BOOLEAN
    (19) valor -> . string
    (20) valor -> . VARIABLE
    (21) valor -> . estructuras_datos
    (22) valor -> . funciones
    (23) valor -> . valor
    (71) number -> . INTEGER
    (72) number -> . FLOAT
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (89) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN

    ARGUMENTO       shift and go to state 38
    BOOLEAN         shift and go to state 40
    VARIABLE        shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    valor                          shift and go to state 52
    valorArreglo                   shift and go to state 103
    number                         shift and go to state 39
    string                         shift and go to state 41
    estructuras_datos              shift and go to state 43
    funciones                      shift and go to state 44
    array                          shift and go to state 23
    queue                          shift and go to state 15
    splfixedarray                  shift and go to state 17

state 76

    (28) asignacion -> VARIABLE operador_asignacion valor . ENDLINE
    (23) valor -> valor .
    (89) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY
    (62) expresiones_logicas -> valor .
    (63) expresiones_logicas -> valor . operador expresiones_logicas
    (69) operador -> . operador_logico
    (70) operador -> . operador_comparacion
    (64) operador_logico -> . BOOLEAN_AND
    (65) operador_logico -> . BOOLEAN_OR
    (66) operador_logico -> . AND
    (67) operador_logico -> . OR
    (68) operador_logico -> . XOR
    (46) operador_comparacion -> . IS_EQUAL
    (47) operador_comparacion -> . IS_GREATER_OR_EQUAL
    (48) operador_comparacion -> . IS_NOT_EQUAL
    (49) operador_comparacion -> . IS_SMALLER_OR_EQUAL
    (50) operador_comparacion -> . IS_GREATER
    (51) operador_comparacion -> . IS_SMALLER

  ! shift/reduce conflict for ENDLINE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ENDLINE resolved as shift
  ! shift/reduce conflict for BOOLEAN_AND resolved as shift
  ! shift/reduce conflict for BOOLEAN_OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for IS_EQUAL resolved as shift
  ! shift/reduce conflict for IS_GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for IS_NOT_EQUAL resolved as shift
  ! shift/reduce conflict for IS_SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for IS_GREATER resolved as shift
  ! shift/reduce conflict for IS_SMALLER resolved as shift
    ENDLINE         shift and go to state 104
    LPAREN          shift and go to state 70
    BOOLEAN_AND     shift and go to state 108
    BOOLEAN_OR      shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    XOR             shift and go to state 112
    IS_EQUAL        shift and go to state 113
    IS_GREATER_OR_EQUAL shift and go to state 114
    IS_NOT_EQUAL    shift and go to state 115
    IS_SMALLER_OR_EQUAL shift and go to state 116
    IS_GREATER      shift and go to state 117
    IS_SMALLER      shift and go to state 118

  ! ENDLINE         [ reduce using rule 23 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 23 (valor -> valor .) ]
  ! BOOLEAN_AND     [ reduce using rule 23 (valor -> valor .) ]
  ! BOOLEAN_OR      [ reduce using rule 23 (valor -> valor .) ]
  ! AND             [ reduce using rule 23 (valor -> valor .) ]
  ! OR              [ reduce using rule 23 (valor -> valor .) ]
  ! XOR             [ reduce using rule 23 (valor -> valor .) ]
  ! IS_EQUAL        [ reduce using rule 23 (valor -> valor .) ]
  ! IS_GREATER_OR_EQUAL [ reduce using rule 23 (valor -> valor .) ]
  ! IS_NOT_EQUAL    [ reduce using rule 23 (valor -> valor .) ]
  ! IS_SMALLER_OR_EQUAL [ reduce using rule 23 (valor -> valor .) ]
  ! IS_GREATER      [ reduce using rule 23 (valor -> valor .) ]
  ! IS_SMALLER      [ reduce using rule 23 (valor -> valor .) ]
  ! ENDLINE         [ reduce using rule 62 (expresiones_logicas -> valor .) ]

    operador                       shift and go to state 105
    operador_logico                shift and go to state 106
    operador_comparacion           shift and go to state 107

state 77

    (29) asignacion -> VARIABLE operador_asignacion expresion . ENDLINE

    ENDLINE         shift and go to state 119


state 78

    (17) valor -> number .
    (79) expresion_aritmetica -> number .
    (80) expresion_aritmetica -> number . operador_aritmetico expresion_aritmetica
    (73) operador_aritmetico -> . ADDITION
    (74) operador_aritmetico -> . SUBTRACTION
    (75) operador_aritmetico -> . MULTIPLICATION
    (76) operador_aritmetico -> . DIVISION
    (77) operador_aritmetico -> . MODULO
    (78) operador_aritmetico -> . EXPONENTIATION

  ! reduce/reduce conflict for ENDLINE resolved using rule 17 (valor -> number .)
    ENDLINE         reduce using rule 17 (valor -> number .)
    LPAREN          reduce using rule 17 (valor -> number .)
    BOOLEAN_AND     reduce using rule 17 (valor -> number .)
    BOOLEAN_OR      reduce using rule 17 (valor -> number .)
    AND             reduce using rule 17 (valor -> number .)
    OR              reduce using rule 17 (valor -> number .)
    XOR             reduce using rule 17 (valor -> number .)
    IS_EQUAL        reduce using rule 17 (valor -> number .)
    IS_GREATER_OR_EQUAL reduce using rule 17 (valor -> number .)
    IS_NOT_EQUAL    reduce using rule 17 (valor -> number .)
    IS_SMALLER_OR_EQUAL reduce using rule 17 (valor -> number .)
    IS_GREATER      reduce using rule 17 (valor -> number .)
    IS_SMALLER      reduce using rule 17 (valor -> number .)
    ADDITION        shift and go to state 121
    SUBTRACTION     shift and go to state 122
    MULTIPLICATION  shift and go to state 123
    DIVISION        shift and go to state 124
    MODULO          shift and go to state 125
    EXPONENTIATION  shift and go to state 126

  ! ENDLINE         [ reduce using rule 79 (expresion_aritmetica -> number .) ]

    operador_aritmetico            shift and go to state 120

state 79

    (60) expresion -> expresiones_logicas .

    ENDLINE         reduce using rule 60 (expresion -> expresiones_logicas .)
    RPAREN          reduce using rule 60 (expresion -> expresiones_logicas .)


state 80

    (61) expresion -> expresion_aritmetica .

    ENDLINE         reduce using rule 61 (expresion -> expresion_aritmetica .)
    RPAREN          reduce using rule 61 (expresion -> expresion_aritmetica .)


state 81

    (30) asignacion -> queue_variable operador_asignacion queue . ENDLINE

    ENDLINE         shift and go to state 127


state 82

    (31) queue -> NEW . SPLQUEUE LPAREN RPAREN

    SPLQUEUE        shift and go to state 67


state 83

    (36) push -> queue_variable ARROW PUSH . LPAREN valor RPAREN ENDLINE

    LPAREN          shift and go to state 128


state 84

    (37) pop -> queue_variable ARROW POP . LPAREN RPAREN ENDLINE

    LPAREN          shift and go to state 129


state 85

    (33) asignacion -> splfixedarray_variable operador_asignacion splfixedarray . ENDLINE

    ENDLINE         shift and go to state 130


state 86

    (34) splfixedarray -> NEW . SPLFIXEDARRAY LPAREN INTEGER RPAREN

    SPLFIXEDARRAY   shift and go to state 68


state 87

    (27) function -> FUNCTION ARGUMENTO LPAREN . VARIABLE RPAREN LKEY ARGUMENTO RKEY

    VARIABLE        shift and go to state 131


state 88

    (59) else -> if ELSE LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . estructuras_datos
    (10) cuerpo -> . metodos
    (11) cuerpo -> . metodos cuerpo
    (12) cuerpo -> . abrir_archivo
    (13) cuerpo -> . lectura_archivo
    (14) salida -> . ECHO valor ENDLINE
    (15) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (29) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (30) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (33) asignacion -> . splfixedarray_variable operador_asignacion splfixedarray ENDLINE
    (27) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (53) estructuras_control -> . if
    (54) estructuras_control -> . else
    (55) estructuras_control -> . while
    (56) estructuras_control -> . for
    (57) estructuras_control -> . estructuras_control
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (38) metodos -> . push
    (39) metodos -> . pop
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (83) lectura_archivo -> . FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
    (32) queue_variable -> . VARIABLE
    (35) splfixedarray_variable -> . VARIABLE
    (58) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (59) else -> . if ELSE LKEY cuerpo RKEY
    (84) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (101) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
    (36) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 10
    PRINT           shift and go to state 11
    VARIABLE        shift and go to state 13
    FUNCTION        shift and go to state 18
    FOPEN           shift and go to state 26
    FSCANF          shift and go to state 27
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    if                             shift and go to state 19
    cuerpo                         shift and go to state 132
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    estructuras_datos              shift and go to state 6
    metodos                        shift and go to state 7
    abrir_archivo                  shift and go to state 8
    lectura_archivo                shift and go to state 9
    queue_variable                 shift and go to state 14
    queue                          shift and go to state 15
    splfixedarray_variable         shift and go to state 16
    splfixedarray                  shift and go to state 17
    else                           shift and go to state 20
    while                          shift and go to state 21
    for                            shift and go to state 22
    array                          shift and go to state 23
    push                           shift and go to state 24
    pop                            shift and go to state 25

state 89

    (81) abrir_archivo -> FOPEN LPAREN string . RPAREN
    (82) abrir_archivo -> FOPEN LPAREN string . RPAREN ENDLINE

    RPAREN          shift and go to state 133


state 90

    (83) lectura_archivo -> FSCANF LPAREN abrir_archivo . COMA string RPAREN ENDLINE

    COMA            shift and go to state 134


state 91

    (58) if -> IF LPAREN expresion . RPAREN LKEY cuerpo RKEY

    RPAREN          shift and go to state 135


state 92

    (62) expresiones_logicas -> valor .
    (63) expresiones_logicas -> valor . operador expresiones_logicas
    (23) valor -> valor .
    (89) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY
    (69) operador -> . operador_logico
    (70) operador -> . operador_comparacion
    (64) operador_logico -> . BOOLEAN_AND
    (65) operador_logico -> . BOOLEAN_OR
    (66) operador_logico -> . AND
    (67) operador_logico -> . OR
    (68) operador_logico -> . XOR
    (46) operador_comparacion -> . IS_EQUAL
    (47) operador_comparacion -> . IS_GREATER_OR_EQUAL
    (48) operador_comparacion -> . IS_NOT_EQUAL
    (49) operador_comparacion -> . IS_SMALLER_OR_EQUAL
    (50) operador_comparacion -> . IS_GREATER
    (51) operador_comparacion -> . IS_SMALLER

  ! reduce/reduce conflict for RPAREN resolved using rule 23 (valor -> valor .)
  ! reduce/reduce conflict for ENDLINE resolved using rule 23 (valor -> valor .)
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN_AND resolved as shift
  ! shift/reduce conflict for BOOLEAN_OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for IS_EQUAL resolved as shift
  ! shift/reduce conflict for IS_GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for IS_NOT_EQUAL resolved as shift
  ! shift/reduce conflict for IS_SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for IS_GREATER resolved as shift
  ! shift/reduce conflict for IS_SMALLER resolved as shift
    RPAREN          reduce using rule 23 (valor -> valor .)
    ENDLINE         reduce using rule 23 (valor -> valor .)
    LPAREN          shift and go to state 70
    BOOLEAN_AND     shift and go to state 108
    BOOLEAN_OR      shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    XOR             shift and go to state 112
    IS_EQUAL        shift and go to state 113
    IS_GREATER_OR_EQUAL shift and go to state 114
    IS_NOT_EQUAL    shift and go to state 115
    IS_SMALLER_OR_EQUAL shift and go to state 116
    IS_GREATER      shift and go to state 117
    IS_SMALLER      shift and go to state 118

  ! RPAREN          [ reduce using rule 62 (expresiones_logicas -> valor .) ]
  ! ENDLINE         [ reduce using rule 62 (expresiones_logicas -> valor .) ]
  ! LPAREN          [ reduce using rule 23 (valor -> valor .) ]
  ! BOOLEAN_AND     [ reduce using rule 23 (valor -> valor .) ]
  ! BOOLEAN_OR      [ reduce using rule 23 (valor -> valor .) ]
  ! AND             [ reduce using rule 23 (valor -> valor .) ]
  ! OR              [ reduce using rule 23 (valor -> valor .) ]
  ! XOR             [ reduce using rule 23 (valor -> valor .) ]
  ! IS_EQUAL        [ reduce using rule 23 (valor -> valor .) ]
  ! IS_GREATER_OR_EQUAL [ reduce using rule 23 (valor -> valor .) ]
  ! IS_NOT_EQUAL    [ reduce using rule 23 (valor -> valor .) ]
  ! IS_SMALLER_OR_EQUAL [ reduce using rule 23 (valor -> valor .) ]
  ! IS_GREATER      [ reduce using rule 23 (valor -> valor .) ]
  ! IS_SMALLER      [ reduce using rule 23 (valor -> valor .) ]

    operador                       shift and go to state 105
    operador_logico                shift and go to state 106
    operador_comparacion           shift and go to state 107

state 93

    (79) expresion_aritmetica -> number .
    (80) expresion_aritmetica -> number . operador_aritmetico expresion_aritmetica
    (17) valor -> number .
    (73) operador_aritmetico -> . ADDITION
    (74) operador_aritmetico -> . SUBTRACTION
    (75) operador_aritmetico -> . MULTIPLICATION
    (76) operador_aritmetico -> . DIVISION
    (77) operador_aritmetico -> . MODULO
    (78) operador_aritmetico -> . EXPONENTIATION

  ! reduce/reduce conflict for RPAREN resolved using rule 17 (valor -> number .)
    LPAREN          reduce using rule 17 (valor -> number .)
    BOOLEAN_AND     reduce using rule 17 (valor -> number .)
    BOOLEAN_OR      reduce using rule 17 (valor -> number .)
    AND             reduce using rule 17 (valor -> number .)
    OR              reduce using rule 17 (valor -> number .)
    XOR             reduce using rule 17 (valor -> number .)
    IS_EQUAL        reduce using rule 17 (valor -> number .)
    IS_GREATER_OR_EQUAL reduce using rule 17 (valor -> number .)
    IS_NOT_EQUAL    reduce using rule 17 (valor -> number .)
    IS_SMALLER_OR_EQUAL reduce using rule 17 (valor -> number .)
    IS_GREATER      reduce using rule 17 (valor -> number .)
    IS_SMALLER      reduce using rule 17 (valor -> number .)
    RPAREN          reduce using rule 17 (valor -> number .)
    ADDITION        shift and go to state 121
    SUBTRACTION     shift and go to state 122
    MULTIPLICATION  shift and go to state 123
    DIVISION        shift and go to state 124
    MODULO          shift and go to state 125
    EXPONENTIATION  shift and go to state 126

  ! RPAREN          [ reduce using rule 79 (expresion_aritmetica -> number .) ]

    operador_aritmetico            shift and go to state 120

state 94

    (84) while -> WHILE LPAREN valor . operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> WHILE LPAREN valor . operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (23) valor -> valor .
    (89) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY
    (46) operador_comparacion -> . IS_EQUAL
    (47) operador_comparacion -> . IS_GREATER_OR_EQUAL
    (48) operador_comparacion -> . IS_NOT_EQUAL
    (49) operador_comparacion -> . IS_SMALLER_OR_EQUAL
    (50) operador_comparacion -> . IS_GREATER
    (51) operador_comparacion -> . IS_SMALLER

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IS_EQUAL resolved as shift
  ! shift/reduce conflict for IS_GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for IS_NOT_EQUAL resolved as shift
  ! shift/reduce conflict for IS_SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for IS_GREATER resolved as shift
  ! shift/reduce conflict for IS_SMALLER resolved as shift
    LPAREN          shift and go to state 70
    IS_EQUAL        shift and go to state 113
    IS_GREATER_OR_EQUAL shift and go to state 114
    IS_NOT_EQUAL    shift and go to state 115
    IS_SMALLER_OR_EQUAL shift and go to state 116
    IS_GREATER      shift and go to state 117
    IS_SMALLER      shift and go to state 118

  ! LPAREN          [ reduce using rule 23 (valor -> valor .) ]
  ! IS_EQUAL        [ reduce using rule 23 (valor -> valor .) ]
  ! IS_GREATER_OR_EQUAL [ reduce using rule 23 (valor -> valor .) ]
  ! IS_NOT_EQUAL    [ reduce using rule 23 (valor -> valor .) ]
  ! IS_SMALLER_OR_EQUAL [ reduce using rule 23 (valor -> valor .) ]
  ! IS_GREATER      [ reduce using rule 23 (valor -> valor .) ]
  ! IS_SMALLER      [ reduce using rule 23 (valor -> valor .) ]

    operador_comparacion           shift and go to state 136

state 95

    (101) for -> FOR LPAREN VARIABLE . EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    EQUAL           shift and go to state 137


state 96

    (31) queue -> NEW SPLQUEUE LPAREN . RPAREN

    RPAREN          shift and go to state 138


state 97

    (34) splfixedarray -> NEW SPLFIXEDARRAY LPAREN . INTEGER RPAREN

    INTEGER         shift and go to state 139


state 98

    (89) funciones -> valor LPAREN valor . RPAREN LKEY cuerpo RKEY
    (23) valor -> valor .
    (89) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          shift and go to state 140
    LPAREN          shift and go to state 70

  ! RPAREN          [ reduce using rule 23 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 23 (valor -> valor .) ]


state 99

    (25) string -> COMILLA_DOBLE STRING COMILLA_DOBLE .

    ENDLINE         reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    LPAREN          reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    COMA            reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    RPAREN          reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    BOOLEAN_AND     reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    BOOLEAN_OR      reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    AND             reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    OR              reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    XOR             reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    IS_EQUAL        reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    IS_GREATER_OR_EQUAL reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    IS_NOT_EQUAL    reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    IS_SMALLER_OR_EQUAL reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    IS_GREATER      reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)
    IS_SMALLER      reduce using rule 25 (string -> COMILLA_DOBLE STRING COMILLA_DOBLE .)


state 100

    (26) string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .

    ENDLINE         reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    LPAREN          reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    COMA            reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    RPAREN          reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    BOOLEAN_AND     reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    BOOLEAN_OR      reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    AND             reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    OR              reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    XOR             reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    IS_EQUAL        reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    IS_GREATER_OR_EQUAL reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    IS_NOT_EQUAL    reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    IS_SMALLER_OR_EQUAL reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    IS_GREATER      reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)
    IS_SMALLER      reduce using rule 26 (string -> COMILLA_SIMPLE STRING COMILLA_SIMPLE .)


state 101

    (15) salida -> PRINT LPAREN valor RPAREN . ENDLINE

    ENDLINE         shift and go to state 141


state 102

    (86) array -> LPAREN valorArreglo RPAREN ENDLINE .

    $end            reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    RKEY            reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    ECHO            reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    PRINT           reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    VARIABLE        reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    FUNCTION        reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    FOPEN           reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    FSCANF          reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    IF              reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    WHILE           reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    FOR             reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    LPAREN          reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    NEW             reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    ENDLINE         reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    COMA            reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    RPAREN          reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    BOOLEAN_AND     reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    BOOLEAN_OR      reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    AND             reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    OR              reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    XOR             reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    IS_EQUAL        reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    IS_GREATER_OR_EQUAL reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    IS_NOT_EQUAL    reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    IS_SMALLER_OR_EQUAL reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    IS_GREATER      reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)
    IS_SMALLER      reduce using rule 86 (array -> LPAREN valorArreglo RPAREN ENDLINE .)


state 103

    (87) valorArreglo -> valor COMA valorArreglo .

    RPAREN          reduce using rule 87 (valorArreglo -> valor COMA valorArreglo .)


state 104

    (28) asignacion -> VARIABLE operador_asignacion valor ENDLINE .

    ECHO            reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    PRINT           reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    VARIABLE        reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    FUNCTION        reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    FOPEN           reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    FSCANF          reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    IF              reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    WHILE           reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    FOR             reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    LPAREN          reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    NEW             reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    $end            reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)
    RKEY            reduce using rule 28 (asignacion -> VARIABLE operador_asignacion valor ENDLINE .)


state 105

    (63) expresiones_logicas -> valor operador . expresiones_logicas
    (62) expresiones_logicas -> . valor
    (63) expresiones_logicas -> . valor operador expresiones_logicas
    (16) valor -> . ARGUMENTO
    (17) valor -> . number
    (18) valor -> . BOOLEAN
    (19) valor -> . string
    (20) valor -> . VARIABLE
    (21) valor -> . estructuras_datos
    (22) valor -> . funciones
    (23) valor -> . valor
    (71) number -> . INTEGER
    (72) number -> . FLOAT
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (89) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN

    ARGUMENTO       shift and go to state 38
    BOOLEAN         shift and go to state 40
    VARIABLE        shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    valor                          shift and go to state 92
    expresiones_logicas            shift and go to state 142
    number                         shift and go to state 39
    string                         shift and go to state 41
    estructuras_datos              shift and go to state 43
    funciones                      shift and go to state 44
    array                          shift and go to state 23
    queue                          shift and go to state 15
    splfixedarray                  shift and go to state 17

state 106

    (69) operador -> operador_logico .

    ARGUMENTO       reduce using rule 69 (operador -> operador_logico .)
    BOOLEAN         reduce using rule 69 (operador -> operador_logico .)
    VARIABLE        reduce using rule 69 (operador -> operador_logico .)
    INTEGER         reduce using rule 69 (operador -> operador_logico .)
    FLOAT           reduce using rule 69 (operador -> operador_logico .)
    STRING          reduce using rule 69 (operador -> operador_logico .)
    COMILLA_DOBLE   reduce using rule 69 (operador -> operador_logico .)
    COMILLA_SIMPLE  reduce using rule 69 (operador -> operador_logico .)
    LPAREN          reduce using rule 69 (operador -> operador_logico .)
    NEW             reduce using rule 69 (operador -> operador_logico .)


state 107

    (70) operador -> operador_comparacion .

    ARGUMENTO       reduce using rule 70 (operador -> operador_comparacion .)
    BOOLEAN         reduce using rule 70 (operador -> operador_comparacion .)
    VARIABLE        reduce using rule 70 (operador -> operador_comparacion .)
    INTEGER         reduce using rule 70 (operador -> operador_comparacion .)
    FLOAT           reduce using rule 70 (operador -> operador_comparacion .)
    STRING          reduce using rule 70 (operador -> operador_comparacion .)
    COMILLA_DOBLE   reduce using rule 70 (operador -> operador_comparacion .)
    COMILLA_SIMPLE  reduce using rule 70 (operador -> operador_comparacion .)
    LPAREN          reduce using rule 70 (operador -> operador_comparacion .)
    NEW             reduce using rule 70 (operador -> operador_comparacion .)


state 108

    (64) operador_logico -> BOOLEAN_AND .

    ARGUMENTO       reduce using rule 64 (operador_logico -> BOOLEAN_AND .)
    BOOLEAN         reduce using rule 64 (operador_logico -> BOOLEAN_AND .)
    VARIABLE        reduce using rule 64 (operador_logico -> BOOLEAN_AND .)
    INTEGER         reduce using rule 64 (operador_logico -> BOOLEAN_AND .)
    FLOAT           reduce using rule 64 (operador_logico -> BOOLEAN_AND .)
    STRING          reduce using rule 64 (operador_logico -> BOOLEAN_AND .)
    COMILLA_DOBLE   reduce using rule 64 (operador_logico -> BOOLEAN_AND .)
    COMILLA_SIMPLE  reduce using rule 64 (operador_logico -> BOOLEAN_AND .)
    LPAREN          reduce using rule 64 (operador_logico -> BOOLEAN_AND .)
    NEW             reduce using rule 64 (operador_logico -> BOOLEAN_AND .)


state 109

    (65) operador_logico -> BOOLEAN_OR .

    ARGUMENTO       reduce using rule 65 (operador_logico -> BOOLEAN_OR .)
    BOOLEAN         reduce using rule 65 (operador_logico -> BOOLEAN_OR .)
    VARIABLE        reduce using rule 65 (operador_logico -> BOOLEAN_OR .)
    INTEGER         reduce using rule 65 (operador_logico -> BOOLEAN_OR .)
    FLOAT           reduce using rule 65 (operador_logico -> BOOLEAN_OR .)
    STRING          reduce using rule 65 (operador_logico -> BOOLEAN_OR .)
    COMILLA_DOBLE   reduce using rule 65 (operador_logico -> BOOLEAN_OR .)
    COMILLA_SIMPLE  reduce using rule 65 (operador_logico -> BOOLEAN_OR .)
    LPAREN          reduce using rule 65 (operador_logico -> BOOLEAN_OR .)
    NEW             reduce using rule 65 (operador_logico -> BOOLEAN_OR .)


state 110

    (66) operador_logico -> AND .

    ARGUMENTO       reduce using rule 66 (operador_logico -> AND .)
    BOOLEAN         reduce using rule 66 (operador_logico -> AND .)
    VARIABLE        reduce using rule 66 (operador_logico -> AND .)
    INTEGER         reduce using rule 66 (operador_logico -> AND .)
    FLOAT           reduce using rule 66 (operador_logico -> AND .)
    STRING          reduce using rule 66 (operador_logico -> AND .)
    COMILLA_DOBLE   reduce using rule 66 (operador_logico -> AND .)
    COMILLA_SIMPLE  reduce using rule 66 (operador_logico -> AND .)
    LPAREN          reduce using rule 66 (operador_logico -> AND .)
    NEW             reduce using rule 66 (operador_logico -> AND .)


state 111

    (67) operador_logico -> OR .

    ARGUMENTO       reduce using rule 67 (operador_logico -> OR .)
    BOOLEAN         reduce using rule 67 (operador_logico -> OR .)
    VARIABLE        reduce using rule 67 (operador_logico -> OR .)
    INTEGER         reduce using rule 67 (operador_logico -> OR .)
    FLOAT           reduce using rule 67 (operador_logico -> OR .)
    STRING          reduce using rule 67 (operador_logico -> OR .)
    COMILLA_DOBLE   reduce using rule 67 (operador_logico -> OR .)
    COMILLA_SIMPLE  reduce using rule 67 (operador_logico -> OR .)
    LPAREN          reduce using rule 67 (operador_logico -> OR .)
    NEW             reduce using rule 67 (operador_logico -> OR .)


state 112

    (68) operador_logico -> XOR .

    ARGUMENTO       reduce using rule 68 (operador_logico -> XOR .)
    BOOLEAN         reduce using rule 68 (operador_logico -> XOR .)
    VARIABLE        reduce using rule 68 (operador_logico -> XOR .)
    INTEGER         reduce using rule 68 (operador_logico -> XOR .)
    FLOAT           reduce using rule 68 (operador_logico -> XOR .)
    STRING          reduce using rule 68 (operador_logico -> XOR .)
    COMILLA_DOBLE   reduce using rule 68 (operador_logico -> XOR .)
    COMILLA_SIMPLE  reduce using rule 68 (operador_logico -> XOR .)
    LPAREN          reduce using rule 68 (operador_logico -> XOR .)
    NEW             reduce using rule 68 (operador_logico -> XOR .)


state 113

    (46) operador_comparacion -> IS_EQUAL .

    ARGUMENTO       reduce using rule 46 (operador_comparacion -> IS_EQUAL .)
    BOOLEAN         reduce using rule 46 (operador_comparacion -> IS_EQUAL .)
    VARIABLE        reduce using rule 46 (operador_comparacion -> IS_EQUAL .)
    INTEGER         reduce using rule 46 (operador_comparacion -> IS_EQUAL .)
    FLOAT           reduce using rule 46 (operador_comparacion -> IS_EQUAL .)
    STRING          reduce using rule 46 (operador_comparacion -> IS_EQUAL .)
    COMILLA_DOBLE   reduce using rule 46 (operador_comparacion -> IS_EQUAL .)
    COMILLA_SIMPLE  reduce using rule 46 (operador_comparacion -> IS_EQUAL .)
    LPAREN          reduce using rule 46 (operador_comparacion -> IS_EQUAL .)
    NEW             reduce using rule 46 (operador_comparacion -> IS_EQUAL .)


state 114

    (47) operador_comparacion -> IS_GREATER_OR_EQUAL .

    ARGUMENTO       reduce using rule 47 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    BOOLEAN         reduce using rule 47 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    VARIABLE        reduce using rule 47 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 47 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    FLOAT           reduce using rule 47 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    STRING          reduce using rule 47 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    COMILLA_DOBLE   reduce using rule 47 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    COMILLA_SIMPLE  reduce using rule 47 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    LPAREN          reduce using rule 47 (operador_comparacion -> IS_GREATER_OR_EQUAL .)
    NEW             reduce using rule 47 (operador_comparacion -> IS_GREATER_OR_EQUAL .)


state 115

    (48) operador_comparacion -> IS_NOT_EQUAL .

    ARGUMENTO       reduce using rule 48 (operador_comparacion -> IS_NOT_EQUAL .)
    BOOLEAN         reduce using rule 48 (operador_comparacion -> IS_NOT_EQUAL .)
    VARIABLE        reduce using rule 48 (operador_comparacion -> IS_NOT_EQUAL .)
    INTEGER         reduce using rule 48 (operador_comparacion -> IS_NOT_EQUAL .)
    FLOAT           reduce using rule 48 (operador_comparacion -> IS_NOT_EQUAL .)
    STRING          reduce using rule 48 (operador_comparacion -> IS_NOT_EQUAL .)
    COMILLA_DOBLE   reduce using rule 48 (operador_comparacion -> IS_NOT_EQUAL .)
    COMILLA_SIMPLE  reduce using rule 48 (operador_comparacion -> IS_NOT_EQUAL .)
    LPAREN          reduce using rule 48 (operador_comparacion -> IS_NOT_EQUAL .)
    NEW             reduce using rule 48 (operador_comparacion -> IS_NOT_EQUAL .)


state 116

    (49) operador_comparacion -> IS_SMALLER_OR_EQUAL .

    ARGUMENTO       reduce using rule 49 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    BOOLEAN         reduce using rule 49 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    VARIABLE        reduce using rule 49 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 49 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    FLOAT           reduce using rule 49 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    STRING          reduce using rule 49 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    COMILLA_DOBLE   reduce using rule 49 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    COMILLA_SIMPLE  reduce using rule 49 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    LPAREN          reduce using rule 49 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)
    NEW             reduce using rule 49 (operador_comparacion -> IS_SMALLER_OR_EQUAL .)


state 117

    (50) operador_comparacion -> IS_GREATER .

    ARGUMENTO       reduce using rule 50 (operador_comparacion -> IS_GREATER .)
    BOOLEAN         reduce using rule 50 (operador_comparacion -> IS_GREATER .)
    VARIABLE        reduce using rule 50 (operador_comparacion -> IS_GREATER .)
    INTEGER         reduce using rule 50 (operador_comparacion -> IS_GREATER .)
    FLOAT           reduce using rule 50 (operador_comparacion -> IS_GREATER .)
    STRING          reduce using rule 50 (operador_comparacion -> IS_GREATER .)
    COMILLA_DOBLE   reduce using rule 50 (operador_comparacion -> IS_GREATER .)
    COMILLA_SIMPLE  reduce using rule 50 (operador_comparacion -> IS_GREATER .)
    LPAREN          reduce using rule 50 (operador_comparacion -> IS_GREATER .)
    NEW             reduce using rule 50 (operador_comparacion -> IS_GREATER .)


state 118

    (51) operador_comparacion -> IS_SMALLER .

    ARGUMENTO       reduce using rule 51 (operador_comparacion -> IS_SMALLER .)
    BOOLEAN         reduce using rule 51 (operador_comparacion -> IS_SMALLER .)
    VARIABLE        reduce using rule 51 (operador_comparacion -> IS_SMALLER .)
    INTEGER         reduce using rule 51 (operador_comparacion -> IS_SMALLER .)
    FLOAT           reduce using rule 51 (operador_comparacion -> IS_SMALLER .)
    STRING          reduce using rule 51 (operador_comparacion -> IS_SMALLER .)
    COMILLA_DOBLE   reduce using rule 51 (operador_comparacion -> IS_SMALLER .)
    COMILLA_SIMPLE  reduce using rule 51 (operador_comparacion -> IS_SMALLER .)
    LPAREN          reduce using rule 51 (operador_comparacion -> IS_SMALLER .)
    NEW             reduce using rule 51 (operador_comparacion -> IS_SMALLER .)


state 119

    (29) asignacion -> VARIABLE operador_asignacion expresion ENDLINE .

    ECHO            reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    PRINT           reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    VARIABLE        reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    FUNCTION        reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    FOPEN           reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    FSCANF          reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    IF              reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    WHILE           reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    FOR             reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    LPAREN          reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    NEW             reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    $end            reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)
    RKEY            reduce using rule 29 (asignacion -> VARIABLE operador_asignacion expresion ENDLINE .)


state 120

    (80) expresion_aritmetica -> number operador_aritmetico . expresion_aritmetica
    (79) expresion_aritmetica -> . number
    (80) expresion_aritmetica -> . number operador_aritmetico expresion_aritmetica
    (71) number -> . INTEGER
    (72) number -> . FLOAT

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46

    number                         shift and go to state 143
    expresion_aritmetica           shift and go to state 144

state 121

    (73) operador_aritmetico -> ADDITION .

    INTEGER         reduce using rule 73 (operador_aritmetico -> ADDITION .)
    FLOAT           reduce using rule 73 (operador_aritmetico -> ADDITION .)


state 122

    (74) operador_aritmetico -> SUBTRACTION .

    INTEGER         reduce using rule 74 (operador_aritmetico -> SUBTRACTION .)
    FLOAT           reduce using rule 74 (operador_aritmetico -> SUBTRACTION .)


state 123

    (75) operador_aritmetico -> MULTIPLICATION .

    INTEGER         reduce using rule 75 (operador_aritmetico -> MULTIPLICATION .)
    FLOAT           reduce using rule 75 (operador_aritmetico -> MULTIPLICATION .)


state 124

    (76) operador_aritmetico -> DIVISION .

    INTEGER         reduce using rule 76 (operador_aritmetico -> DIVISION .)
    FLOAT           reduce using rule 76 (operador_aritmetico -> DIVISION .)


state 125

    (77) operador_aritmetico -> MODULO .

    INTEGER         reduce using rule 77 (operador_aritmetico -> MODULO .)
    FLOAT           reduce using rule 77 (operador_aritmetico -> MODULO .)


state 126

    (78) operador_aritmetico -> EXPONENTIATION .

    INTEGER         reduce using rule 78 (operador_aritmetico -> EXPONENTIATION .)
    FLOAT           reduce using rule 78 (operador_aritmetico -> EXPONENTIATION .)


state 127

    (30) asignacion -> queue_variable operador_asignacion queue ENDLINE .

    ECHO            reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    PRINT           reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    VARIABLE        reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    FUNCTION        reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    FOPEN           reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    FSCANF          reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    IF              reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    WHILE           reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    FOR             reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    LPAREN          reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    NEW             reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    $end            reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)
    RKEY            reduce using rule 30 (asignacion -> queue_variable operador_asignacion queue ENDLINE .)


state 128

    (36) push -> queue_variable ARROW PUSH LPAREN . valor RPAREN ENDLINE
    (16) valor -> . ARGUMENTO
    (17) valor -> . number
    (18) valor -> . BOOLEAN
    (19) valor -> . string
    (20) valor -> . VARIABLE
    (21) valor -> . estructuras_datos
    (22) valor -> . funciones
    (23) valor -> . valor
    (71) number -> . INTEGER
    (72) number -> . FLOAT
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (89) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN

    ARGUMENTO       shift and go to state 38
    BOOLEAN         shift and go to state 40
    VARIABLE        shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    valor                          shift and go to state 145
    number                         shift and go to state 39
    string                         shift and go to state 41
    estructuras_datos              shift and go to state 43
    funciones                      shift and go to state 44
    array                          shift and go to state 23
    queue                          shift and go to state 15
    splfixedarray                  shift and go to state 17

state 129

    (37) pop -> queue_variable ARROW POP LPAREN . RPAREN ENDLINE

    RPAREN          shift and go to state 146


state 130

    (33) asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .

    ECHO            reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)
    PRINT           reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)
    VARIABLE        reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)
    FUNCTION        reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)
    FOPEN           reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)
    FSCANF          reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)
    IF              reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)
    WHILE           reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)
    FOR             reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)
    LPAREN          reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)
    NEW             reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)
    $end            reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)
    RKEY            reduce using rule 33 (asignacion -> splfixedarray_variable operador_asignacion splfixedarray ENDLINE .)


state 131

    (27) function -> FUNCTION ARGUMENTO LPAREN VARIABLE . RPAREN LKEY ARGUMENTO RKEY

    RPAREN          shift and go to state 147


state 132

    (59) else -> if ELSE LKEY cuerpo . RKEY

    RKEY            shift and go to state 148


state 133

    (81) abrir_archivo -> FOPEN LPAREN string RPAREN .
    (82) abrir_archivo -> FOPEN LPAREN string RPAREN . ENDLINE

    $end            reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    RKEY            reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    ECHO            reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    PRINT           reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    VARIABLE        reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    FUNCTION        reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    FOPEN           reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    FSCANF          reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    IF              reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    WHILE           reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    FOR             reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    LPAREN          reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    NEW             reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    COMA            reduce using rule 81 (abrir_archivo -> FOPEN LPAREN string RPAREN .)
    ENDLINE         shift and go to state 149


state 134

    (83) lectura_archivo -> FSCANF LPAREN abrir_archivo COMA . string RPAREN ENDLINE
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE

    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49

    string                         shift and go to state 150

state 135

    (58) if -> IF LPAREN expresion RPAREN . LKEY cuerpo RKEY

    LKEY            shift and go to state 151


state 136

    (84) while -> WHILE LPAREN valor operador_comparacion . valor RPAREN COLON cuerpo
    (85) while -> WHILE LPAREN valor operador_comparacion . valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (16) valor -> . ARGUMENTO
    (17) valor -> . number
    (18) valor -> . BOOLEAN
    (19) valor -> . string
    (20) valor -> . VARIABLE
    (21) valor -> . estructuras_datos
    (22) valor -> . funciones
    (23) valor -> . valor
    (71) number -> . INTEGER
    (72) number -> . FLOAT
    (24) string -> . STRING
    (25) string -> . COMILLA_DOBLE STRING COMILLA_DOBLE
    (26) string -> . COMILLA_SIMPLE STRING COMILLA_SIMPLE
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (89) funciones -> . valor LPAREN valor RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN

    ARGUMENTO       shift and go to state 38
    BOOLEAN         shift and go to state 40
    VARIABLE        shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    STRING          shift and go to state 47
    COMILLA_DOBLE   shift and go to state 48
    COMILLA_SIMPLE  shift and go to state 49
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    valor                          shift and go to state 152
    number                         shift and go to state 39
    string                         shift and go to state 41
    estructuras_datos              shift and go to state 43
    funciones                      shift and go to state 44
    array                          shift and go to state 23
    queue                          shift and go to state 15
    splfixedarray                  shift and go to state 17

state 137

    (101) for -> FOR LPAREN VARIABLE EQUAL . INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    INTEGER         shift and go to state 153


state 138

    (31) queue -> NEW SPLQUEUE LPAREN RPAREN .

    $end            reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    RKEY            reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    ECHO            reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    PRINT           reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    VARIABLE        reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    FUNCTION        reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    FOPEN           reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    FSCANF          reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IF              reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    WHILE           reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    FOR             reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    LPAREN          reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    NEW             reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    ENDLINE         reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    COMA            reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    RPAREN          reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    BOOLEAN_AND     reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    BOOLEAN_OR      reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    AND             reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    OR              reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    XOR             reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IS_EQUAL        reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IS_GREATER_OR_EQUAL reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IS_NOT_EQUAL    reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IS_SMALLER_OR_EQUAL reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IS_GREATER      reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)
    IS_SMALLER      reduce using rule 31 (queue -> NEW SPLQUEUE LPAREN RPAREN .)


state 139

    (34) splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER . RPAREN

    RPAREN          shift and go to state 154


state 140

    (89) funciones -> valor LPAREN valor RPAREN . LKEY cuerpo RKEY

    LKEY            shift and go to state 155


state 141

    (15) salida -> PRINT LPAREN valor RPAREN ENDLINE .

    ECHO            reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    PRINT           reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    VARIABLE        reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    FUNCTION        reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    FOPEN           reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    FSCANF          reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    IF              reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    WHILE           reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    FOR             reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    LPAREN          reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    NEW             reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    $end            reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)
    RKEY            reduce using rule 15 (salida -> PRINT LPAREN valor RPAREN ENDLINE .)


state 142

    (63) expresiones_logicas -> valor operador expresiones_logicas .

    ENDLINE         reduce using rule 63 (expresiones_logicas -> valor operador expresiones_logicas .)
    RPAREN          reduce using rule 63 (expresiones_logicas -> valor operador expresiones_logicas .)


state 143

    (79) expresion_aritmetica -> number .
    (80) expresion_aritmetica -> number . operador_aritmetico expresion_aritmetica
    (73) operador_aritmetico -> . ADDITION
    (74) operador_aritmetico -> . SUBTRACTION
    (75) operador_aritmetico -> . MULTIPLICATION
    (76) operador_aritmetico -> . DIVISION
    (77) operador_aritmetico -> . MODULO
    (78) operador_aritmetico -> . EXPONENTIATION

    ENDLINE         reduce using rule 79 (expresion_aritmetica -> number .)
    RPAREN          reduce using rule 79 (expresion_aritmetica -> number .)
    ADDITION        shift and go to state 121
    SUBTRACTION     shift and go to state 122
    MULTIPLICATION  shift and go to state 123
    DIVISION        shift and go to state 124
    MODULO          shift and go to state 125
    EXPONENTIATION  shift and go to state 126

    operador_aritmetico            shift and go to state 120

state 144

    (80) expresion_aritmetica -> number operador_aritmetico expresion_aritmetica .

    ENDLINE         reduce using rule 80 (expresion_aritmetica -> number operador_aritmetico expresion_aritmetica .)
    RPAREN          reduce using rule 80 (expresion_aritmetica -> number operador_aritmetico expresion_aritmetica .)


state 145

    (36) push -> queue_variable ARROW PUSH LPAREN valor . RPAREN ENDLINE
    (23) valor -> valor .
    (89) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          shift and go to state 156
    LPAREN          shift and go to state 70

  ! RPAREN          [ reduce using rule 23 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 23 (valor -> valor .) ]


state 146

    (37) pop -> queue_variable ARROW POP LPAREN RPAREN . ENDLINE

    ENDLINE         shift and go to state 157


state 147

    (27) function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN . LKEY ARGUMENTO RKEY

    LKEY            shift and go to state 158


state 148

    (59) else -> if ELSE LKEY cuerpo RKEY .

    ECHO            reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)
    PRINT           reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)
    VARIABLE        reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)
    FUNCTION        reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)
    FOPEN           reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)
    FSCANF          reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)
    IF              reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)
    WHILE           reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)
    FOR             reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)
    LPAREN          reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)
    NEW             reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)
    $end            reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)
    RKEY            reduce using rule 59 (else -> if ELSE LKEY cuerpo RKEY .)


state 149

    (82) abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .

    $end            reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    RKEY            reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    ECHO            reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    PRINT           reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    VARIABLE        reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    FUNCTION        reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    FOPEN           reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    FSCANF          reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    IF              reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    WHILE           reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    FOR             reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    LPAREN          reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    NEW             reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)
    COMA            reduce using rule 82 (abrir_archivo -> FOPEN LPAREN string RPAREN ENDLINE .)


state 150

    (83) lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string . RPAREN ENDLINE

    RPAREN          shift and go to state 159


state 151

    (58) if -> IF LPAREN expresion RPAREN LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . estructuras_datos
    (10) cuerpo -> . metodos
    (11) cuerpo -> . metodos cuerpo
    (12) cuerpo -> . abrir_archivo
    (13) cuerpo -> . lectura_archivo
    (14) salida -> . ECHO valor ENDLINE
    (15) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (29) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (30) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (33) asignacion -> . splfixedarray_variable operador_asignacion splfixedarray ENDLINE
    (27) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (53) estructuras_control -> . if
    (54) estructuras_control -> . else
    (55) estructuras_control -> . while
    (56) estructuras_control -> . for
    (57) estructuras_control -> . estructuras_control
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (38) metodos -> . push
    (39) metodos -> . pop
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (83) lectura_archivo -> . FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
    (32) queue_variable -> . VARIABLE
    (35) splfixedarray_variable -> . VARIABLE
    (58) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (59) else -> . if ELSE LKEY cuerpo RKEY
    (84) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (101) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
    (36) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 10
    PRINT           shift and go to state 11
    VARIABLE        shift and go to state 13
    FUNCTION        shift and go to state 18
    FOPEN           shift and go to state 26
    FSCANF          shift and go to state 27
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    cuerpo                         shift and go to state 160
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    estructuras_datos              shift and go to state 6
    metodos                        shift and go to state 7
    abrir_archivo                  shift and go to state 8
    lectura_archivo                shift and go to state 9
    queue_variable                 shift and go to state 14
    queue                          shift and go to state 15
    splfixedarray_variable         shift and go to state 16
    splfixedarray                  shift and go to state 17
    if                             shift and go to state 19
    else                           shift and go to state 20
    while                          shift and go to state 21
    for                            shift and go to state 22
    array                          shift and go to state 23
    push                           shift and go to state 24
    pop                            shift and go to state 25

state 152

    (84) while -> WHILE LPAREN valor operador_comparacion valor . RPAREN COLON cuerpo
    (85) while -> WHILE LPAREN valor operador_comparacion valor . RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (23) valor -> valor .
    (89) funciones -> valor . LPAREN valor RPAREN LKEY cuerpo RKEY

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          shift and go to state 161
    LPAREN          shift and go to state 70

  ! RPAREN          [ reduce using rule 23 (valor -> valor .) ]
  ! LPAREN          [ reduce using rule 23 (valor -> valor .) ]


state 153

    (101) for -> FOR LPAREN VARIABLE EQUAL INTEGER . ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ENDLINE         shift and go to state 162


state 154

    (34) splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .

    $end            reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    RKEY            reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    ECHO            reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    PRINT           reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    VARIABLE        reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    FUNCTION        reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    FOPEN           reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    FSCANF          reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    IF              reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    WHILE           reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    FOR             reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    LPAREN          reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    NEW             reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    ENDLINE         reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    COMA            reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    RPAREN          reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    BOOLEAN_AND     reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    BOOLEAN_OR      reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    AND             reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    OR              reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    XOR             reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    IS_EQUAL        reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    IS_GREATER_OR_EQUAL reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    IS_NOT_EQUAL    reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    IS_SMALLER_OR_EQUAL reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    IS_GREATER      reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)
    IS_SMALLER      reduce using rule 34 (splfixedarray -> NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN .)


state 155

    (89) funciones -> valor LPAREN valor RPAREN LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . estructuras_datos
    (10) cuerpo -> . metodos
    (11) cuerpo -> . metodos cuerpo
    (12) cuerpo -> . abrir_archivo
    (13) cuerpo -> . lectura_archivo
    (14) salida -> . ECHO valor ENDLINE
    (15) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (29) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (30) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (33) asignacion -> . splfixedarray_variable operador_asignacion splfixedarray ENDLINE
    (27) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (53) estructuras_control -> . if
    (54) estructuras_control -> . else
    (55) estructuras_control -> . while
    (56) estructuras_control -> . for
    (57) estructuras_control -> . estructuras_control
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (38) metodos -> . push
    (39) metodos -> . pop
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (83) lectura_archivo -> . FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
    (32) queue_variable -> . VARIABLE
    (35) splfixedarray_variable -> . VARIABLE
    (58) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (59) else -> . if ELSE LKEY cuerpo RKEY
    (84) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (101) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
    (36) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 10
    PRINT           shift and go to state 11
    VARIABLE        shift and go to state 13
    FUNCTION        shift and go to state 18
    FOPEN           shift and go to state 26
    FSCANF          shift and go to state 27
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    cuerpo                         shift and go to state 163
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    estructuras_datos              shift and go to state 6
    metodos                        shift and go to state 7
    abrir_archivo                  shift and go to state 8
    lectura_archivo                shift and go to state 9
    queue_variable                 shift and go to state 14
    queue                          shift and go to state 15
    splfixedarray_variable         shift and go to state 16
    splfixedarray                  shift and go to state 17
    if                             shift and go to state 19
    else                           shift and go to state 20
    while                          shift and go to state 21
    for                            shift and go to state 22
    array                          shift and go to state 23
    push                           shift and go to state 24
    pop                            shift and go to state 25

state 156

    (36) push -> queue_variable ARROW PUSH LPAREN valor RPAREN . ENDLINE

    ENDLINE         shift and go to state 164


state 157

    (37) pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .

    ECHO            reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    PRINT           reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    VARIABLE        reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    FUNCTION        reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    FOPEN           reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    FSCANF          reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    IF              reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    WHILE           reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    FOR             reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    LPAREN          reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    NEW             reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    $end            reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)
    RKEY            reduce using rule 37 (pop -> queue_variable ARROW POP LPAREN RPAREN ENDLINE .)


state 158

    (27) function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY . ARGUMENTO RKEY

    ARGUMENTO       shift and go to state 165


state 159

    (83) lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN . ENDLINE

    ENDLINE         shift and go to state 166


state 160

    (58) if -> IF LPAREN expresion RPAREN LKEY cuerpo . RKEY

    RKEY            shift and go to state 167


state 161

    (84) while -> WHILE LPAREN valor operador_comparacion valor RPAREN . COLON cuerpo
    (85) while -> WHILE LPAREN valor operador_comparacion valor RPAREN . LKEY TAB_VERTICAL cuerpo RKEY

    COLON           shift and go to state 168
    LKEY            shift and go to state 169


state 162

    (101) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE . VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    VARIABLE        shift and go to state 170


state 163

    (89) funciones -> valor LPAREN valor RPAREN LKEY cuerpo . RKEY

    RKEY            shift and go to state 171


state 164

    (36) push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .

    ECHO            reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    PRINT           reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    VARIABLE        reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    FUNCTION        reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    FOPEN           reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    FSCANF          reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    IF              reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    WHILE           reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    FOR             reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    LPAREN          reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    NEW             reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    $end            reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)
    RKEY            reduce using rule 36 (push -> queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE .)


state 165

    (27) function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO . RKEY

    RKEY            shift and go to state 172


state 166

    (83) lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .

    $end            reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)
    RKEY            reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)
    ECHO            reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)
    PRINT           reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)
    VARIABLE        reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)
    FUNCTION        reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)
    FOPEN           reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)
    FSCANF          reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)
    IF              reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)
    WHILE           reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)
    FOR             reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)
    LPAREN          reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)
    NEW             reduce using rule 83 (lectura_archivo -> FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE .)


state 167

    (58) if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .

    ELSE            reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    ECHO            reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    PRINT           reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    VARIABLE        reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    FUNCTION        reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    FOPEN           reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    FSCANF          reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    IF              reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    WHILE           reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    FOR             reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    LPAREN          reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    NEW             reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    $end            reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)
    RKEY            reduce using rule 58 (if -> IF LPAREN expresion RPAREN LKEY cuerpo RKEY .)


state 168

    (84) while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON . cuerpo
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . estructuras_datos
    (10) cuerpo -> . metodos
    (11) cuerpo -> . metodos cuerpo
    (12) cuerpo -> . abrir_archivo
    (13) cuerpo -> . lectura_archivo
    (14) salida -> . ECHO valor ENDLINE
    (15) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (29) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (30) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (33) asignacion -> . splfixedarray_variable operador_asignacion splfixedarray ENDLINE
    (27) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (53) estructuras_control -> . if
    (54) estructuras_control -> . else
    (55) estructuras_control -> . while
    (56) estructuras_control -> . for
    (57) estructuras_control -> . estructuras_control
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (38) metodos -> . push
    (39) metodos -> . pop
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (83) lectura_archivo -> . FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
    (32) queue_variable -> . VARIABLE
    (35) splfixedarray_variable -> . VARIABLE
    (58) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (59) else -> . if ELSE LKEY cuerpo RKEY
    (84) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (101) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
    (36) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 10
    PRINT           shift and go to state 11
    VARIABLE        shift and go to state 13
    FUNCTION        shift and go to state 18
    FOPEN           shift and go to state 26
    FSCANF          shift and go to state 27
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    cuerpo                         shift and go to state 173
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    estructuras_datos              shift and go to state 6
    metodos                        shift and go to state 7
    abrir_archivo                  shift and go to state 8
    lectura_archivo                shift and go to state 9
    queue_variable                 shift and go to state 14
    queue                          shift and go to state 15
    splfixedarray_variable         shift and go to state 16
    splfixedarray                  shift and go to state 17
    if                             shift and go to state 19
    else                           shift and go to state 20
    while                          shift and go to state 21
    for                            shift and go to state 22
    array                          shift and go to state 23
    push                           shift and go to state 24
    pop                            shift and go to state 25

state 169

    (85) while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY . TAB_VERTICAL cuerpo RKEY

    TAB_VERTICAL    shift and go to state 174


state 170

    (101) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE . operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (46) operador_comparacion -> . IS_EQUAL
    (47) operador_comparacion -> . IS_GREATER_OR_EQUAL
    (48) operador_comparacion -> . IS_NOT_EQUAL
    (49) operador_comparacion -> . IS_SMALLER_OR_EQUAL
    (50) operador_comparacion -> . IS_GREATER
    (51) operador_comparacion -> . IS_SMALLER

    IS_EQUAL        shift and go to state 113
    IS_GREATER_OR_EQUAL shift and go to state 114
    IS_NOT_EQUAL    shift and go to state 115
    IS_SMALLER_OR_EQUAL shift and go to state 116
    IS_GREATER      shift and go to state 117
    IS_SMALLER      shift and go to state 118

    operador_comparacion           shift and go to state 175

state 171

    (89) funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .

    ENDLINE         reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    LPAREN          reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    COMA            reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    RPAREN          reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    BOOLEAN_AND     reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    BOOLEAN_OR      reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    AND             reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    OR              reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    XOR             reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_EQUAL        reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_GREATER_OR_EQUAL reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_NOT_EQUAL    reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_SMALLER_OR_EQUAL reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_GREATER      reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)
    IS_SMALLER      reduce using rule 89 (funciones -> valor LPAREN valor RPAREN LKEY cuerpo RKEY .)


state 172

    (27) function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .

    ECHO            reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    PRINT           reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    VARIABLE        reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    FUNCTION        reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    FOPEN           reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    FSCANF          reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    IF              reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    WHILE           reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    FOR             reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    LPAREN          reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    NEW             reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    $end            reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)
    RKEY            reduce using rule 27 (function -> FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY .)


state 173

    (84) while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .

    ECHO            reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    PRINT           reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    VARIABLE        reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    FUNCTION        reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    FOPEN           reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    FSCANF          reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    IF              reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    WHILE           reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    FOR             reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    LPAREN          reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    NEW             reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    $end            reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)
    RKEY            reduce using rule 84 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo .)


state 174

    (85) while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . estructuras_datos
    (10) cuerpo -> . metodos
    (11) cuerpo -> . metodos cuerpo
    (12) cuerpo -> . abrir_archivo
    (13) cuerpo -> . lectura_archivo
    (14) salida -> . ECHO valor ENDLINE
    (15) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (29) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (30) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (33) asignacion -> . splfixedarray_variable operador_asignacion splfixedarray ENDLINE
    (27) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (53) estructuras_control -> . if
    (54) estructuras_control -> . else
    (55) estructuras_control -> . while
    (56) estructuras_control -> . for
    (57) estructuras_control -> . estructuras_control
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (38) metodos -> . push
    (39) metodos -> . pop
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (83) lectura_archivo -> . FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
    (32) queue_variable -> . VARIABLE
    (35) splfixedarray_variable -> . VARIABLE
    (58) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (59) else -> . if ELSE LKEY cuerpo RKEY
    (84) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (101) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
    (36) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 10
    PRINT           shift and go to state 11
    VARIABLE        shift and go to state 13
    FUNCTION        shift and go to state 18
    FOPEN           shift and go to state 26
    FSCANF          shift and go to state 27
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    cuerpo                         shift and go to state 176
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    estructuras_datos              shift and go to state 6
    metodos                        shift and go to state 7
    abrir_archivo                  shift and go to state 8
    lectura_archivo                shift and go to state 9
    queue_variable                 shift and go to state 14
    queue                          shift and go to state 15
    splfixedarray_variable         shift and go to state 16
    splfixedarray                  shift and go to state 17
    if                             shift and go to state 19
    else                           shift and go to state 20
    while                          shift and go to state 21
    for                            shift and go to state 22
    array                          shift and go to state 23
    push                           shift and go to state 24
    pop                            shift and go to state 25

state 175

    (101) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion . INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    INTEGER         shift and go to state 177


state 176

    (85) while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo . RKEY

    RKEY            shift and go to state 178


state 177

    (101) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER . ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY

    ENDLINE         shift and go to state 179


state 178

    (85) while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .

    ECHO            reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    PRINT           reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    VARIABLE        reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    FUNCTION        reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    FOPEN           reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    FSCANF          reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    IF              reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    WHILE           reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    FOR             reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    LPAREN          reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    NEW             reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    $end            reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)
    RKEY            reduce using rule 85 (while -> WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY .)


state 179

    (101) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE . forma_operacion RPAREN LKEY cuerpo RKEY
    (96) forma_operacion -> . VARIABLE OPERADOR_INCREMENTO
    (97) forma_operacion -> . OPERADOR_INCREMENTO VARIABLE
    (98) forma_operacion -> . VARIABLE OPERADOR_DECREMENTO
    (99) forma_operacion -> . OPERADOR_DECREMENTO VARIABLE
    (100) forma_operacion -> . VARIABLE EQUAL VARIABLE tipo_operador INTEGER

    VARIABLE        shift and go to state 180
    OPERADOR_INCREMENTO shift and go to state 182
    OPERADOR_DECREMENTO shift and go to state 183

    forma_operacion                shift and go to state 181

state 180

    (96) forma_operacion -> VARIABLE . OPERADOR_INCREMENTO
    (98) forma_operacion -> VARIABLE . OPERADOR_DECREMENTO
    (100) forma_operacion -> VARIABLE . EQUAL VARIABLE tipo_operador INTEGER

    OPERADOR_INCREMENTO shift and go to state 184
    OPERADOR_DECREMENTO shift and go to state 185
    EQUAL           shift and go to state 186


state 181

    (101) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion . RPAREN LKEY cuerpo RKEY

    RPAREN          shift and go to state 187


state 182

    (97) forma_operacion -> OPERADOR_INCREMENTO . VARIABLE

    VARIABLE        shift and go to state 188


state 183

    (99) forma_operacion -> OPERADOR_DECREMENTO . VARIABLE

    VARIABLE        shift and go to state 189


state 184

    (96) forma_operacion -> VARIABLE OPERADOR_INCREMENTO .

    RPAREN          reduce using rule 96 (forma_operacion -> VARIABLE OPERADOR_INCREMENTO .)


state 185

    (98) forma_operacion -> VARIABLE OPERADOR_DECREMENTO .

    RPAREN          reduce using rule 98 (forma_operacion -> VARIABLE OPERADOR_DECREMENTO .)


state 186

    (100) forma_operacion -> VARIABLE EQUAL . VARIABLE tipo_operador INTEGER

    VARIABLE        shift and go to state 190


state 187

    (101) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN . LKEY cuerpo RKEY

    LKEY            shift and go to state 191


state 188

    (97) forma_operacion -> OPERADOR_INCREMENTO VARIABLE .

    RPAREN          reduce using rule 97 (forma_operacion -> OPERADOR_INCREMENTO VARIABLE .)


state 189

    (99) forma_operacion -> OPERADOR_DECREMENTO VARIABLE .

    RPAREN          reduce using rule 99 (forma_operacion -> OPERADOR_DECREMENTO VARIABLE .)


state 190

    (100) forma_operacion -> VARIABLE EQUAL VARIABLE . tipo_operador INTEGER
    (90) tipo_operador -> . ADDITION
    (91) tipo_operador -> . SUBTRACTION
    (92) tipo_operador -> . MULTIPLICATION
    (93) tipo_operador -> . DIVISION
    (94) tipo_operador -> . MODULO
    (95) tipo_operador -> . EXPONENTIATION

    ADDITION        shift and go to state 193
    SUBTRACTION     shift and go to state 194
    MULTIPLICATION  shift and go to state 195
    DIVISION        shift and go to state 196
    MODULO          shift and go to state 197
    EXPONENTIATION  shift and go to state 198

    tipo_operador                  shift and go to state 192

state 191

    (101) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY . cuerpo RKEY
    (1) cuerpo -> . salida
    (2) cuerpo -> . salida cuerpo
    (3) cuerpo -> . asignacion
    (4) cuerpo -> . asignacion cuerpo
    (5) cuerpo -> . function
    (6) cuerpo -> . function cuerpo
    (7) cuerpo -> . estructuras_control
    (8) cuerpo -> . estructuras_control cuerpo
    (9) cuerpo -> . estructuras_datos
    (10) cuerpo -> . metodos
    (11) cuerpo -> . metodos cuerpo
    (12) cuerpo -> . abrir_archivo
    (13) cuerpo -> . lectura_archivo
    (14) salida -> . ECHO valor ENDLINE
    (15) salida -> . PRINT LPAREN valor RPAREN ENDLINE
    (28) asignacion -> . VARIABLE operador_asignacion valor ENDLINE
    (29) asignacion -> . VARIABLE operador_asignacion expresion ENDLINE
    (30) asignacion -> . queue_variable operador_asignacion queue ENDLINE
    (33) asignacion -> . splfixedarray_variable operador_asignacion splfixedarray ENDLINE
    (27) function -> . FUNCTION ARGUMENTO LPAREN VARIABLE RPAREN LKEY ARGUMENTO RKEY
    (53) estructuras_control -> . if
    (54) estructuras_control -> . else
    (55) estructuras_control -> . while
    (56) estructuras_control -> . for
    (57) estructuras_control -> . estructuras_control
    (43) estructuras_datos -> . array
    (44) estructuras_datos -> . queue
    (45) estructuras_datos -> . splfixedarray
    (38) metodos -> . push
    (39) metodos -> . pop
    (81) abrir_archivo -> . FOPEN LPAREN string RPAREN
    (82) abrir_archivo -> . FOPEN LPAREN string RPAREN ENDLINE
    (83) lectura_archivo -> . FSCANF LPAREN abrir_archivo COMA string RPAREN ENDLINE
    (32) queue_variable -> . VARIABLE
    (35) splfixedarray_variable -> . VARIABLE
    (58) if -> . IF LPAREN expresion RPAREN LKEY cuerpo RKEY
    (59) else -> . if ELSE LKEY cuerpo RKEY
    (84) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN COLON cuerpo
    (85) while -> . WHILE LPAREN valor operador_comparacion valor RPAREN LKEY TAB_VERTICAL cuerpo RKEY
    (101) for -> . FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY
    (86) array -> . LPAREN valorArreglo RPAREN ENDLINE
    (31) queue -> . NEW SPLQUEUE LPAREN RPAREN
    (34) splfixedarray -> . NEW SPLFIXEDARRAY LPAREN INTEGER RPAREN
    (36) push -> . queue_variable ARROW PUSH LPAREN valor RPAREN ENDLINE
    (37) pop -> . queue_variable ARROW POP LPAREN RPAREN ENDLINE

    ECHO            shift and go to state 10
    PRINT           shift and go to state 11
    VARIABLE        shift and go to state 13
    FUNCTION        shift and go to state 18
    FOPEN           shift and go to state 26
    FSCANF          shift and go to state 27
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 12
    NEW             shift and go to state 31

    cuerpo                         shift and go to state 199
    salida                         shift and go to state 2
    asignacion                     shift and go to state 3
    function                       shift and go to state 4
    estructuras_control            shift and go to state 5
    estructuras_datos              shift and go to state 6
    metodos                        shift and go to state 7
    abrir_archivo                  shift and go to state 8
    lectura_archivo                shift and go to state 9
    queue_variable                 shift and go to state 14
    queue                          shift and go to state 15
    splfixedarray_variable         shift and go to state 16
    splfixedarray                  shift and go to state 17
    if                             shift and go to state 19
    else                           shift and go to state 20
    while                          shift and go to state 21
    for                            shift and go to state 22
    array                          shift and go to state 23
    push                           shift and go to state 24
    pop                            shift and go to state 25

state 192

    (100) forma_operacion -> VARIABLE EQUAL VARIABLE tipo_operador . INTEGER

    INTEGER         shift and go to state 200


state 193

    (90) tipo_operador -> ADDITION .

    INTEGER         reduce using rule 90 (tipo_operador -> ADDITION .)


state 194

    (91) tipo_operador -> SUBTRACTION .

    INTEGER         reduce using rule 91 (tipo_operador -> SUBTRACTION .)


state 195

    (92) tipo_operador -> MULTIPLICATION .

    INTEGER         reduce using rule 92 (tipo_operador -> MULTIPLICATION .)


state 196

    (93) tipo_operador -> DIVISION .

    INTEGER         reduce using rule 93 (tipo_operador -> DIVISION .)


state 197

    (94) tipo_operador -> MODULO .

    INTEGER         reduce using rule 94 (tipo_operador -> MODULO .)


state 198

    (95) tipo_operador -> EXPONENTIATION .

    INTEGER         reduce using rule 95 (tipo_operador -> EXPONENTIATION .)


state 199

    (101) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo . RKEY

    RKEY            shift and go to state 201


state 200

    (100) forma_operacion -> VARIABLE EQUAL VARIABLE tipo_operador INTEGER .

    RPAREN          reduce using rule 100 (forma_operacion -> VARIABLE EQUAL VARIABLE tipo_operador INTEGER .)


state 201

    (101) for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .

    ECHO            reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    PRINT           reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    VARIABLE        reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    FUNCTION        reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    FOPEN           reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    FSCANF          reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    IF              reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    WHILE           reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    FOR             reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    LPAREN          reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    NEW             reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    $end            reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)
    RKEY            reduce using rule 101 (for -> FOR LPAREN VARIABLE EQUAL INTEGER ENDLINE VARIABLE operador_comparacion INTEGER ENDLINE forma_operacion RPAREN LKEY cuerpo RKEY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ECHO in state 2 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 2 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 2 resolved as shift
WARNING: shift/reduce conflict for FOPEN in state 2 resolved as shift
WARNING: shift/reduce conflict for FSCANF in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 2 resolved as shift
WARNING: shift/reduce conflict for NEW in state 2 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 3 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 3 resolved as shift
WARNING: shift/reduce conflict for FOPEN in state 3 resolved as shift
WARNING: shift/reduce conflict for FSCANF in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 3 resolved as shift
WARNING: shift/reduce conflict for NEW in state 3 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 4 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 4 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 4 resolved as shift
WARNING: shift/reduce conflict for FOPEN in state 4 resolved as shift
WARNING: shift/reduce conflict for FSCANF in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 4 resolved as shift
WARNING: shift/reduce conflict for NEW in state 4 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 5 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 5 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 5 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 5 resolved as shift
WARNING: shift/reduce conflict for FOPEN in state 5 resolved as shift
WARNING: shift/reduce conflict for FSCANF in state 5 resolved as shift
WARNING: shift/reduce conflict for IF in state 5 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 5 resolved as shift
WARNING: shift/reduce conflict for FOR in state 5 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 5 resolved as shift
WARNING: shift/reduce conflict for NEW in state 5 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 7 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 7 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 7 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 7 resolved as shift
WARNING: shift/reduce conflict for FOPEN in state 7 resolved as shift
WARNING: shift/reduce conflict for FSCANF in state 7 resolved as shift
WARNING: shift/reduce conflict for IF in state 7 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 7 resolved as shift
WARNING: shift/reduce conflict for FOR in state 7 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 7 resolved as shift
WARNING: shift/reduce conflict for NEW in state 7 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 13 resolved as shift
WARNING: shift/reduce conflict for PLUS_EQUAL in state 13 resolved as shift
WARNING: shift/reduce conflict for CONCAT_EQUAL in state 13 resolved as shift
WARNING: shift/reduce conflict for ENDLINE in state 37 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 37 resolved as shift
WARNING: shift/reduce conflict for COMA in state 52 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 52 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 73 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 73 resolved as shift
WARNING: shift/reduce conflict for ENDLINE in state 76 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 76 resolved as shift
WARNING: shift/reduce conflict for ENDLINE in state 76 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_AND in state 76 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_OR in state 76 resolved as shift
WARNING: shift/reduce conflict for AND in state 76 resolved as shift
WARNING: shift/reduce conflict for OR in state 76 resolved as shift
WARNING: shift/reduce conflict for XOR in state 76 resolved as shift
WARNING: shift/reduce conflict for IS_EQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for IS_GREATER_OR_EQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for IS_NOT_EQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for IS_SMALLER_OR_EQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for IS_GREATER in state 76 resolved as shift
WARNING: shift/reduce conflict for IS_SMALLER in state 76 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 92 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_AND in state 92 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_OR in state 92 resolved as shift
WARNING: shift/reduce conflict for AND in state 92 resolved as shift
WARNING: shift/reduce conflict for OR in state 92 resolved as shift
WARNING: shift/reduce conflict for XOR in state 92 resolved as shift
WARNING: shift/reduce conflict for IS_EQUAL in state 92 resolved as shift
WARNING: shift/reduce conflict for IS_GREATER_OR_EQUAL in state 92 resolved as shift
WARNING: shift/reduce conflict for IS_NOT_EQUAL in state 92 resolved as shift
WARNING: shift/reduce conflict for IS_SMALLER_OR_EQUAL in state 92 resolved as shift
WARNING: shift/reduce conflict for IS_GREATER in state 92 resolved as shift
WARNING: shift/reduce conflict for IS_SMALLER in state 92 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 94 resolved as shift
WARNING: shift/reduce conflict for IS_EQUAL in state 94 resolved as shift
WARNING: shift/reduce conflict for IS_GREATER_OR_EQUAL in state 94 resolved as shift
WARNING: shift/reduce conflict for IS_NOT_EQUAL in state 94 resolved as shift
WARNING: shift/reduce conflict for IS_SMALLER_OR_EQUAL in state 94 resolved as shift
WARNING: shift/reduce conflict for IS_GREATER in state 94 resolved as shift
WARNING: shift/reduce conflict for IS_SMALLER in state 94 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 98 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 98 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 145 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 145 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 152 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 152 resolved as shift
WARNING: reduce/reduce conflict in state 5 resolved using rule (cuerpo -> estructuras_control)
WARNING: rejected rule (estructuras_control -> estructuras_control) in state 5
WARNING: reduce/reduce conflict in state 13 resolved using rule (queue_variable -> VARIABLE)
WARNING: rejected rule (splfixedarray_variable -> VARIABLE) in state 13
WARNING: reduce/reduce conflict in state 52 resolved using rule (valor -> valor)
WARNING: rejected rule (valorArreglo -> valor) in state 52
WARNING: reduce/reduce conflict in state 78 resolved using rule (valor -> number)
WARNING: rejected rule (expresion_aritmetica -> number) in state 78
WARNING: reduce/reduce conflict in state 92 resolved using rule (valor -> valor)
WARNING: rejected rule (expresiones_logicas -> valor) in state 92
WARNING: reduce/reduce conflict in state 93 resolved using rule (valor -> number)
WARNING: rejected rule (expresion_aritmetica -> number) in state 93
WARNING: Rule (estructuras_control -> estructuras_control) is never reduced
WARNING: Rule (splfixedarray_variable -> VARIABLE) is never reduced
WARNING: Rule (valorArreglo -> valor) is never reduced
WARNING: Rule (expresiones_logicas -> valor) is never reduced
